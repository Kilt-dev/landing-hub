{"ast":null,"code":"/*!\n * HTML Parser By John Resig (ejohn.org)\n * Modified by Juriy \"kangax\" Zaytsev\n * Original code by Erik Arvidsson, Mozilla Public License\n * http://erik.eae.net/simplehtmlparser/simplehtmlparser.js\n */\n\n/*\n * // Use like so:\n * HTMLParser(htmlString, {\n *     start: function(tag, attrs, unary) {},\n *     end: function(tag) {},\n *     chars: function(text) {},\n *     comment: function(text) {}\n * });\n *\n * // or to get an XML string:\n * HTMLtoXML(htmlString);\n *\n * // or to get an XML DOM Document\n * HTMLtoDOM(htmlString);\n *\n * // or to inject into an existing document/DOM node\n * HTMLtoDOM(htmlString, document);\n * HTMLtoDOM(htmlString, document.body);\n *\n */\n\n/* global ActiveXObject, DOMDocument */\n\nimport { replaceAsync } from './utils.js';\nclass CaseInsensitiveSet extends Set {\n  has(str) {\n    return super.has(str.toLowerCase());\n  }\n}\n\n// Regular Expressions for parsing tags and attributes\nconst singleAttrIdentifier = /([^\\s\"'<>/=]+)/;\nconst singleAttrAssigns = [/=/];\nconst singleAttrValues = [\n// attr value double quotes\n/\"([^\"]*)\"+/.source,\n// attr value, single quotes\n/'([^']*)'+/.source,\n// attr value, no quotes\n/([^ \\t\\n\\f\\r\"'`=<>]+)/.source];\n// https://www.w3.org/TR/1999/REC-xml-names-19990114/#NT-QName\nconst qnameCapture = function () {\n  // based on https://www.npmjs.com/package/ncname\n  const combiningChar = '\\\\u0300-\\\\u0345\\\\u0360\\\\u0361\\\\u0483-\\\\u0486\\\\u0591-\\\\u05A1\\\\u05A3-\\\\u05B9\\\\u05BB-\\\\u05BD\\\\u05BF\\\\u05C1\\\\u05C2\\\\u05C4\\\\u064B-\\\\u0652\\\\u0670\\\\u06D6-\\\\u06E4\\\\u06E7\\\\u06E8\\\\u06EA-\\\\u06ED\\\\u0901-\\\\u0903\\\\u093C\\\\u093E-\\\\u094D\\\\u0951-\\\\u0954\\\\u0962\\\\u0963\\\\u0981-\\\\u0983\\\\u09BC\\\\u09BE-\\\\u09C4\\\\u09C7\\\\u09C8\\\\u09CB-\\\\u09CD\\\\u09D7\\\\u09E2\\\\u09E3\\\\u0A02\\\\u0A3C\\\\u0A3E-\\\\u0A42\\\\u0A47\\\\u0A48\\\\u0A4B-\\\\u0A4D\\\\u0A70\\\\u0A71\\\\u0A81-\\\\u0A83\\\\u0ABC\\\\u0ABE-\\\\u0AC5\\\\u0AC7-\\\\u0AC9\\\\u0ACB-\\\\u0ACD\\\\u0B01-\\\\u0B03\\\\u0B3C\\\\u0B3E-\\\\u0B43\\\\u0B47\\\\u0B48\\\\u0B4B-\\\\u0B4D\\\\u0B56\\\\u0B57\\\\u0B82\\\\u0B83\\\\u0BBE-\\\\u0BC2\\\\u0BC6-\\\\u0BC8\\\\u0BCA-\\\\u0BCD\\\\u0BD7\\\\u0C01-\\\\u0C03\\\\u0C3E-\\\\u0C44\\\\u0C46-\\\\u0C48\\\\u0C4A-\\\\u0C4D\\\\u0C55\\\\u0C56\\\\u0C82\\\\u0C83\\\\u0CBE-\\\\u0CC4\\\\u0CC6-\\\\u0CC8\\\\u0CCA-\\\\u0CCD\\\\u0CD5\\\\u0CD6\\\\u0D02\\\\u0D03\\\\u0D3E-\\\\u0D43\\\\u0D46-\\\\u0D48\\\\u0D4A-\\\\u0D4D\\\\u0D57\\\\u0E31\\\\u0E34-\\\\u0E3A\\\\u0E47-\\\\u0E4E\\\\u0EB1\\\\u0EB4-\\\\u0EB9\\\\u0EBB\\\\u0EBC\\\\u0EC8-\\\\u0ECD\\\\u0F18\\\\u0F19\\\\u0F35\\\\u0F37\\\\u0F39\\\\u0F3E\\\\u0F3F\\\\u0F71-\\\\u0F84\\\\u0F86-\\\\u0F8B\\\\u0F90-\\\\u0F95\\\\u0F97\\\\u0F99-\\\\u0FAD\\\\u0FB1-\\\\u0FB7\\\\u0FB9\\\\u20D0-\\\\u20DC\\\\u20E1\\\\u302A-\\\\u302F\\\\u3099\\\\u309A';\n  const digit = '0-9\\\\u0660-\\\\u0669\\\\u06F0-\\\\u06F9\\\\u0966-\\\\u096F\\\\u09E6-\\\\u09EF\\\\u0A66-\\\\u0A6F\\\\u0AE6-\\\\u0AEF\\\\u0B66-\\\\u0B6F\\\\u0BE7-\\\\u0BEF\\\\u0C66-\\\\u0C6F\\\\u0CE6-\\\\u0CEF\\\\u0D66-\\\\u0D6F\\\\u0E50-\\\\u0E59\\\\u0ED0-\\\\u0ED9\\\\u0F20-\\\\u0F29';\n  const extender = '\\\\xB7\\\\u02D0\\\\u02D1\\\\u0387\\\\u0640\\\\u0E46\\\\u0EC6\\\\u3005\\\\u3031-\\\\u3035\\\\u309D\\\\u309E\\\\u30FC-\\\\u30FE';\n  const letter = 'A-Za-z\\\\xC0-\\\\xD6\\\\xD8-\\\\xF6\\\\xF8-\\\\u0131\\\\u0134-\\\\u013E\\\\u0141-\\\\u0148\\\\u014A-\\\\u017E\\\\u0180-\\\\u01C3\\\\u01CD-\\\\u01F0\\\\u01F4\\\\u01F5\\\\u01FA-\\\\u0217\\\\u0250-\\\\u02A8\\\\u02BB-\\\\u02C1\\\\u0386\\\\u0388-\\\\u038A\\\\u038C\\\\u038E-\\\\u03A1\\\\u03A3-\\\\u03CE\\\\u03D0-\\\\u03D6\\\\u03DA\\\\u03DC\\\\u03DE\\\\u03E0\\\\u03E2-\\\\u03F3\\\\u0401-\\\\u040C\\\\u040E-\\\\u044F\\\\u0451-\\\\u045C\\\\u045E-\\\\u0481\\\\u0490-\\\\u04C4\\\\u04C7\\\\u04C8\\\\u04CB\\\\u04CC\\\\u04D0-\\\\u04EB\\\\u04EE-\\\\u04F5\\\\u04F8\\\\u04F9\\\\u0531-\\\\u0556\\\\u0559\\\\u0561-\\\\u0586\\\\u05D0-\\\\u05EA\\\\u05F0-\\\\u05F2\\\\u0621-\\\\u063A\\\\u0641-\\\\u064A\\\\u0671-\\\\u06B7\\\\u06BA-\\\\u06BE\\\\u06C0-\\\\u06CE\\\\u06D0-\\\\u06D3\\\\u06D5\\\\u06E5\\\\u06E6\\\\u0905-\\\\u0939\\\\u093D\\\\u0958-\\\\u0961\\\\u0985-\\\\u098C\\\\u098F\\\\u0990\\\\u0993-\\\\u09A8\\\\u09AA-\\\\u09B0\\\\u09B2\\\\u09B6-\\\\u09B9\\\\u09DC\\\\u09DD\\\\u09DF-\\\\u09E1\\\\u09F0\\\\u09F1\\\\u0A05-\\\\u0A0A\\\\u0A0F\\\\u0A10\\\\u0A13-\\\\u0A28\\\\u0A2A-\\\\u0A30\\\\u0A32\\\\u0A33\\\\u0A35\\\\u0A36\\\\u0A38\\\\u0A39\\\\u0A59-\\\\u0A5C\\\\u0A5E\\\\u0A72-\\\\u0A74\\\\u0A85-\\\\u0A8B\\\\u0A8D\\\\u0A8F-\\\\u0A91\\\\u0A93-\\\\u0AA8\\\\u0AAA-\\\\u0AB0\\\\u0AB2\\\\u0AB3\\\\u0AB5-\\\\u0AB9\\\\u0ABD\\\\u0AE0\\\\u0B05-\\\\u0B0C\\\\u0B0F\\\\u0B10\\\\u0B13-\\\\u0B28\\\\u0B2A-\\\\u0B30\\\\u0B32\\\\u0B33\\\\u0B36-\\\\u0B39\\\\u0B3D\\\\u0B5C\\\\u0B5D\\\\u0B5F-\\\\u0B61\\\\u0B85-\\\\u0B8A\\\\u0B8E-\\\\u0B90\\\\u0B92-\\\\u0B95\\\\u0B99\\\\u0B9A\\\\u0B9C\\\\u0B9E\\\\u0B9F\\\\u0BA3\\\\u0BA4\\\\u0BA8-\\\\u0BAA\\\\u0BAE-\\\\u0BB5\\\\u0BB7-\\\\u0BB9\\\\u0C05-\\\\u0C0C\\\\u0C0E-\\\\u0C10\\\\u0C12-\\\\u0C28\\\\u0C2A-\\\\u0C33\\\\u0C35-\\\\u0C39\\\\u0C60\\\\u0C61\\\\u0C85-\\\\u0C8C\\\\u0C8E-\\\\u0C90\\\\u0C92-\\\\u0CA8\\\\u0CAA-\\\\u0CB3\\\\u0CB5-\\\\u0CB9\\\\u0CDE\\\\u0CE0\\\\u0CE1\\\\u0D05-\\\\u0D0C\\\\u0D0E-\\\\u0D10\\\\u0D12-\\\\u0D28\\\\u0D2A-\\\\u0D39\\\\u0D60\\\\u0D61\\\\u0E01-\\\\u0E2E\\\\u0E30\\\\u0E32\\\\u0E33\\\\u0E40-\\\\u0E45\\\\u0E81\\\\u0E82\\\\u0E84\\\\u0E87\\\\u0E88\\\\u0E8A\\\\u0E8D\\\\u0E94-\\\\u0E97\\\\u0E99-\\\\u0E9F\\\\u0EA1-\\\\u0EA3\\\\u0EA5\\\\u0EA7\\\\u0EAA\\\\u0EAB\\\\u0EAD\\\\u0EAE\\\\u0EB0\\\\u0EB2\\\\u0EB3\\\\u0EBD\\\\u0EC0-\\\\u0EC4\\\\u0F40-\\\\u0F47\\\\u0F49-\\\\u0F69\\\\u10A0-\\\\u10C5\\\\u10D0-\\\\u10F6\\\\u1100\\\\u1102\\\\u1103\\\\u1105-\\\\u1107\\\\u1109\\\\u110B\\\\u110C\\\\u110E-\\\\u1112\\\\u113C\\\\u113E\\\\u1140\\\\u114C\\\\u114E\\\\u1150\\\\u1154\\\\u1155\\\\u1159\\\\u115F-\\\\u1161\\\\u1163\\\\u1165\\\\u1167\\\\u1169\\\\u116D\\\\u116E\\\\u1172\\\\u1173\\\\u1175\\\\u119E\\\\u11A8\\\\u11AB\\\\u11AE\\\\u11AF\\\\u11B7\\\\u11B8\\\\u11BA\\\\u11BC-\\\\u11C2\\\\u11EB\\\\u11F0\\\\u11F9\\\\u1E00-\\\\u1E9B\\\\u1EA0-\\\\u1EF9\\\\u1F00-\\\\u1F15\\\\u1F18-\\\\u1F1D\\\\u1F20-\\\\u1F45\\\\u1F48-\\\\u1F4D\\\\u1F50-\\\\u1F57\\\\u1F59\\\\u1F5B\\\\u1F5D\\\\u1F5F-\\\\u1F7D\\\\u1F80-\\\\u1FB4\\\\u1FB6-\\\\u1FBC\\\\u1FBE\\\\u1FC2-\\\\u1FC4\\\\u1FC6-\\\\u1FCC\\\\u1FD0-\\\\u1FD3\\\\u1FD6-\\\\u1FDB\\\\u1FE0-\\\\u1FEC\\\\u1FF2-\\\\u1FF4\\\\u1FF6-\\\\u1FFC\\\\u2126\\\\u212A\\\\u212B\\\\u212E\\\\u2180-\\\\u2182\\\\u3007\\\\u3021-\\\\u3029\\\\u3041-\\\\u3094\\\\u30A1-\\\\u30FA\\\\u3105-\\\\u312C\\\\u4E00-\\\\u9FA5\\\\uAC00-\\\\uD7A3';\n  const ncname = '[' + letter + '_][' + letter + digit + '\\\\.\\\\-_' + combiningChar + extender + ']*';\n  return '((?:' + ncname + '\\\\:)?' + ncname + ')';\n}();\nconst startTagOpen = new RegExp('^<' + qnameCapture);\nconst startTagClose = /^\\s*(\\/?)>/;\nexport const endTag = new RegExp('^<\\\\/' + qnameCapture + '[^>]*>');\nconst doctype = /^<!DOCTYPE\\s?[^>]+>/i;\nlet IS_REGEX_CAPTURING_BROKEN = false;\n'x'.replace(/x(.)?/g, function (m, g) {\n  IS_REGEX_CAPTURING_BROKEN = g === '';\n});\n\n// Empty Elements\nconst empty = new CaseInsensitiveSet(['area', 'base', 'basefont', 'br', 'col', 'embed', 'frame', 'hr', 'img', 'input', 'isindex', 'keygen', 'link', 'meta', 'param', 'source', 'track', 'wbr']);\n\n// Inline Elements\nconst inline = new CaseInsensitiveSet(['a', 'abbr', 'acronym', 'applet', 'b', 'basefont', 'bdo', 'big', 'br', 'button', 'cite', 'code', 'del', 'dfn', 'em', 'font', 'i', 'iframe', 'img', 'input', 'ins', 'kbd', 'label', 'map', 'noscript', 'object', 'q', 's', 'samp', 'script', 'select', 'small', 'span', 'strike', 'strong', 'sub', 'sup', 'svg', 'textarea', 'tt', 'u', 'var']);\n\n// Elements that you can, intentionally, leave open\n// (and which close themselves)\nconst closeSelf = new CaseInsensitiveSet(['colgroup', 'dd', 'dt', 'li', 'option', 'p', 'td', 'tfoot', 'th', 'thead', 'tr', 'source']);\n\n// Attributes that have their values filled in disabled='disabled'\nconst fillAttrs = new CaseInsensitiveSet(['checked', 'compact', 'declare', 'defer', 'disabled', 'ismap', 'multiple', 'nohref', 'noresize', 'noshade', 'nowrap', 'readonly', 'selected']);\n\n// Special Elements (can contain anything)\nconst special = new CaseInsensitiveSet(['script', 'style']);\n\n// HTML5 tags https://html.spec.whatwg.org/multipage/indices.html#elements-3\n// Phrasing Content https://html.spec.whatwg.org/multipage/dom.html#phrasing-content\nconst nonPhrasing = new CaseInsensitiveSet(['address', 'article', 'aside', 'base', 'blockquote', 'body', 'caption', 'col', 'colgroup', 'dd', 'details', 'dialog', 'div', 'dl', 'dt', 'fieldset', 'figcaption', 'figure', 'footer', 'form', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'head', 'header', 'hgroup', 'hr', 'html', 'legend', 'li', 'menuitem', 'meta', 'ol', 'optgroup', 'option', 'param', 'rp', 'rt', 'source', 'style', 'summary', 'tbody', 'td', 'tfoot', 'th', 'thead', 'title', 'tr', 'track', 'ul']);\nconst reCache = {};\nfunction attrForHandler(handler) {\n  let pattern = singleAttrIdentifier.source + '(?:\\\\s*(' + joinSingleAttrAssigns(handler) + ')' + '[ \\\\t\\\\n\\\\f\\\\r]*(?:' + singleAttrValues.join('|') + '))?';\n  if (handler.customAttrSurround) {\n    const attrClauses = [];\n    for (let i = handler.customAttrSurround.length - 1; i >= 0; i--) {\n      attrClauses[i] = '(?:' + '(' + handler.customAttrSurround[i][0].source + ')\\\\s*' + pattern + '\\\\s*(' + handler.customAttrSurround[i][1].source + ')' + ')';\n    }\n    attrClauses.push('(?:' + pattern + ')');\n    pattern = '(?:' + attrClauses.join('|') + ')';\n  }\n  return new RegExp('^\\\\s*' + pattern);\n}\nfunction joinSingleAttrAssigns(handler) {\n  return singleAttrAssigns.concat(handler.customAttrAssign || []).map(function (assign) {\n    return '(?:' + assign.source + ')';\n  }).join('|');\n}\nexport class HTMLParser {\n  constructor(html, handler) {\n    this.html = html;\n    this.handler = handler;\n  }\n  async parse() {\n    let html = this.html;\n    const handler = this.handler;\n    const stack = [];\n    let lastTag;\n    const attribute = attrForHandler(handler);\n    let last, prevTag, nextTag;\n    while (html) {\n      last = html;\n      // Make sure we're not in a script or style element\n      if (!lastTag || !special.has(lastTag)) {\n        let textEnd = html.indexOf('<');\n        if (textEnd === 0) {\n          // Comment:\n          if (/^<!--/.test(html)) {\n            const commentEnd = html.indexOf('-->');\n            if (commentEnd >= 0) {\n              if (handler.comment) {\n                await handler.comment(html.substring(4, commentEnd));\n              }\n              html = html.substring(commentEnd + 3);\n              prevTag = '';\n              continue;\n            }\n          }\n\n          // https://en.wikipedia.org/wiki/Conditional_comment#Downlevel-revealed_conditional_comment\n          if (/^<!\\[/.test(html)) {\n            const conditionalEnd = html.indexOf(']>');\n            if (conditionalEnd >= 0) {\n              if (handler.comment) {\n                await handler.comment(html.substring(2, conditionalEnd + 1), true /* non-standard */);\n              }\n              html = html.substring(conditionalEnd + 2);\n              prevTag = '';\n              continue;\n            }\n          }\n\n          // Doctype:\n          const doctypeMatch = html.match(doctype);\n          if (doctypeMatch) {\n            if (handler.doctype) {\n              handler.doctype(doctypeMatch[0]);\n            }\n            html = html.substring(doctypeMatch[0].length);\n            prevTag = '';\n            continue;\n          }\n\n          // End tag:\n          const endTagMatch = html.match(endTag);\n          if (endTagMatch) {\n            html = html.substring(endTagMatch[0].length);\n            await replaceAsync(endTagMatch[0], endTag, parseEndTag);\n            prevTag = '/' + endTagMatch[1].toLowerCase();\n            continue;\n          }\n\n          // Start tag:\n          const startTagMatch = parseStartTag(html);\n          if (startTagMatch) {\n            html = startTagMatch.rest;\n            await handleStartTag(startTagMatch);\n            prevTag = startTagMatch.tagName.toLowerCase();\n            continue;\n          }\n\n          // Treat `<` as text\n          if (handler.continueOnParseError) {\n            textEnd = html.indexOf('<', 1);\n          }\n        }\n        let text;\n        if (textEnd >= 0) {\n          text = html.substring(0, textEnd);\n          html = html.substring(textEnd);\n        } else {\n          text = html;\n          html = '';\n        }\n\n        // next tag\n        let nextTagMatch = parseStartTag(html);\n        if (nextTagMatch) {\n          nextTag = nextTagMatch.tagName;\n        } else {\n          nextTagMatch = html.match(endTag);\n          if (nextTagMatch) {\n            nextTag = '/' + nextTagMatch[1];\n          } else {\n            nextTag = '';\n          }\n        }\n        if (handler.chars) {\n          await handler.chars(text, prevTag, nextTag);\n        }\n        prevTag = '';\n      } else {\n        const stackedTag = lastTag.toLowerCase();\n        const reStackedTag = reCache[stackedTag] || (reCache[stackedTag] = new RegExp('([\\\\s\\\\S]*?)</' + stackedTag + '[^>]*>', 'i'));\n        html = await replaceAsync(html, reStackedTag, async (_, text) => {\n          if (stackedTag !== 'script' && stackedTag !== 'style' && stackedTag !== 'noscript') {\n            text = text.replace(/<!--([\\s\\S]*?)-->/g, '$1').replace(/<!\\[CDATA\\[([\\s\\S]*?)]]>/g, '$1');\n          }\n          if (handler.chars) {\n            await handler.chars(text);\n          }\n          return '';\n        });\n        await parseEndTag('</' + stackedTag + '>', stackedTag);\n      }\n      if (html === last) {\n        throw new Error('Parse Error: ' + html);\n      }\n    }\n    if (!handler.partialMarkup) {\n      // Clean up any remaining tags\n      await parseEndTag();\n    }\n    function parseStartTag(input) {\n      const start = input.match(startTagOpen);\n      if (start) {\n        const match = {\n          tagName: start[1],\n          attrs: []\n        };\n        input = input.slice(start[0].length);\n        let end, attr;\n        while (!(end = input.match(startTagClose)) && (attr = input.match(attribute))) {\n          input = input.slice(attr[0].length);\n          match.attrs.push(attr);\n        }\n        if (end) {\n          match.unarySlash = end[1];\n          match.rest = input.slice(end[0].length);\n          return match;\n        }\n      }\n    }\n    async function closeIfFound(tagName) {\n      if (findTag(tagName) >= 0) {\n        await parseEndTag('', tagName);\n        return true;\n      }\n    }\n    async function handleStartTag(match) {\n      const tagName = match.tagName;\n      let unarySlash = match.unarySlash;\n      if (handler.html5) {\n        if (lastTag === 'p' && nonPhrasing.has(tagName)) {\n          await parseEndTag('', lastTag);\n        } else if (tagName === 'tbody') {\n          await closeIfFound('thead');\n        } else if (tagName === 'tfoot') {\n          if (!(await closeIfFound('tbody'))) {\n            await closeIfFound('thead');\n          }\n        }\n        if (tagName === 'col' && findTag('colgroup') < 0) {\n          lastTag = 'colgroup';\n          stack.push({\n            tag: lastTag,\n            attrs: []\n          });\n          if (handler.start) {\n            await handler.start(lastTag, [], false, '');\n          }\n        }\n      }\n      if (!handler.html5 && !inline.has(tagName)) {\n        while (lastTag && inline.has(lastTag)) {\n          await parseEndTag('', lastTag);\n        }\n      }\n      if (closeSelf.has(tagName) && lastTag === tagName) {\n        await parseEndTag('', tagName);\n      }\n      const unary = empty.has(tagName) || tagName === 'html' && lastTag === 'head' || !!unarySlash;\n      const attrs = match.attrs.map(function (args) {\n        let name, value, customOpen, customClose, customAssign, quote;\n        const ncp = 7; // number of captured parts, scalar\n\n        // hackish work around FF bug https://bugzilla.mozilla.org/show_bug.cgi?id=369778\n        if (IS_REGEX_CAPTURING_BROKEN && args[0].indexOf('\"\"') === -1) {\n          if (args[3] === '') {\n            delete args[3];\n          }\n          if (args[4] === '') {\n            delete args[4];\n          }\n          if (args[5] === '') {\n            delete args[5];\n          }\n        }\n        function populate(index) {\n          customAssign = args[index];\n          value = args[index + 1];\n          if (typeof value !== 'undefined') {\n            return '\"';\n          }\n          value = args[index + 2];\n          if (typeof value !== 'undefined') {\n            return '\\'';\n          }\n          value = args[index + 3];\n          if (typeof value === 'undefined' && fillAttrs.has(name)) {\n            value = name;\n          }\n          return '';\n        }\n        let j = 1;\n        if (handler.customAttrSurround) {\n          for (let i = 0, l = handler.customAttrSurround.length; i < l; i++, j += ncp) {\n            name = args[j + 1];\n            if (name) {\n              quote = populate(j + 2);\n              customOpen = args[j];\n              customClose = args[j + 6];\n              break;\n            }\n          }\n        }\n        if (!name && (name = args[j])) {\n          quote = populate(j + 1);\n        }\n        return {\n          name,\n          value,\n          customAssign: customAssign || '=',\n          customOpen: customOpen || '',\n          customClose: customClose || '',\n          quote: quote || ''\n        };\n      });\n      if (!unary) {\n        stack.push({\n          tag: tagName,\n          attrs\n        });\n        lastTag = tagName;\n        unarySlash = '';\n      }\n      if (handler.start) {\n        await handler.start(tagName, attrs, unary, unarySlash);\n      }\n    }\n    function findTag(tagName) {\n      let pos;\n      const needle = tagName.toLowerCase();\n      for (pos = stack.length - 1; pos >= 0; pos--) {\n        if (stack[pos].tag.toLowerCase() === needle) {\n          break;\n        }\n      }\n      return pos;\n    }\n    async function parseEndTag(tag, tagName) {\n      let pos;\n\n      // Find the closest opened tag of the same type\n      if (tagName) {\n        pos = findTag(tagName);\n      } else {\n        // If no tag name is provided, clean shop\n        pos = 0;\n      }\n      if (pos >= 0) {\n        // Close all the open elements, up the stack\n        for (let i = stack.length - 1; i >= pos; i--) {\n          if (handler.end) {\n            handler.end(stack[i].tag, stack[i].attrs, i > pos || !tag);\n          }\n        }\n\n        // Remove the open elements from the stack\n        stack.length = pos;\n        lastTag = pos && stack[pos - 1].tag;\n      } else if (tagName.toLowerCase() === 'br') {\n        if (handler.start) {\n          await handler.start(tagName, [], true, '');\n        }\n      } else if (tagName.toLowerCase() === 'p') {\n        if (handler.start) {\n          await handler.start(tagName, [], false, '', true);\n        }\n        if (handler.end) {\n          handler.end(tagName, []);\n        }\n      }\n    }\n  }\n}\nexport const HTMLtoXML = html => {\n  let results = '';\n  const parser = new HTMLParser(html, {\n    start: function (tag, attrs, unary) {\n      results += '<' + tag;\n      for (let i = 0, len = attrs.length; i < len; i++) {\n        results += ' ' + attrs[i].name + '=\"' + (attrs[i].value || '').replace(/\"/g, '&#34;') + '\"';\n      }\n      results += (unary ? '/' : '') + '>';\n    },\n    end: function (tag) {\n      results += '</' + tag + '>';\n    },\n    chars: function (text) {\n      results += text;\n    },\n    comment: function (text) {\n      results += '<!--' + text + '-->';\n    },\n    ignore: function (text) {\n      results += text;\n    }\n  });\n  parser.parse();\n  return results;\n};\nexport const HTMLtoDOM = (html, doc) => {\n  // There can be only one of these elements\n  const one = {\n    html: true,\n    head: true,\n    body: true,\n    title: true\n  };\n\n  // Enforce a structure for the document\n  const structure = {\n    link: 'head',\n    base: 'head'\n  };\n  if (doc) {\n    doc = doc.ownerDocument || doc.getOwnerDocument && doc.getOwnerDocument() || doc;\n  } else if (typeof DOMDocument !== 'undefined') {\n    doc = new DOMDocument();\n  } else if (typeof document !== 'undefined' && document.implementation && document.implementation.createDocument) {\n    doc = document.implementation.createDocument('', '', null);\n  } else if (typeof ActiveX !== 'undefined') {\n    doc = new ActiveXObject('Msxml.DOMDocument');\n  }\n  const elems = [];\n  const documentElement = doc.documentElement || doc.getDocumentElement && doc.getDocumentElement();\n\n  // If we're dealing with an empty document then we\n  // need to pre-populate it with the HTML document structure\n  if (!documentElement && doc.createElement) {\n    (function () {\n      const html = doc.createElement('html');\n      const head = doc.createElement('head');\n      head.appendChild(doc.createElement('title'));\n      html.appendChild(head);\n      html.appendChild(doc.createElement('body'));\n      doc.appendChild(html);\n    })();\n  }\n\n  // Find all the unique elements\n  if (doc.getElementsByTagName) {\n    for (const i in one) {\n      one[i] = doc.getElementsByTagName(i)[0];\n    }\n  }\n\n  // If we're working with a document, inject contents into\n  // the body element\n  let curParentNode = one.body;\n  const parser = new HTMLParser(html, {\n    start: function (tagName, attrs, unary) {\n      // If it's a pre-built element, then we can ignore\n      // its construction\n      if (one[tagName]) {\n        curParentNode = one[tagName];\n        return;\n      }\n      const elem = doc.createElement(tagName);\n      for (const attr in attrs) {\n        elem.setAttribute(attrs[attr].name, attrs[attr].value);\n      }\n      if (structure[tagName] && typeof one[structure[tagName]] !== 'boolean') {\n        one[structure[tagName]].appendChild(elem);\n      } else if (curParentNode && curParentNode.appendChild) {\n        curParentNode.appendChild(elem);\n      }\n      if (!unary) {\n        elems.push(elem);\n        curParentNode = elem;\n      }\n    },\n    end: function /* tag */\n    () {\n      elems.length -= 1;\n\n      // Init the new parentNode\n      curParentNode = elems[elems.length - 1];\n    },\n    chars: function (text) {\n      curParentNode.appendChild(doc.createTextNode(text));\n    },\n    comment: function /* text */\n    () {\n      // create comment node\n    },\n    ignore: function /* text */\n    () {\n      // What to do here?\n    }\n  });\n  parser.parse();\n  return doc;\n};","map":{"version":3,"names":["replaceAsync","CaseInsensitiveSet","Set","has","str","toLowerCase","singleAttrIdentifier","singleAttrAssigns","singleAttrValues","source","qnameCapture","combiningChar","digit","extender","letter","ncname","startTagOpen","RegExp","startTagClose","endTag","doctype","IS_REGEX_CAPTURING_BROKEN","replace","m","g","empty","inline","closeSelf","fillAttrs","special","nonPhrasing","reCache","attrForHandler","handler","pattern","joinSingleAttrAssigns","join","customAttrSurround","attrClauses","i","length","push","concat","customAttrAssign","map","assign","HTMLParser","constructor","html","parse","stack","lastTag","attribute","last","prevTag","nextTag","textEnd","indexOf","test","commentEnd","comment","substring","conditionalEnd","doctypeMatch","match","endTagMatch","parseEndTag","startTagMatch","parseStartTag","rest","handleStartTag","tagName","continueOnParseError","text","nextTagMatch","chars","stackedTag","reStackedTag","_","Error","partialMarkup","input","start","attrs","slice","end","attr","unarySlash","closeIfFound","findTag","html5","tag","unary","args","name","value","customOpen","customClose","customAssign","quote","ncp","populate","index","j","l","pos","needle","HTMLtoXML","results","parser","len","ignore","HTMLtoDOM","doc","one","head","body","title","structure","link","base","ownerDocument","getOwnerDocument","DOMDocument","document","implementation","createDocument","ActiveX","ActiveXObject","elems","documentElement","getDocumentElement","createElement","appendChild","getElementsByTagName","curParentNode","elem","setAttribute","createTextNode"],"sources":["F:/landinghub-iconic/node_modules/.pnpm/html-minifier-terser@7.2.0/node_modules/html-minifier-terser/src/htmlparser.js"],"sourcesContent":["/*!\n * HTML Parser By John Resig (ejohn.org)\n * Modified by Juriy \"kangax\" Zaytsev\n * Original code by Erik Arvidsson, Mozilla Public License\n * http://erik.eae.net/simplehtmlparser/simplehtmlparser.js\n */\n\n/*\n * // Use like so:\n * HTMLParser(htmlString, {\n *     start: function(tag, attrs, unary) {},\n *     end: function(tag) {},\n *     chars: function(text) {},\n *     comment: function(text) {}\n * });\n *\n * // or to get an XML string:\n * HTMLtoXML(htmlString);\n *\n * // or to get an XML DOM Document\n * HTMLtoDOM(htmlString);\n *\n * // or to inject into an existing document/DOM node\n * HTMLtoDOM(htmlString, document);\n * HTMLtoDOM(htmlString, document.body);\n *\n */\n\n/* global ActiveXObject, DOMDocument */\n\nimport { replaceAsync } from './utils.js';\n\nclass CaseInsensitiveSet extends Set {\n  has(str) {\n    return super.has(str.toLowerCase());\n  }\n}\n\n// Regular Expressions for parsing tags and attributes\nconst singleAttrIdentifier = /([^\\s\"'<>/=]+)/;\nconst singleAttrAssigns = [/=/];\nconst singleAttrValues = [\n  // attr value double quotes\n  /\"([^\"]*)\"+/.source,\n  // attr value, single quotes\n  /'([^']*)'+/.source,\n  // attr value, no quotes\n  /([^ \\t\\n\\f\\r\"'`=<>]+)/.source\n];\n// https://www.w3.org/TR/1999/REC-xml-names-19990114/#NT-QName\nconst qnameCapture = (function () {\n  // based on https://www.npmjs.com/package/ncname\n  const combiningChar = '\\\\u0300-\\\\u0345\\\\u0360\\\\u0361\\\\u0483-\\\\u0486\\\\u0591-\\\\u05A1\\\\u05A3-\\\\u05B9\\\\u05BB-\\\\u05BD\\\\u05BF\\\\u05C1\\\\u05C2\\\\u05C4\\\\u064B-\\\\u0652\\\\u0670\\\\u06D6-\\\\u06E4\\\\u06E7\\\\u06E8\\\\u06EA-\\\\u06ED\\\\u0901-\\\\u0903\\\\u093C\\\\u093E-\\\\u094D\\\\u0951-\\\\u0954\\\\u0962\\\\u0963\\\\u0981-\\\\u0983\\\\u09BC\\\\u09BE-\\\\u09C4\\\\u09C7\\\\u09C8\\\\u09CB-\\\\u09CD\\\\u09D7\\\\u09E2\\\\u09E3\\\\u0A02\\\\u0A3C\\\\u0A3E-\\\\u0A42\\\\u0A47\\\\u0A48\\\\u0A4B-\\\\u0A4D\\\\u0A70\\\\u0A71\\\\u0A81-\\\\u0A83\\\\u0ABC\\\\u0ABE-\\\\u0AC5\\\\u0AC7-\\\\u0AC9\\\\u0ACB-\\\\u0ACD\\\\u0B01-\\\\u0B03\\\\u0B3C\\\\u0B3E-\\\\u0B43\\\\u0B47\\\\u0B48\\\\u0B4B-\\\\u0B4D\\\\u0B56\\\\u0B57\\\\u0B82\\\\u0B83\\\\u0BBE-\\\\u0BC2\\\\u0BC6-\\\\u0BC8\\\\u0BCA-\\\\u0BCD\\\\u0BD7\\\\u0C01-\\\\u0C03\\\\u0C3E-\\\\u0C44\\\\u0C46-\\\\u0C48\\\\u0C4A-\\\\u0C4D\\\\u0C55\\\\u0C56\\\\u0C82\\\\u0C83\\\\u0CBE-\\\\u0CC4\\\\u0CC6-\\\\u0CC8\\\\u0CCA-\\\\u0CCD\\\\u0CD5\\\\u0CD6\\\\u0D02\\\\u0D03\\\\u0D3E-\\\\u0D43\\\\u0D46-\\\\u0D48\\\\u0D4A-\\\\u0D4D\\\\u0D57\\\\u0E31\\\\u0E34-\\\\u0E3A\\\\u0E47-\\\\u0E4E\\\\u0EB1\\\\u0EB4-\\\\u0EB9\\\\u0EBB\\\\u0EBC\\\\u0EC8-\\\\u0ECD\\\\u0F18\\\\u0F19\\\\u0F35\\\\u0F37\\\\u0F39\\\\u0F3E\\\\u0F3F\\\\u0F71-\\\\u0F84\\\\u0F86-\\\\u0F8B\\\\u0F90-\\\\u0F95\\\\u0F97\\\\u0F99-\\\\u0FAD\\\\u0FB1-\\\\u0FB7\\\\u0FB9\\\\u20D0-\\\\u20DC\\\\u20E1\\\\u302A-\\\\u302F\\\\u3099\\\\u309A';\n  const digit = '0-9\\\\u0660-\\\\u0669\\\\u06F0-\\\\u06F9\\\\u0966-\\\\u096F\\\\u09E6-\\\\u09EF\\\\u0A66-\\\\u0A6F\\\\u0AE6-\\\\u0AEF\\\\u0B66-\\\\u0B6F\\\\u0BE7-\\\\u0BEF\\\\u0C66-\\\\u0C6F\\\\u0CE6-\\\\u0CEF\\\\u0D66-\\\\u0D6F\\\\u0E50-\\\\u0E59\\\\u0ED0-\\\\u0ED9\\\\u0F20-\\\\u0F29';\n  const extender = '\\\\xB7\\\\u02D0\\\\u02D1\\\\u0387\\\\u0640\\\\u0E46\\\\u0EC6\\\\u3005\\\\u3031-\\\\u3035\\\\u309D\\\\u309E\\\\u30FC-\\\\u30FE';\n  const letter = 'A-Za-z\\\\xC0-\\\\xD6\\\\xD8-\\\\xF6\\\\xF8-\\\\u0131\\\\u0134-\\\\u013E\\\\u0141-\\\\u0148\\\\u014A-\\\\u017E\\\\u0180-\\\\u01C3\\\\u01CD-\\\\u01F0\\\\u01F4\\\\u01F5\\\\u01FA-\\\\u0217\\\\u0250-\\\\u02A8\\\\u02BB-\\\\u02C1\\\\u0386\\\\u0388-\\\\u038A\\\\u038C\\\\u038E-\\\\u03A1\\\\u03A3-\\\\u03CE\\\\u03D0-\\\\u03D6\\\\u03DA\\\\u03DC\\\\u03DE\\\\u03E0\\\\u03E2-\\\\u03F3\\\\u0401-\\\\u040C\\\\u040E-\\\\u044F\\\\u0451-\\\\u045C\\\\u045E-\\\\u0481\\\\u0490-\\\\u04C4\\\\u04C7\\\\u04C8\\\\u04CB\\\\u04CC\\\\u04D0-\\\\u04EB\\\\u04EE-\\\\u04F5\\\\u04F8\\\\u04F9\\\\u0531-\\\\u0556\\\\u0559\\\\u0561-\\\\u0586\\\\u05D0-\\\\u05EA\\\\u05F0-\\\\u05F2\\\\u0621-\\\\u063A\\\\u0641-\\\\u064A\\\\u0671-\\\\u06B7\\\\u06BA-\\\\u06BE\\\\u06C0-\\\\u06CE\\\\u06D0-\\\\u06D3\\\\u06D5\\\\u06E5\\\\u06E6\\\\u0905-\\\\u0939\\\\u093D\\\\u0958-\\\\u0961\\\\u0985-\\\\u098C\\\\u098F\\\\u0990\\\\u0993-\\\\u09A8\\\\u09AA-\\\\u09B0\\\\u09B2\\\\u09B6-\\\\u09B9\\\\u09DC\\\\u09DD\\\\u09DF-\\\\u09E1\\\\u09F0\\\\u09F1\\\\u0A05-\\\\u0A0A\\\\u0A0F\\\\u0A10\\\\u0A13-\\\\u0A28\\\\u0A2A-\\\\u0A30\\\\u0A32\\\\u0A33\\\\u0A35\\\\u0A36\\\\u0A38\\\\u0A39\\\\u0A59-\\\\u0A5C\\\\u0A5E\\\\u0A72-\\\\u0A74\\\\u0A85-\\\\u0A8B\\\\u0A8D\\\\u0A8F-\\\\u0A91\\\\u0A93-\\\\u0AA8\\\\u0AAA-\\\\u0AB0\\\\u0AB2\\\\u0AB3\\\\u0AB5-\\\\u0AB9\\\\u0ABD\\\\u0AE0\\\\u0B05-\\\\u0B0C\\\\u0B0F\\\\u0B10\\\\u0B13-\\\\u0B28\\\\u0B2A-\\\\u0B30\\\\u0B32\\\\u0B33\\\\u0B36-\\\\u0B39\\\\u0B3D\\\\u0B5C\\\\u0B5D\\\\u0B5F-\\\\u0B61\\\\u0B85-\\\\u0B8A\\\\u0B8E-\\\\u0B90\\\\u0B92-\\\\u0B95\\\\u0B99\\\\u0B9A\\\\u0B9C\\\\u0B9E\\\\u0B9F\\\\u0BA3\\\\u0BA4\\\\u0BA8-\\\\u0BAA\\\\u0BAE-\\\\u0BB5\\\\u0BB7-\\\\u0BB9\\\\u0C05-\\\\u0C0C\\\\u0C0E-\\\\u0C10\\\\u0C12-\\\\u0C28\\\\u0C2A-\\\\u0C33\\\\u0C35-\\\\u0C39\\\\u0C60\\\\u0C61\\\\u0C85-\\\\u0C8C\\\\u0C8E-\\\\u0C90\\\\u0C92-\\\\u0CA8\\\\u0CAA-\\\\u0CB3\\\\u0CB5-\\\\u0CB9\\\\u0CDE\\\\u0CE0\\\\u0CE1\\\\u0D05-\\\\u0D0C\\\\u0D0E-\\\\u0D10\\\\u0D12-\\\\u0D28\\\\u0D2A-\\\\u0D39\\\\u0D60\\\\u0D61\\\\u0E01-\\\\u0E2E\\\\u0E30\\\\u0E32\\\\u0E33\\\\u0E40-\\\\u0E45\\\\u0E81\\\\u0E82\\\\u0E84\\\\u0E87\\\\u0E88\\\\u0E8A\\\\u0E8D\\\\u0E94-\\\\u0E97\\\\u0E99-\\\\u0E9F\\\\u0EA1-\\\\u0EA3\\\\u0EA5\\\\u0EA7\\\\u0EAA\\\\u0EAB\\\\u0EAD\\\\u0EAE\\\\u0EB0\\\\u0EB2\\\\u0EB3\\\\u0EBD\\\\u0EC0-\\\\u0EC4\\\\u0F40-\\\\u0F47\\\\u0F49-\\\\u0F69\\\\u10A0-\\\\u10C5\\\\u10D0-\\\\u10F6\\\\u1100\\\\u1102\\\\u1103\\\\u1105-\\\\u1107\\\\u1109\\\\u110B\\\\u110C\\\\u110E-\\\\u1112\\\\u113C\\\\u113E\\\\u1140\\\\u114C\\\\u114E\\\\u1150\\\\u1154\\\\u1155\\\\u1159\\\\u115F-\\\\u1161\\\\u1163\\\\u1165\\\\u1167\\\\u1169\\\\u116D\\\\u116E\\\\u1172\\\\u1173\\\\u1175\\\\u119E\\\\u11A8\\\\u11AB\\\\u11AE\\\\u11AF\\\\u11B7\\\\u11B8\\\\u11BA\\\\u11BC-\\\\u11C2\\\\u11EB\\\\u11F0\\\\u11F9\\\\u1E00-\\\\u1E9B\\\\u1EA0-\\\\u1EF9\\\\u1F00-\\\\u1F15\\\\u1F18-\\\\u1F1D\\\\u1F20-\\\\u1F45\\\\u1F48-\\\\u1F4D\\\\u1F50-\\\\u1F57\\\\u1F59\\\\u1F5B\\\\u1F5D\\\\u1F5F-\\\\u1F7D\\\\u1F80-\\\\u1FB4\\\\u1FB6-\\\\u1FBC\\\\u1FBE\\\\u1FC2-\\\\u1FC4\\\\u1FC6-\\\\u1FCC\\\\u1FD0-\\\\u1FD3\\\\u1FD6-\\\\u1FDB\\\\u1FE0-\\\\u1FEC\\\\u1FF2-\\\\u1FF4\\\\u1FF6-\\\\u1FFC\\\\u2126\\\\u212A\\\\u212B\\\\u212E\\\\u2180-\\\\u2182\\\\u3007\\\\u3021-\\\\u3029\\\\u3041-\\\\u3094\\\\u30A1-\\\\u30FA\\\\u3105-\\\\u312C\\\\u4E00-\\\\u9FA5\\\\uAC00-\\\\uD7A3';\n  const ncname = '[' + letter + '_][' + letter + digit + '\\\\.\\\\-_' + combiningChar + extender + ']*';\n  return '((?:' + ncname + '\\\\:)?' + ncname + ')';\n})();\nconst startTagOpen = new RegExp('^<' + qnameCapture);\nconst startTagClose = /^\\s*(\\/?)>/;\nexport const endTag = new RegExp('^<\\\\/' + qnameCapture + '[^>]*>');\nconst doctype = /^<!DOCTYPE\\s?[^>]+>/i;\n\nlet IS_REGEX_CAPTURING_BROKEN = false;\n'x'.replace(/x(.)?/g, function (m, g) {\n  IS_REGEX_CAPTURING_BROKEN = g === '';\n});\n\n// Empty Elements\nconst empty = new CaseInsensitiveSet(['area', 'base', 'basefont', 'br', 'col', 'embed', 'frame', 'hr', 'img', 'input', 'isindex', 'keygen', 'link', 'meta', 'param', 'source', 'track', 'wbr']);\n\n// Inline Elements\nconst inline = new CaseInsensitiveSet(['a', 'abbr', 'acronym', 'applet', 'b', 'basefont', 'bdo', 'big', 'br', 'button', 'cite', 'code', 'del', 'dfn', 'em', 'font', 'i', 'iframe', 'img', 'input', 'ins', 'kbd', 'label', 'map', 'noscript', 'object', 'q', 's', 'samp', 'script', 'select', 'small', 'span', 'strike', 'strong', 'sub', 'sup', 'svg', 'textarea', 'tt', 'u', 'var']);\n\n// Elements that you can, intentionally, leave open\n// (and which close themselves)\nconst closeSelf = new CaseInsensitiveSet(['colgroup', 'dd', 'dt', 'li', 'option', 'p', 'td', 'tfoot', 'th', 'thead', 'tr', 'source']);\n\n// Attributes that have their values filled in disabled='disabled'\nconst fillAttrs = new CaseInsensitiveSet(['checked', 'compact', 'declare', 'defer', 'disabled', 'ismap', 'multiple', 'nohref', 'noresize', 'noshade', 'nowrap', 'readonly', 'selected']);\n\n// Special Elements (can contain anything)\nconst special = new CaseInsensitiveSet(['script', 'style']);\n\n// HTML5 tags https://html.spec.whatwg.org/multipage/indices.html#elements-3\n// Phrasing Content https://html.spec.whatwg.org/multipage/dom.html#phrasing-content\nconst nonPhrasing = new CaseInsensitiveSet(['address', 'article', 'aside', 'base', 'blockquote', 'body', 'caption', 'col', 'colgroup', 'dd', 'details', 'dialog', 'div', 'dl', 'dt', 'fieldset', 'figcaption', 'figure', 'footer', 'form', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'head', 'header', 'hgroup', 'hr', 'html', 'legend', 'li', 'menuitem', 'meta', 'ol', 'optgroup', 'option', 'param', 'rp', 'rt', 'source', 'style', 'summary', 'tbody', 'td', 'tfoot', 'th', 'thead', 'title', 'tr', 'track', 'ul']);\n\nconst reCache = {};\n\nfunction attrForHandler(handler) {\n  let pattern = singleAttrIdentifier.source +\n    '(?:\\\\s*(' + joinSingleAttrAssigns(handler) + ')' +\n    '[ \\\\t\\\\n\\\\f\\\\r]*(?:' + singleAttrValues.join('|') + '))?';\n  if (handler.customAttrSurround) {\n    const attrClauses = [];\n    for (let i = handler.customAttrSurround.length - 1; i >= 0; i--) {\n      attrClauses[i] = '(?:' +\n        '(' + handler.customAttrSurround[i][0].source + ')\\\\s*' +\n        pattern +\n        '\\\\s*(' + handler.customAttrSurround[i][1].source + ')' +\n        ')';\n    }\n    attrClauses.push('(?:' + pattern + ')');\n    pattern = '(?:' + attrClauses.join('|') + ')';\n  }\n  return new RegExp('^\\\\s*' + pattern);\n}\n\nfunction joinSingleAttrAssigns(handler) {\n  return singleAttrAssigns.concat(\n    handler.customAttrAssign || []\n  ).map(function (assign) {\n    return '(?:' + assign.source + ')';\n  }).join('|');\n}\n\nexport class HTMLParser {\n  constructor(html, handler) {\n    this.html = html;\n    this.handler = handler;\n  }\n\n  async parse() {\n    let html = this.html;\n    const handler = this.handler;\n\n    const stack = []; let lastTag;\n    const attribute = attrForHandler(handler);\n    let last, prevTag, nextTag;\n    while (html) {\n      last = html;\n      // Make sure we're not in a script or style element\n      if (!lastTag || !special.has(lastTag)) {\n        let textEnd = html.indexOf('<');\n        if (textEnd === 0) {\n          // Comment:\n          if (/^<!--/.test(html)) {\n            const commentEnd = html.indexOf('-->');\n\n            if (commentEnd >= 0) {\n              if (handler.comment) {\n                await handler.comment(html.substring(4, commentEnd));\n              }\n              html = html.substring(commentEnd + 3);\n              prevTag = '';\n              continue;\n            }\n          }\n\n          // https://en.wikipedia.org/wiki/Conditional_comment#Downlevel-revealed_conditional_comment\n          if (/^<!\\[/.test(html)) {\n            const conditionalEnd = html.indexOf(']>');\n\n            if (conditionalEnd >= 0) {\n              if (handler.comment) {\n                await handler.comment(html.substring(2, conditionalEnd + 1), true /* non-standard */);\n              }\n              html = html.substring(conditionalEnd + 2);\n              prevTag = '';\n              continue;\n            }\n          }\n\n          // Doctype:\n          const doctypeMatch = html.match(doctype);\n          if (doctypeMatch) {\n            if (handler.doctype) {\n              handler.doctype(doctypeMatch[0]);\n            }\n            html = html.substring(doctypeMatch[0].length);\n            prevTag = '';\n            continue;\n          }\n\n          // End tag:\n          const endTagMatch = html.match(endTag);\n          if (endTagMatch) {\n            html = html.substring(endTagMatch[0].length);\n            await replaceAsync(endTagMatch[0], endTag, parseEndTag);\n            prevTag = '/' + endTagMatch[1].toLowerCase();\n            continue;\n          }\n\n          // Start tag:\n          const startTagMatch = parseStartTag(html);\n          if (startTagMatch) {\n            html = startTagMatch.rest;\n            await handleStartTag(startTagMatch);\n            prevTag = startTagMatch.tagName.toLowerCase();\n            continue;\n          }\n\n          // Treat `<` as text\n          if (handler.continueOnParseError) {\n            textEnd = html.indexOf('<', 1);\n          }\n        }\n\n        let text;\n        if (textEnd >= 0) {\n          text = html.substring(0, textEnd);\n          html = html.substring(textEnd);\n        } else {\n          text = html;\n          html = '';\n        }\n\n        // next tag\n        let nextTagMatch = parseStartTag(html);\n        if (nextTagMatch) {\n          nextTag = nextTagMatch.tagName;\n        } else {\n          nextTagMatch = html.match(endTag);\n          if (nextTagMatch) {\n            nextTag = '/' + nextTagMatch[1];\n          } else {\n            nextTag = '';\n          }\n        }\n\n        if (handler.chars) {\n          await handler.chars(text, prevTag, nextTag);\n        }\n        prevTag = '';\n      } else {\n        const stackedTag = lastTag.toLowerCase();\n        const reStackedTag = reCache[stackedTag] || (reCache[stackedTag] = new RegExp('([\\\\s\\\\S]*?)</' + stackedTag + '[^>]*>', 'i'));\n\n        html = await replaceAsync(html, reStackedTag, async (_, text) => {\n          if (stackedTag !== 'script' && stackedTag !== 'style' && stackedTag !== 'noscript') {\n            text = text\n              .replace(/<!--([\\s\\S]*?)-->/g, '$1')\n              .replace(/<!\\[CDATA\\[([\\s\\S]*?)]]>/g, '$1');\n          }\n\n          if (handler.chars) {\n            await handler.chars(text);\n          }\n\n          return '';\n        });\n\n        await parseEndTag('</' + stackedTag + '>', stackedTag);\n      }\n\n      if (html === last) {\n        throw new Error('Parse Error: ' + html);\n      }\n    }\n\n    if (!handler.partialMarkup) {\n      // Clean up any remaining tags\n      await parseEndTag();\n    }\n\n    function parseStartTag(input) {\n      const start = input.match(startTagOpen);\n      if (start) {\n        const match = {\n          tagName: start[1],\n          attrs: []\n        };\n        input = input.slice(start[0].length);\n        let end, attr;\n        while (!(end = input.match(startTagClose)) && (attr = input.match(attribute))) {\n          input = input.slice(attr[0].length);\n          match.attrs.push(attr);\n        }\n        if (end) {\n          match.unarySlash = end[1];\n          match.rest = input.slice(end[0].length);\n          return match;\n        }\n      }\n    }\n\n    async function closeIfFound(tagName) {\n      if (findTag(tagName) >= 0) {\n        await parseEndTag('', tagName);\n        return true;\n      }\n    }\n\n    async function handleStartTag(match) {\n      const tagName = match.tagName;\n      let unarySlash = match.unarySlash;\n\n      if (handler.html5) {\n        if (lastTag === 'p' && nonPhrasing.has(tagName)) {\n          await parseEndTag('', lastTag);\n        } else if (tagName === 'tbody') {\n          await closeIfFound('thead');\n        } else if (tagName === 'tfoot') {\n          if (!await closeIfFound('tbody')) {\n            await closeIfFound('thead');\n          }\n        }\n        if (tagName === 'col' && findTag('colgroup') < 0) {\n          lastTag = 'colgroup';\n          stack.push({ tag: lastTag, attrs: [] });\n          if (handler.start) {\n            await handler.start(lastTag, [], false, '');\n          }\n        }\n      }\n\n      if (!handler.html5 && !inline.has(tagName)) {\n        while (lastTag && inline.has(lastTag)) {\n          await parseEndTag('', lastTag);\n        }\n      }\n\n      if (closeSelf.has(tagName) && lastTag === tagName) {\n        await parseEndTag('', tagName);\n      }\n\n      const unary = empty.has(tagName) || (tagName === 'html' && lastTag === 'head') || !!unarySlash;\n\n      const attrs = match.attrs.map(function (args) {\n        let name, value, customOpen, customClose, customAssign, quote;\n        const ncp = 7; // number of captured parts, scalar\n\n        // hackish work around FF bug https://bugzilla.mozilla.org/show_bug.cgi?id=369778\n        if (IS_REGEX_CAPTURING_BROKEN && args[0].indexOf('\"\"') === -1) {\n          if (args[3] === '') { delete args[3]; }\n          if (args[4] === '') { delete args[4]; }\n          if (args[5] === '') { delete args[5]; }\n        }\n\n        function populate(index) {\n          customAssign = args[index];\n          value = args[index + 1];\n          if (typeof value !== 'undefined') {\n            return '\"';\n          }\n          value = args[index + 2];\n          if (typeof value !== 'undefined') {\n            return '\\'';\n          }\n          value = args[index + 3];\n          if (typeof value === 'undefined' && fillAttrs.has(name)) {\n            value = name;\n          }\n          return '';\n        }\n\n        let j = 1;\n        if (handler.customAttrSurround) {\n          for (let i = 0, l = handler.customAttrSurround.length; i < l; i++, j += ncp) {\n            name = args[j + 1];\n            if (name) {\n              quote = populate(j + 2);\n              customOpen = args[j];\n              customClose = args[j + 6];\n              break;\n            }\n          }\n        }\n\n        if (!name && (name = args[j])) {\n          quote = populate(j + 1);\n        }\n\n        return {\n          name,\n          value,\n          customAssign: customAssign || '=',\n          customOpen: customOpen || '',\n          customClose: customClose || '',\n          quote: quote || ''\n        };\n      });\n\n      if (!unary) {\n        stack.push({ tag: tagName, attrs });\n        lastTag = tagName;\n        unarySlash = '';\n      }\n\n      if (handler.start) {\n        await handler.start(tagName, attrs, unary, unarySlash);\n      }\n    }\n\n    function findTag(tagName) {\n      let pos;\n      const needle = tagName.toLowerCase();\n      for (pos = stack.length - 1; pos >= 0; pos--) {\n        if (stack[pos].tag.toLowerCase() === needle) {\n          break;\n        }\n      }\n      return pos;\n    }\n\n    async function parseEndTag(tag, tagName) {\n      let pos;\n\n      // Find the closest opened tag of the same type\n      if (tagName) {\n        pos = findTag(tagName);\n      } else { // If no tag name is provided, clean shop\n        pos = 0;\n      }\n\n      if (pos >= 0) {\n        // Close all the open elements, up the stack\n        for (let i = stack.length - 1; i >= pos; i--) {\n          if (handler.end) {\n            handler.end(stack[i].tag, stack[i].attrs, i > pos || !tag);\n          }\n        }\n\n        // Remove the open elements from the stack\n        stack.length = pos;\n        lastTag = pos && stack[pos - 1].tag;\n      } else if (tagName.toLowerCase() === 'br') {\n        if (handler.start) {\n          await handler.start(tagName, [], true, '');\n        }\n      } else if (tagName.toLowerCase() === 'p') {\n        if (handler.start) {\n          await handler.start(tagName, [], false, '', true);\n        }\n        if (handler.end) {\n          handler.end(tagName, []);\n        }\n      }\n    }\n  }\n}\n\nexport const HTMLtoXML = (html) => {\n  let results = '';\n\n  const parser = new HTMLParser(html, {\n    start: function (tag, attrs, unary) {\n      results += '<' + tag;\n\n      for (let i = 0, len = attrs.length; i < len; i++) {\n        results += ' ' + attrs[i].name + '=\"' + (attrs[i].value || '').replace(/\"/g, '&#34;') + '\"';\n      }\n\n      results += (unary ? '/' : '') + '>';\n    },\n    end: function (tag) {\n      results += '</' + tag + '>';\n    },\n    chars: function (text) {\n      results += text;\n    },\n    comment: function (text) {\n      results += '<!--' + text + '-->';\n    },\n    ignore: function (text) {\n      results += text;\n    }\n  });\n\n  parser.parse();\n\n  return results;\n};\n\nexport const HTMLtoDOM = (html, doc) => {\n  // There can be only one of these elements\n  const one = {\n    html: true,\n    head: true,\n    body: true,\n    title: true\n  };\n\n  // Enforce a structure for the document\n  const structure = {\n    link: 'head',\n    base: 'head'\n  };\n\n  if (doc) {\n    doc = doc.ownerDocument || (doc.getOwnerDocument && doc.getOwnerDocument()) || doc;\n  } else if (typeof DOMDocument !== 'undefined') {\n    doc = new DOMDocument();\n  } else if (typeof document !== 'undefined' && document.implementation && document.implementation.createDocument) {\n    doc = document.implementation.createDocument('', '', null);\n  } else if (typeof ActiveX !== 'undefined') {\n    doc = new ActiveXObject('Msxml.DOMDocument');\n  }\n\n  const elems = [];\n  const documentElement = doc.documentElement || (doc.getDocumentElement && doc.getDocumentElement());\n\n  // If we're dealing with an empty document then we\n  // need to pre-populate it with the HTML document structure\n  if (!documentElement && doc.createElement) {\n    (function () {\n      const html = doc.createElement('html');\n      const head = doc.createElement('head');\n      head.appendChild(doc.createElement('title'));\n      html.appendChild(head);\n      html.appendChild(doc.createElement('body'));\n      doc.appendChild(html);\n    })();\n  }\n\n  // Find all the unique elements\n  if (doc.getElementsByTagName) {\n    for (const i in one) {\n      one[i] = doc.getElementsByTagName(i)[0];\n    }\n  }\n\n  // If we're working with a document, inject contents into\n  // the body element\n  let curParentNode = one.body;\n\n  const parser = new HTMLParser(html, {\n    start: function (tagName, attrs, unary) {\n      // If it's a pre-built element, then we can ignore\n      // its construction\n      if (one[tagName]) {\n        curParentNode = one[tagName];\n        return;\n      }\n\n      const elem = doc.createElement(tagName);\n\n      for (const attr in attrs) {\n        elem.setAttribute(attrs[attr].name, attrs[attr].value);\n      }\n\n      if (structure[tagName] && typeof one[structure[tagName]] !== 'boolean') {\n        one[structure[tagName]].appendChild(elem);\n      } else if (curParentNode && curParentNode.appendChild) {\n        curParentNode.appendChild(elem);\n      }\n\n      if (!unary) {\n        elems.push(elem);\n        curParentNode = elem;\n      }\n    },\n    end: function (/* tag */) {\n      elems.length -= 1;\n\n      // Init the new parentNode\n      curParentNode = elems[elems.length - 1];\n    },\n    chars: function (text) {\n      curParentNode.appendChild(doc.createTextNode(text));\n    },\n    comment: function (/* text */) {\n      // create comment node\n    },\n    ignore: function (/* text */) {\n      // What to do here?\n    }\n  });\n\n  parser.parse();\n\n  return doc;\n};\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,SAASA,YAAY,QAAQ,YAAY;AAEzC,MAAMC,kBAAkB,SAASC,GAAG,CAAC;EACnCC,GAAGA,CAACC,GAAG,EAAE;IACP,OAAO,KAAK,CAACD,GAAG,CAACC,GAAG,CAACC,WAAW,CAAC,CAAC,CAAC;EACrC;AACF;;AAEA;AACA,MAAMC,oBAAoB,GAAG,gBAAgB;AAC7C,MAAMC,iBAAiB,GAAG,CAAC,GAAG,CAAC;AAC/B,MAAMC,gBAAgB,GAAG;AACvB;AACA,YAAY,CAACC,MAAM;AACnB;AACA,YAAY,CAACA,MAAM;AACnB;AACA,uBAAuB,CAACA,MAAM,CAC/B;AACD;AACA,MAAMC,YAAY,GAAI,YAAY;EAChC;EACA,MAAMC,aAAa,GAAG,ylCAAylC;EAC/mC,MAAMC,KAAK,GAAG,uNAAuN;EACrO,MAAMC,QAAQ,GAAG,oGAAoG;EACrH,MAAMC,MAAM,GAAG,wgFAAwgF;EACvhF,MAAMC,MAAM,GAAG,GAAG,GAAGD,MAAM,GAAG,KAAK,GAAGA,MAAM,GAAGF,KAAK,GAAG,SAAS,GAAGD,aAAa,GAAGE,QAAQ,GAAG,IAAI;EAClG,OAAO,MAAM,GAAGE,MAAM,GAAG,OAAO,GAAGA,MAAM,GAAG,GAAG;AACjD,CAAC,CAAE,CAAC;AACJ,MAAMC,YAAY,GAAG,IAAIC,MAAM,CAAC,IAAI,GAAGP,YAAY,CAAC;AACpD,MAAMQ,aAAa,GAAG,YAAY;AAClC,OAAO,MAAMC,MAAM,GAAG,IAAIF,MAAM,CAAC,OAAO,GAAGP,YAAY,GAAG,QAAQ,CAAC;AACnE,MAAMU,OAAO,GAAG,sBAAsB;AAEtC,IAAIC,yBAAyB,GAAG,KAAK;AACrC,GAAG,CAACC,OAAO,CAAC,QAAQ,EAAE,UAAUC,CAAC,EAAEC,CAAC,EAAE;EACpCH,yBAAyB,GAAGG,CAAC,KAAK,EAAE;AACtC,CAAC,CAAC;;AAEF;AACA,MAAMC,KAAK,GAAG,IAAIxB,kBAAkB,CAAC,CAAC,MAAM,EAAE,MAAM,EAAE,UAAU,EAAE,IAAI,EAAE,KAAK,EAAE,OAAO,EAAE,OAAO,EAAE,IAAI,EAAE,KAAK,EAAE,OAAO,EAAE,SAAS,EAAE,QAAQ,EAAE,MAAM,EAAE,MAAM,EAAE,OAAO,EAAE,QAAQ,EAAE,OAAO,EAAE,KAAK,CAAC,CAAC;;AAE/L;AACA,MAAMyB,MAAM,GAAG,IAAIzB,kBAAkB,CAAC,CAAC,GAAG,EAAE,MAAM,EAAE,SAAS,EAAE,QAAQ,EAAE,GAAG,EAAE,UAAU,EAAE,KAAK,EAAE,KAAK,EAAE,IAAI,EAAE,QAAQ,EAAE,MAAM,EAAE,MAAM,EAAE,KAAK,EAAE,KAAK,EAAE,IAAI,EAAE,MAAM,EAAE,GAAG,EAAE,QAAQ,EAAE,KAAK,EAAE,OAAO,EAAE,KAAK,EAAE,KAAK,EAAE,OAAO,EAAE,KAAK,EAAE,UAAU,EAAE,QAAQ,EAAE,GAAG,EAAE,GAAG,EAAE,MAAM,EAAE,QAAQ,EAAE,QAAQ,EAAE,OAAO,EAAE,MAAM,EAAE,QAAQ,EAAE,QAAQ,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,UAAU,EAAE,IAAI,EAAE,GAAG,EAAE,KAAK,CAAC,CAAC;;AAErX;AACA;AACA,MAAM0B,SAAS,GAAG,IAAI1B,kBAAkB,CAAC,CAAC,UAAU,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,QAAQ,EAAE,GAAG,EAAE,IAAI,EAAE,OAAO,EAAE,IAAI,EAAE,OAAO,EAAE,IAAI,EAAE,QAAQ,CAAC,CAAC;;AAErI;AACA,MAAM2B,SAAS,GAAG,IAAI3B,kBAAkB,CAAC,CAAC,SAAS,EAAE,SAAS,EAAE,SAAS,EAAE,OAAO,EAAE,UAAU,EAAE,OAAO,EAAE,UAAU,EAAE,QAAQ,EAAE,UAAU,EAAE,SAAS,EAAE,QAAQ,EAAE,UAAU,EAAE,UAAU,CAAC,CAAC;;AAExL;AACA,MAAM4B,OAAO,GAAG,IAAI5B,kBAAkB,CAAC,CAAC,QAAQ,EAAE,OAAO,CAAC,CAAC;;AAE3D;AACA;AACA,MAAM6B,WAAW,GAAG,IAAI7B,kBAAkB,CAAC,CAAC,SAAS,EAAE,SAAS,EAAE,OAAO,EAAE,MAAM,EAAE,YAAY,EAAE,MAAM,EAAE,SAAS,EAAE,KAAK,EAAE,UAAU,EAAE,IAAI,EAAE,SAAS,EAAE,QAAQ,EAAE,KAAK,EAAE,IAAI,EAAE,IAAI,EAAE,UAAU,EAAE,YAAY,EAAE,QAAQ,EAAE,QAAQ,EAAE,MAAM,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,MAAM,EAAE,QAAQ,EAAE,QAAQ,EAAE,IAAI,EAAE,MAAM,EAAE,QAAQ,EAAE,IAAI,EAAE,UAAU,EAAE,MAAM,EAAE,IAAI,EAAE,UAAU,EAAE,QAAQ,EAAE,OAAO,EAAE,IAAI,EAAE,IAAI,EAAE,QAAQ,EAAE,OAAO,EAAE,SAAS,EAAE,OAAO,EAAE,IAAI,EAAE,OAAO,EAAE,IAAI,EAAE,OAAO,EAAE,OAAO,EAAE,IAAI,EAAE,OAAO,EAAE,IAAI,CAAC,CAAC;AAEjf,MAAM8B,OAAO,GAAG,CAAC,CAAC;AAElB,SAASC,cAAcA,CAACC,OAAO,EAAE;EAC/B,IAAIC,OAAO,GAAG5B,oBAAoB,CAACG,MAAM,GACvC,UAAU,GAAG0B,qBAAqB,CAACF,OAAO,CAAC,GAAG,GAAG,GACjD,qBAAqB,GAAGzB,gBAAgB,CAAC4B,IAAI,CAAC,GAAG,CAAC,GAAG,KAAK;EAC5D,IAAIH,OAAO,CAACI,kBAAkB,EAAE;IAC9B,MAAMC,WAAW,GAAG,EAAE;IACtB,KAAK,IAAIC,CAAC,GAAGN,OAAO,CAACI,kBAAkB,CAACG,MAAM,GAAG,CAAC,EAAED,CAAC,IAAI,CAAC,EAAEA,CAAC,EAAE,EAAE;MAC/DD,WAAW,CAACC,CAAC,CAAC,GAAG,KAAK,GACpB,GAAG,GAAGN,OAAO,CAACI,kBAAkB,CAACE,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC9B,MAAM,GAAG,OAAO,GACvDyB,OAAO,GACP,OAAO,GAAGD,OAAO,CAACI,kBAAkB,CAACE,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC9B,MAAM,GAAG,GAAG,GACvD,GAAG;IACP;IACA6B,WAAW,CAACG,IAAI,CAAC,KAAK,GAAGP,OAAO,GAAG,GAAG,CAAC;IACvCA,OAAO,GAAG,KAAK,GAAGI,WAAW,CAACF,IAAI,CAAC,GAAG,CAAC,GAAG,GAAG;EAC/C;EACA,OAAO,IAAInB,MAAM,CAAC,OAAO,GAAGiB,OAAO,CAAC;AACtC;AAEA,SAASC,qBAAqBA,CAACF,OAAO,EAAE;EACtC,OAAO1B,iBAAiB,CAACmC,MAAM,CAC7BT,OAAO,CAACU,gBAAgB,IAAI,EAC9B,CAAC,CAACC,GAAG,CAAC,UAAUC,MAAM,EAAE;IACtB,OAAO,KAAK,GAAGA,MAAM,CAACpC,MAAM,GAAG,GAAG;EACpC,CAAC,CAAC,CAAC2B,IAAI,CAAC,GAAG,CAAC;AACd;AAEA,OAAO,MAAMU,UAAU,CAAC;EACtBC,WAAWA,CAACC,IAAI,EAAEf,OAAO,EAAE;IACzB,IAAI,CAACe,IAAI,GAAGA,IAAI;IAChB,IAAI,CAACf,OAAO,GAAGA,OAAO;EACxB;EAEA,MAAMgB,KAAKA,CAAA,EAAG;IACZ,IAAID,IAAI,GAAG,IAAI,CAACA,IAAI;IACpB,MAAMf,OAAO,GAAG,IAAI,CAACA,OAAO;IAE5B,MAAMiB,KAAK,GAAG,EAAE;IAAE,IAAIC,OAAO;IAC7B,MAAMC,SAAS,GAAGpB,cAAc,CAACC,OAAO,CAAC;IACzC,IAAIoB,IAAI,EAAEC,OAAO,EAAEC,OAAO;IAC1B,OAAOP,IAAI,EAAE;MACXK,IAAI,GAAGL,IAAI;MACX;MACA,IAAI,CAACG,OAAO,IAAI,CAACtB,OAAO,CAAC1B,GAAG,CAACgD,OAAO,CAAC,EAAE;QACrC,IAAIK,OAAO,GAAGR,IAAI,CAACS,OAAO,CAAC,GAAG,CAAC;QAC/B,IAAID,OAAO,KAAK,CAAC,EAAE;UACjB;UACA,IAAI,OAAO,CAACE,IAAI,CAACV,IAAI,CAAC,EAAE;YACtB,MAAMW,UAAU,GAAGX,IAAI,CAACS,OAAO,CAAC,KAAK,CAAC;YAEtC,IAAIE,UAAU,IAAI,CAAC,EAAE;cACnB,IAAI1B,OAAO,CAAC2B,OAAO,EAAE;gBACnB,MAAM3B,OAAO,CAAC2B,OAAO,CAACZ,IAAI,CAACa,SAAS,CAAC,CAAC,EAAEF,UAAU,CAAC,CAAC;cACtD;cACAX,IAAI,GAAGA,IAAI,CAACa,SAAS,CAACF,UAAU,GAAG,CAAC,CAAC;cACrCL,OAAO,GAAG,EAAE;cACZ;YACF;UACF;;UAEA;UACA,IAAI,OAAO,CAACI,IAAI,CAACV,IAAI,CAAC,EAAE;YACtB,MAAMc,cAAc,GAAGd,IAAI,CAACS,OAAO,CAAC,IAAI,CAAC;YAEzC,IAAIK,cAAc,IAAI,CAAC,EAAE;cACvB,IAAI7B,OAAO,CAAC2B,OAAO,EAAE;gBACnB,MAAM3B,OAAO,CAAC2B,OAAO,CAACZ,IAAI,CAACa,SAAS,CAAC,CAAC,EAAEC,cAAc,GAAG,CAAC,CAAC,EAAE,IAAI,CAAC,kBAAkB,CAAC;cACvF;cACAd,IAAI,GAAGA,IAAI,CAACa,SAAS,CAACC,cAAc,GAAG,CAAC,CAAC;cACzCR,OAAO,GAAG,EAAE;cACZ;YACF;UACF;;UAEA;UACA,MAAMS,YAAY,GAAGf,IAAI,CAACgB,KAAK,CAAC5C,OAAO,CAAC;UACxC,IAAI2C,YAAY,EAAE;YAChB,IAAI9B,OAAO,CAACb,OAAO,EAAE;cACnBa,OAAO,CAACb,OAAO,CAAC2C,YAAY,CAAC,CAAC,CAAC,CAAC;YAClC;YACAf,IAAI,GAAGA,IAAI,CAACa,SAAS,CAACE,YAAY,CAAC,CAAC,CAAC,CAACvB,MAAM,CAAC;YAC7Cc,OAAO,GAAG,EAAE;YACZ;UACF;;UAEA;UACA,MAAMW,WAAW,GAAGjB,IAAI,CAACgB,KAAK,CAAC7C,MAAM,CAAC;UACtC,IAAI8C,WAAW,EAAE;YACfjB,IAAI,GAAGA,IAAI,CAACa,SAAS,CAACI,WAAW,CAAC,CAAC,CAAC,CAACzB,MAAM,CAAC;YAC5C,MAAMxC,YAAY,CAACiE,WAAW,CAAC,CAAC,CAAC,EAAE9C,MAAM,EAAE+C,WAAW,CAAC;YACvDZ,OAAO,GAAG,GAAG,GAAGW,WAAW,CAAC,CAAC,CAAC,CAAC5D,WAAW,CAAC,CAAC;YAC5C;UACF;;UAEA;UACA,MAAM8D,aAAa,GAAGC,aAAa,CAACpB,IAAI,CAAC;UACzC,IAAImB,aAAa,EAAE;YACjBnB,IAAI,GAAGmB,aAAa,CAACE,IAAI;YACzB,MAAMC,cAAc,CAACH,aAAa,CAAC;YACnCb,OAAO,GAAGa,aAAa,CAACI,OAAO,CAAClE,WAAW,CAAC,CAAC;YAC7C;UACF;;UAEA;UACA,IAAI4B,OAAO,CAACuC,oBAAoB,EAAE;YAChChB,OAAO,GAAGR,IAAI,CAACS,OAAO,CAAC,GAAG,EAAE,CAAC,CAAC;UAChC;QACF;QAEA,IAAIgB,IAAI;QACR,IAAIjB,OAAO,IAAI,CAAC,EAAE;UAChBiB,IAAI,GAAGzB,IAAI,CAACa,SAAS,CAAC,CAAC,EAAEL,OAAO,CAAC;UACjCR,IAAI,GAAGA,IAAI,CAACa,SAAS,CAACL,OAAO,CAAC;QAChC,CAAC,MAAM;UACLiB,IAAI,GAAGzB,IAAI;UACXA,IAAI,GAAG,EAAE;QACX;;QAEA;QACA,IAAI0B,YAAY,GAAGN,aAAa,CAACpB,IAAI,CAAC;QACtC,IAAI0B,YAAY,EAAE;UAChBnB,OAAO,GAAGmB,YAAY,CAACH,OAAO;QAChC,CAAC,MAAM;UACLG,YAAY,GAAG1B,IAAI,CAACgB,KAAK,CAAC7C,MAAM,CAAC;UACjC,IAAIuD,YAAY,EAAE;YAChBnB,OAAO,GAAG,GAAG,GAAGmB,YAAY,CAAC,CAAC,CAAC;UACjC,CAAC,MAAM;YACLnB,OAAO,GAAG,EAAE;UACd;QACF;QAEA,IAAItB,OAAO,CAAC0C,KAAK,EAAE;UACjB,MAAM1C,OAAO,CAAC0C,KAAK,CAACF,IAAI,EAAEnB,OAAO,EAAEC,OAAO,CAAC;QAC7C;QACAD,OAAO,GAAG,EAAE;MACd,CAAC,MAAM;QACL,MAAMsB,UAAU,GAAGzB,OAAO,CAAC9C,WAAW,CAAC,CAAC;QACxC,MAAMwE,YAAY,GAAG9C,OAAO,CAAC6C,UAAU,CAAC,KAAK7C,OAAO,CAAC6C,UAAU,CAAC,GAAG,IAAI3D,MAAM,CAAC,gBAAgB,GAAG2D,UAAU,GAAG,QAAQ,EAAE,GAAG,CAAC,CAAC;QAE7H5B,IAAI,GAAG,MAAMhD,YAAY,CAACgD,IAAI,EAAE6B,YAAY,EAAE,OAAOC,CAAC,EAAEL,IAAI,KAAK;UAC/D,IAAIG,UAAU,KAAK,QAAQ,IAAIA,UAAU,KAAK,OAAO,IAAIA,UAAU,KAAK,UAAU,EAAE;YAClFH,IAAI,GAAGA,IAAI,CACRnD,OAAO,CAAC,oBAAoB,EAAE,IAAI,CAAC,CACnCA,OAAO,CAAC,2BAA2B,EAAE,IAAI,CAAC;UAC/C;UAEA,IAAIW,OAAO,CAAC0C,KAAK,EAAE;YACjB,MAAM1C,OAAO,CAAC0C,KAAK,CAACF,IAAI,CAAC;UAC3B;UAEA,OAAO,EAAE;QACX,CAAC,CAAC;QAEF,MAAMP,WAAW,CAAC,IAAI,GAAGU,UAAU,GAAG,GAAG,EAAEA,UAAU,CAAC;MACxD;MAEA,IAAI5B,IAAI,KAAKK,IAAI,EAAE;QACjB,MAAM,IAAI0B,KAAK,CAAC,eAAe,GAAG/B,IAAI,CAAC;MACzC;IACF;IAEA,IAAI,CAACf,OAAO,CAAC+C,aAAa,EAAE;MAC1B;MACA,MAAMd,WAAW,CAAC,CAAC;IACrB;IAEA,SAASE,aAAaA,CAACa,KAAK,EAAE;MAC5B,MAAMC,KAAK,GAAGD,KAAK,CAACjB,KAAK,CAAChD,YAAY,CAAC;MACvC,IAAIkE,KAAK,EAAE;QACT,MAAMlB,KAAK,GAAG;UACZO,OAAO,EAAEW,KAAK,CAAC,CAAC,CAAC;UACjBC,KAAK,EAAE;QACT,CAAC;QACDF,KAAK,GAAGA,KAAK,CAACG,KAAK,CAACF,KAAK,CAAC,CAAC,CAAC,CAAC1C,MAAM,CAAC;QACpC,IAAI6C,GAAG,EAAEC,IAAI;QACb,OAAO,EAAED,GAAG,GAAGJ,KAAK,CAACjB,KAAK,CAAC9C,aAAa,CAAC,CAAC,KAAKoE,IAAI,GAAGL,KAAK,CAACjB,KAAK,CAACZ,SAAS,CAAC,CAAC,EAAE;UAC7E6B,KAAK,GAAGA,KAAK,CAACG,KAAK,CAACE,IAAI,CAAC,CAAC,CAAC,CAAC9C,MAAM,CAAC;UACnCwB,KAAK,CAACmB,KAAK,CAAC1C,IAAI,CAAC6C,IAAI,CAAC;QACxB;QACA,IAAID,GAAG,EAAE;UACPrB,KAAK,CAACuB,UAAU,GAAGF,GAAG,CAAC,CAAC,CAAC;UACzBrB,KAAK,CAACK,IAAI,GAAGY,KAAK,CAACG,KAAK,CAACC,GAAG,CAAC,CAAC,CAAC,CAAC7C,MAAM,CAAC;UACvC,OAAOwB,KAAK;QACd;MACF;IACF;IAEA,eAAewB,YAAYA,CAACjB,OAAO,EAAE;MACnC,IAAIkB,OAAO,CAAClB,OAAO,CAAC,IAAI,CAAC,EAAE;QACzB,MAAML,WAAW,CAAC,EAAE,EAAEK,OAAO,CAAC;QAC9B,OAAO,IAAI;MACb;IACF;IAEA,eAAeD,cAAcA,CAACN,KAAK,EAAE;MACnC,MAAMO,OAAO,GAAGP,KAAK,CAACO,OAAO;MAC7B,IAAIgB,UAAU,GAAGvB,KAAK,CAACuB,UAAU;MAEjC,IAAItD,OAAO,CAACyD,KAAK,EAAE;QACjB,IAAIvC,OAAO,KAAK,GAAG,IAAIrB,WAAW,CAAC3B,GAAG,CAACoE,OAAO,CAAC,EAAE;UAC/C,MAAML,WAAW,CAAC,EAAE,EAAEf,OAAO,CAAC;QAChC,CAAC,MAAM,IAAIoB,OAAO,KAAK,OAAO,EAAE;UAC9B,MAAMiB,YAAY,CAAC,OAAO,CAAC;QAC7B,CAAC,MAAM,IAAIjB,OAAO,KAAK,OAAO,EAAE;UAC9B,IAAI,EAAC,MAAMiB,YAAY,CAAC,OAAO,CAAC,GAAE;YAChC,MAAMA,YAAY,CAAC,OAAO,CAAC;UAC7B;QACF;QACA,IAAIjB,OAAO,KAAK,KAAK,IAAIkB,OAAO,CAAC,UAAU,CAAC,GAAG,CAAC,EAAE;UAChDtC,OAAO,GAAG,UAAU;UACpBD,KAAK,CAACT,IAAI,CAAC;YAAEkD,GAAG,EAAExC,OAAO;YAAEgC,KAAK,EAAE;UAAG,CAAC,CAAC;UACvC,IAAIlD,OAAO,CAACiD,KAAK,EAAE;YACjB,MAAMjD,OAAO,CAACiD,KAAK,CAAC/B,OAAO,EAAE,EAAE,EAAE,KAAK,EAAE,EAAE,CAAC;UAC7C;QACF;MACF;MAEA,IAAI,CAAClB,OAAO,CAACyD,KAAK,IAAI,CAAChE,MAAM,CAACvB,GAAG,CAACoE,OAAO,CAAC,EAAE;QAC1C,OAAOpB,OAAO,IAAIzB,MAAM,CAACvB,GAAG,CAACgD,OAAO,CAAC,EAAE;UACrC,MAAMe,WAAW,CAAC,EAAE,EAAEf,OAAO,CAAC;QAChC;MACF;MAEA,IAAIxB,SAAS,CAACxB,GAAG,CAACoE,OAAO,CAAC,IAAIpB,OAAO,KAAKoB,OAAO,EAAE;QACjD,MAAML,WAAW,CAAC,EAAE,EAAEK,OAAO,CAAC;MAChC;MAEA,MAAMqB,KAAK,GAAGnE,KAAK,CAACtB,GAAG,CAACoE,OAAO,CAAC,IAAKA,OAAO,KAAK,MAAM,IAAIpB,OAAO,KAAK,MAAO,IAAI,CAAC,CAACoC,UAAU;MAE9F,MAAMJ,KAAK,GAAGnB,KAAK,CAACmB,KAAK,CAACvC,GAAG,CAAC,UAAUiD,IAAI,EAAE;QAC5C,IAAIC,IAAI,EAAEC,KAAK,EAAEC,UAAU,EAAEC,WAAW,EAAEC,YAAY,EAAEC,KAAK;QAC7D,MAAMC,GAAG,GAAG,CAAC,CAAC,CAAC;;QAEf;QACA,IAAI/E,yBAAyB,IAAIwE,IAAI,CAAC,CAAC,CAAC,CAACpC,OAAO,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC,EAAE;UAC7D,IAAIoC,IAAI,CAAC,CAAC,CAAC,KAAK,EAAE,EAAE;YAAE,OAAOA,IAAI,CAAC,CAAC,CAAC;UAAE;UACtC,IAAIA,IAAI,CAAC,CAAC,CAAC,KAAK,EAAE,EAAE;YAAE,OAAOA,IAAI,CAAC,CAAC,CAAC;UAAE;UACtC,IAAIA,IAAI,CAAC,CAAC,CAAC,KAAK,EAAE,EAAE;YAAE,OAAOA,IAAI,CAAC,CAAC,CAAC;UAAE;QACxC;QAEA,SAASQ,QAAQA,CAACC,KAAK,EAAE;UACvBJ,YAAY,GAAGL,IAAI,CAACS,KAAK,CAAC;UAC1BP,KAAK,GAAGF,IAAI,CAACS,KAAK,GAAG,CAAC,CAAC;UACvB,IAAI,OAAOP,KAAK,KAAK,WAAW,EAAE;YAChC,OAAO,GAAG;UACZ;UACAA,KAAK,GAAGF,IAAI,CAACS,KAAK,GAAG,CAAC,CAAC;UACvB,IAAI,OAAOP,KAAK,KAAK,WAAW,EAAE;YAChC,OAAO,IAAI;UACb;UACAA,KAAK,GAAGF,IAAI,CAACS,KAAK,GAAG,CAAC,CAAC;UACvB,IAAI,OAAOP,KAAK,KAAK,WAAW,IAAInE,SAAS,CAACzB,GAAG,CAAC2F,IAAI,CAAC,EAAE;YACvDC,KAAK,GAAGD,IAAI;UACd;UACA,OAAO,EAAE;QACX;QAEA,IAAIS,CAAC,GAAG,CAAC;QACT,IAAItE,OAAO,CAACI,kBAAkB,EAAE;UAC9B,KAAK,IAAIE,CAAC,GAAG,CAAC,EAAEiE,CAAC,GAAGvE,OAAO,CAACI,kBAAkB,CAACG,MAAM,EAAED,CAAC,GAAGiE,CAAC,EAAEjE,CAAC,EAAE,EAAEgE,CAAC,IAAIH,GAAG,EAAE;YAC3EN,IAAI,GAAGD,IAAI,CAACU,CAAC,GAAG,CAAC,CAAC;YAClB,IAAIT,IAAI,EAAE;cACRK,KAAK,GAAGE,QAAQ,CAACE,CAAC,GAAG,CAAC,CAAC;cACvBP,UAAU,GAAGH,IAAI,CAACU,CAAC,CAAC;cACpBN,WAAW,GAAGJ,IAAI,CAACU,CAAC,GAAG,CAAC,CAAC;cACzB;YACF;UACF;QACF;QAEA,IAAI,CAACT,IAAI,KAAKA,IAAI,GAAGD,IAAI,CAACU,CAAC,CAAC,CAAC,EAAE;UAC7BJ,KAAK,GAAGE,QAAQ,CAACE,CAAC,GAAG,CAAC,CAAC;QACzB;QAEA,OAAO;UACLT,IAAI;UACJC,KAAK;UACLG,YAAY,EAAEA,YAAY,IAAI,GAAG;UACjCF,UAAU,EAAEA,UAAU,IAAI,EAAE;UAC5BC,WAAW,EAAEA,WAAW,IAAI,EAAE;UAC9BE,KAAK,EAAEA,KAAK,IAAI;QAClB,CAAC;MACH,CAAC,CAAC;MAEF,IAAI,CAACP,KAAK,EAAE;QACV1C,KAAK,CAACT,IAAI,CAAC;UAAEkD,GAAG,EAAEpB,OAAO;UAAEY;QAAM,CAAC,CAAC;QACnChC,OAAO,GAAGoB,OAAO;QACjBgB,UAAU,GAAG,EAAE;MACjB;MAEA,IAAItD,OAAO,CAACiD,KAAK,EAAE;QACjB,MAAMjD,OAAO,CAACiD,KAAK,CAACX,OAAO,EAAEY,KAAK,EAAES,KAAK,EAAEL,UAAU,CAAC;MACxD;IACF;IAEA,SAASE,OAAOA,CAAClB,OAAO,EAAE;MACxB,IAAIkC,GAAG;MACP,MAAMC,MAAM,GAAGnC,OAAO,CAAClE,WAAW,CAAC,CAAC;MACpC,KAAKoG,GAAG,GAAGvD,KAAK,CAACV,MAAM,GAAG,CAAC,EAAEiE,GAAG,IAAI,CAAC,EAAEA,GAAG,EAAE,EAAE;QAC5C,IAAIvD,KAAK,CAACuD,GAAG,CAAC,CAACd,GAAG,CAACtF,WAAW,CAAC,CAAC,KAAKqG,MAAM,EAAE;UAC3C;QACF;MACF;MACA,OAAOD,GAAG;IACZ;IAEA,eAAevC,WAAWA,CAACyB,GAAG,EAAEpB,OAAO,EAAE;MACvC,IAAIkC,GAAG;;MAEP;MACA,IAAIlC,OAAO,EAAE;QACXkC,GAAG,GAAGhB,OAAO,CAAClB,OAAO,CAAC;MACxB,CAAC,MAAM;QAAE;QACPkC,GAAG,GAAG,CAAC;MACT;MAEA,IAAIA,GAAG,IAAI,CAAC,EAAE;QACZ;QACA,KAAK,IAAIlE,CAAC,GAAGW,KAAK,CAACV,MAAM,GAAG,CAAC,EAAED,CAAC,IAAIkE,GAAG,EAAElE,CAAC,EAAE,EAAE;UAC5C,IAAIN,OAAO,CAACoD,GAAG,EAAE;YACfpD,OAAO,CAACoD,GAAG,CAACnC,KAAK,CAACX,CAAC,CAAC,CAACoD,GAAG,EAAEzC,KAAK,CAACX,CAAC,CAAC,CAAC4C,KAAK,EAAE5C,CAAC,GAAGkE,GAAG,IAAI,CAACd,GAAG,CAAC;UAC5D;QACF;;QAEA;QACAzC,KAAK,CAACV,MAAM,GAAGiE,GAAG;QAClBtD,OAAO,GAAGsD,GAAG,IAAIvD,KAAK,CAACuD,GAAG,GAAG,CAAC,CAAC,CAACd,GAAG;MACrC,CAAC,MAAM,IAAIpB,OAAO,CAAClE,WAAW,CAAC,CAAC,KAAK,IAAI,EAAE;QACzC,IAAI4B,OAAO,CAACiD,KAAK,EAAE;UACjB,MAAMjD,OAAO,CAACiD,KAAK,CAACX,OAAO,EAAE,EAAE,EAAE,IAAI,EAAE,EAAE,CAAC;QAC5C;MACF,CAAC,MAAM,IAAIA,OAAO,CAAClE,WAAW,CAAC,CAAC,KAAK,GAAG,EAAE;QACxC,IAAI4B,OAAO,CAACiD,KAAK,EAAE;UACjB,MAAMjD,OAAO,CAACiD,KAAK,CAACX,OAAO,EAAE,EAAE,EAAE,KAAK,EAAE,EAAE,EAAE,IAAI,CAAC;QACnD;QACA,IAAItC,OAAO,CAACoD,GAAG,EAAE;UACfpD,OAAO,CAACoD,GAAG,CAACd,OAAO,EAAE,EAAE,CAAC;QAC1B;MACF;IACF;EACF;AACF;AAEA,OAAO,MAAMoC,SAAS,GAAI3D,IAAI,IAAK;EACjC,IAAI4D,OAAO,GAAG,EAAE;EAEhB,MAAMC,MAAM,GAAG,IAAI/D,UAAU,CAACE,IAAI,EAAE;IAClCkC,KAAK,EAAE,SAAAA,CAAUS,GAAG,EAAER,KAAK,EAAES,KAAK,EAAE;MAClCgB,OAAO,IAAI,GAAG,GAAGjB,GAAG;MAEpB,KAAK,IAAIpD,CAAC,GAAG,CAAC,EAAEuE,GAAG,GAAG3B,KAAK,CAAC3C,MAAM,EAAED,CAAC,GAAGuE,GAAG,EAAEvE,CAAC,EAAE,EAAE;QAChDqE,OAAO,IAAI,GAAG,GAAGzB,KAAK,CAAC5C,CAAC,CAAC,CAACuD,IAAI,GAAG,IAAI,GAAG,CAACX,KAAK,CAAC5C,CAAC,CAAC,CAACwD,KAAK,IAAI,EAAE,EAAEzE,OAAO,CAAC,IAAI,EAAE,OAAO,CAAC,GAAG,GAAG;MAC7F;MAEAsF,OAAO,IAAI,CAAChB,KAAK,GAAG,GAAG,GAAG,EAAE,IAAI,GAAG;IACrC,CAAC;IACDP,GAAG,EAAE,SAAAA,CAAUM,GAAG,EAAE;MAClBiB,OAAO,IAAI,IAAI,GAAGjB,GAAG,GAAG,GAAG;IAC7B,CAAC;IACDhB,KAAK,EAAE,SAAAA,CAAUF,IAAI,EAAE;MACrBmC,OAAO,IAAInC,IAAI;IACjB,CAAC;IACDb,OAAO,EAAE,SAAAA,CAAUa,IAAI,EAAE;MACvBmC,OAAO,IAAI,MAAM,GAAGnC,IAAI,GAAG,KAAK;IAClC,CAAC;IACDsC,MAAM,EAAE,SAAAA,CAAUtC,IAAI,EAAE;MACtBmC,OAAO,IAAInC,IAAI;IACjB;EACF,CAAC,CAAC;EAEFoC,MAAM,CAAC5D,KAAK,CAAC,CAAC;EAEd,OAAO2D,OAAO;AAChB,CAAC;AAED,OAAO,MAAMI,SAAS,GAAGA,CAAChE,IAAI,EAAEiE,GAAG,KAAK;EACtC;EACA,MAAMC,GAAG,GAAG;IACVlE,IAAI,EAAE,IAAI;IACVmE,IAAI,EAAE,IAAI;IACVC,IAAI,EAAE,IAAI;IACVC,KAAK,EAAE;EACT,CAAC;;EAED;EACA,MAAMC,SAAS,GAAG;IAChBC,IAAI,EAAE,MAAM;IACZC,IAAI,EAAE;EACR,CAAC;EAED,IAAIP,GAAG,EAAE;IACPA,GAAG,GAAGA,GAAG,CAACQ,aAAa,IAAKR,GAAG,CAACS,gBAAgB,IAAIT,GAAG,CAACS,gBAAgB,CAAC,CAAE,IAAIT,GAAG;EACpF,CAAC,MAAM,IAAI,OAAOU,WAAW,KAAK,WAAW,EAAE;IAC7CV,GAAG,GAAG,IAAIU,WAAW,CAAC,CAAC;EACzB,CAAC,MAAM,IAAI,OAAOC,QAAQ,KAAK,WAAW,IAAIA,QAAQ,CAACC,cAAc,IAAID,QAAQ,CAACC,cAAc,CAACC,cAAc,EAAE;IAC/Gb,GAAG,GAAGW,QAAQ,CAACC,cAAc,CAACC,cAAc,CAAC,EAAE,EAAE,EAAE,EAAE,IAAI,CAAC;EAC5D,CAAC,MAAM,IAAI,OAAOC,OAAO,KAAK,WAAW,EAAE;IACzCd,GAAG,GAAG,IAAIe,aAAa,CAAC,mBAAmB,CAAC;EAC9C;EAEA,MAAMC,KAAK,GAAG,EAAE;EAChB,MAAMC,eAAe,GAAGjB,GAAG,CAACiB,eAAe,IAAKjB,GAAG,CAACkB,kBAAkB,IAAIlB,GAAG,CAACkB,kBAAkB,CAAC,CAAE;;EAEnG;EACA;EACA,IAAI,CAACD,eAAe,IAAIjB,GAAG,CAACmB,aAAa,EAAE;IACzC,CAAC,YAAY;MACX,MAAMpF,IAAI,GAAGiE,GAAG,CAACmB,aAAa,CAAC,MAAM,CAAC;MACtC,MAAMjB,IAAI,GAAGF,GAAG,CAACmB,aAAa,CAAC,MAAM,CAAC;MACtCjB,IAAI,CAACkB,WAAW,CAACpB,GAAG,CAACmB,aAAa,CAAC,OAAO,CAAC,CAAC;MAC5CpF,IAAI,CAACqF,WAAW,CAAClB,IAAI,CAAC;MACtBnE,IAAI,CAACqF,WAAW,CAACpB,GAAG,CAACmB,aAAa,CAAC,MAAM,CAAC,CAAC;MAC3CnB,GAAG,CAACoB,WAAW,CAACrF,IAAI,CAAC;IACvB,CAAC,EAAE,CAAC;EACN;;EAEA;EACA,IAAIiE,GAAG,CAACqB,oBAAoB,EAAE;IAC5B,KAAK,MAAM/F,CAAC,IAAI2E,GAAG,EAAE;MACnBA,GAAG,CAAC3E,CAAC,CAAC,GAAG0E,GAAG,CAACqB,oBAAoB,CAAC/F,CAAC,CAAC,CAAC,CAAC,CAAC;IACzC;EACF;;EAEA;EACA;EACA,IAAIgG,aAAa,GAAGrB,GAAG,CAACE,IAAI;EAE5B,MAAMP,MAAM,GAAG,IAAI/D,UAAU,CAACE,IAAI,EAAE;IAClCkC,KAAK,EAAE,SAAAA,CAAUX,OAAO,EAAEY,KAAK,EAAES,KAAK,EAAE;MACtC;MACA;MACA,IAAIsB,GAAG,CAAC3C,OAAO,CAAC,EAAE;QAChBgE,aAAa,GAAGrB,GAAG,CAAC3C,OAAO,CAAC;QAC5B;MACF;MAEA,MAAMiE,IAAI,GAAGvB,GAAG,CAACmB,aAAa,CAAC7D,OAAO,CAAC;MAEvC,KAAK,MAAMe,IAAI,IAAIH,KAAK,EAAE;QACxBqD,IAAI,CAACC,YAAY,CAACtD,KAAK,CAACG,IAAI,CAAC,CAACQ,IAAI,EAAEX,KAAK,CAACG,IAAI,CAAC,CAACS,KAAK,CAAC;MACxD;MAEA,IAAIuB,SAAS,CAAC/C,OAAO,CAAC,IAAI,OAAO2C,GAAG,CAACI,SAAS,CAAC/C,OAAO,CAAC,CAAC,KAAK,SAAS,EAAE;QACtE2C,GAAG,CAACI,SAAS,CAAC/C,OAAO,CAAC,CAAC,CAAC8D,WAAW,CAACG,IAAI,CAAC;MAC3C,CAAC,MAAM,IAAID,aAAa,IAAIA,aAAa,CAACF,WAAW,EAAE;QACrDE,aAAa,CAACF,WAAW,CAACG,IAAI,CAAC;MACjC;MAEA,IAAI,CAAC5C,KAAK,EAAE;QACVqC,KAAK,CAACxF,IAAI,CAAC+F,IAAI,CAAC;QAChBD,aAAa,GAAGC,IAAI;MACtB;IACF,CAAC;IACDnD,GAAG,EAAE,SAAUA;IAAA,GAAW;MACxB4C,KAAK,CAACzF,MAAM,IAAI,CAAC;;MAEjB;MACA+F,aAAa,GAAGN,KAAK,CAACA,KAAK,CAACzF,MAAM,GAAG,CAAC,CAAC;IACzC,CAAC;IACDmC,KAAK,EAAE,SAAAA,CAAUF,IAAI,EAAE;MACrB8D,aAAa,CAACF,WAAW,CAACpB,GAAG,CAACyB,cAAc,CAACjE,IAAI,CAAC,CAAC;IACrD,CAAC;IACDb,OAAO,EAAE,SAAUA;IAAA,GAAY;MAC7B;IAAA,CACD;IACDmD,MAAM,EAAE,SAAUA;IAAA,GAAY;MAC5B;IAAA;EAEJ,CAAC,CAAC;EAEFF,MAAM,CAAC5D,KAAK,CAAC,CAAC;EAEd,OAAOgE,GAAG;AACZ,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}