{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nconst he_1 = require(\"he\");\nconst node_1 = __importDefault(require(\"./node\"));\nconst type_1 = __importDefault(require(\"./type\"));\n/**\n * TextNode to contain a text element in DOM tree.\n * @param {string} value [description]\n */\nclass TextNode extends node_1.default {\n  clone() {\n    return new TextNode(this._rawText, null);\n  }\n  constructor(rawText, parentNode = null, range) {\n    super(parentNode, range);\n    /**\n     * Node Type declaration.\n     * @type {Number}\n     */\n    this.nodeType = type_1.default.TEXT_NODE;\n    this.rawTagName = '';\n    this._rawText = rawText;\n  }\n  get rawText() {\n    return this._rawText;\n  }\n  /**\n   * Set rawText and invalidate trimmed caches\n   */\n  set rawText(text) {\n    this._rawText = text;\n    this._trimmedRawText = void 0;\n    this._trimmedText = void 0;\n  }\n  /**\n   * Returns raw text with all whitespace trimmed except single leading/trailing non-breaking space\n   */\n  get trimmedRawText() {\n    if (this._trimmedRawText !== undefined) return this._trimmedRawText;\n    this._trimmedRawText = trimText(this.rawText);\n    return this._trimmedRawText;\n  }\n  /**\n   * Returns text with all whitespace trimmed except single leading/trailing non-breaking space\n   */\n  get trimmedText() {\n    if (this._trimmedText !== undefined) return this._trimmedText;\n    this._trimmedText = trimText(this.text);\n    return this._trimmedText;\n  }\n  /**\n   * Get unescaped text value of current node and its children.\n   * @return {string} text content\n   */\n  get text() {\n    return (0, he_1.decode)(this.rawText);\n  }\n  /**\n   * Detect if the node contains only white space.\n   * @return {boolean}\n   */\n  get isWhitespace() {\n    return /^(\\s|&nbsp;)*$/.test(this.rawText);\n  }\n  toString() {\n    return this.rawText;\n  }\n}\nexports.default = TextNode;\n/**\n * Trim whitespace except single leading/trailing non-breaking space\n */\nfunction trimText(text) {\n  let i = 0;\n  let startPos;\n  let endPos;\n  while (i >= 0 && i < text.length) {\n    if (/\\S/.test(text[i])) {\n      if (startPos === undefined) {\n        startPos = i;\n        i = text.length;\n      } else {\n        endPos = i;\n        i = void 0;\n      }\n    }\n    if (startPos === undefined) i++;else i--;\n  }\n  if (startPos === undefined) startPos = 0;\n  if (endPos === undefined) endPos = text.length - 1;\n  const hasLeadingSpace = startPos > 0 && /[^\\S\\r\\n]/.test(text[startPos - 1]);\n  const hasTrailingSpace = endPos < text.length - 1 && /[^\\S\\r\\n]/.test(text[endPos + 1]);\n  return (hasLeadingSpace ? ' ' : '') + text.slice(startPos, endPos + 1) + (hasTrailingSpace ? ' ' : '');\n}","map":{"version":3,"names":["__importDefault","mod","__esModule","Object","defineProperty","exports","value","he_1","require","node_1","type_1","TextNode","default","clone","_rawText","constructor","rawText","parentNode","range","nodeType","TEXT_NODE","rawTagName","text","_trimmedRawText","_trimmedText","trimmedRawText","undefined","trimText","trimmedText","decode","isWhitespace","test","toString","i","startPos","endPos","length","hasLeadingSpace","hasTrailingSpace","slice"],"sources":["F:/landinghub-iconic/node_modules/.pnpm/node-html-parser@7.0.1/node_modules/node-html-parser/dist/nodes/text.js"],"sourcesContent":["\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst he_1 = require(\"he\");\nconst node_1 = __importDefault(require(\"./node\"));\nconst type_1 = __importDefault(require(\"./type\"));\n/**\n * TextNode to contain a text element in DOM tree.\n * @param {string} value [description]\n */\nclass TextNode extends node_1.default {\n    clone() {\n        return new TextNode(this._rawText, null);\n    }\n    constructor(rawText, parentNode = null, range) {\n        super(parentNode, range);\n        /**\n         * Node Type declaration.\n         * @type {Number}\n         */\n        this.nodeType = type_1.default.TEXT_NODE;\n        this.rawTagName = '';\n        this._rawText = rawText;\n    }\n    get rawText() {\n        return this._rawText;\n    }\n    /**\n     * Set rawText and invalidate trimmed caches\n     */\n    set rawText(text) {\n        this._rawText = text;\n        this._trimmedRawText = void 0;\n        this._trimmedText = void 0;\n    }\n    /**\n     * Returns raw text with all whitespace trimmed except single leading/trailing non-breaking space\n     */\n    get trimmedRawText() {\n        if (this._trimmedRawText !== undefined)\n            return this._trimmedRawText;\n        this._trimmedRawText = trimText(this.rawText);\n        return this._trimmedRawText;\n    }\n    /**\n     * Returns text with all whitespace trimmed except single leading/trailing non-breaking space\n     */\n    get trimmedText() {\n        if (this._trimmedText !== undefined)\n            return this._trimmedText;\n        this._trimmedText = trimText(this.text);\n        return this._trimmedText;\n    }\n    /**\n     * Get unescaped text value of current node and its children.\n     * @return {string} text content\n     */\n    get text() {\n        return (0, he_1.decode)(this.rawText);\n    }\n    /**\n     * Detect if the node contains only white space.\n     * @return {boolean}\n     */\n    get isWhitespace() {\n        return /^(\\s|&nbsp;)*$/.test(this.rawText);\n    }\n    toString() {\n        return this.rawText;\n    }\n}\nexports.default = TextNode;\n/**\n * Trim whitespace except single leading/trailing non-breaking space\n */\nfunction trimText(text) {\n    let i = 0;\n    let startPos;\n    let endPos;\n    while (i >= 0 && i < text.length) {\n        if (/\\S/.test(text[i])) {\n            if (startPos === undefined) {\n                startPos = i;\n                i = text.length;\n            }\n            else {\n                endPos = i;\n                i = void 0;\n            }\n        }\n        if (startPos === undefined)\n            i++;\n        else\n            i--;\n    }\n    if (startPos === undefined)\n        startPos = 0;\n    if (endPos === undefined)\n        endPos = text.length - 1;\n    const hasLeadingSpace = startPos > 0 && /[^\\S\\r\\n]/.test(text[startPos - 1]);\n    const hasTrailingSpace = endPos < (text.length - 1) && /[^\\S\\r\\n]/.test(text[endPos + 1]);\n    return (hasLeadingSpace ? ' ' : '') + text.slice(startPos, endPos + 1) + (hasTrailingSpace ? ' ' : '');\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}