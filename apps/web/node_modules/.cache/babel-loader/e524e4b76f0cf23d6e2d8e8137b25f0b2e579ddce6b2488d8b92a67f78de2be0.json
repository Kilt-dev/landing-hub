{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.parse = exports.base_parse = void 0;\nconst css_select_1 = require(\"css-select\");\nconst he_1 = __importDefault(require(\"he\"));\nconst back_1 = __importDefault(require(\"../back\"));\nconst matcher_1 = __importDefault(require(\"../matcher\"));\nconst void_tag_1 = __importDefault(require(\"../void-tag\"));\nconst comment_1 = __importDefault(require(\"./comment\"));\nconst node_1 = __importDefault(require(\"./node\"));\nconst text_1 = __importDefault(require(\"./text\"));\nconst type_1 = __importDefault(require(\"./type\"));\nfunction decode(val) {\n  // clone string\n  return JSON.parse(JSON.stringify(he_1.default.decode(val)));\n}\n// https://developer.mozilla.org/en-US/docs/Web/HTML/Block-level_elements\nconst Htags = ['h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'header', 'hgroup'];\nconst Dtags = ['details', 'dialog', 'dd', 'div', 'dt'];\nconst Ftags = ['fieldset', 'figcaption', 'figure', 'footer', 'form'];\nconst tableTags = ['table', 'td', 'tr'];\nconst htmlTags = ['address', 'article', 'aside', 'blockquote', 'br', 'hr', 'li', 'main', 'nav', 'ol', 'p', 'pre', 'section', 'ul'];\nconst kBlockElements = new Set();\nfunction addToKBlockElement(...args) {\n  const addToSet = array => {\n    for (let index = 0; index < array.length; index++) {\n      const element = array[index];\n      kBlockElements.add(element);\n      kBlockElements.add(element.toUpperCase());\n    }\n  };\n  for (const arg of args) addToSet(arg);\n}\naddToKBlockElement(Htags, Dtags, Ftags, tableTags, htmlTags);\nclass DOMTokenList {\n  _validate(c) {\n    if (/\\s/.test(c)) {\n      throw new Error(`DOMException in DOMTokenList.add: The token '${c}' contains HTML space characters, which are not valid in tokens.`);\n    }\n  }\n  constructor(valuesInit = [], afterUpdate = () => null) {\n    this._set = new Set(valuesInit);\n    this._afterUpdate = afterUpdate;\n  }\n  add(c) {\n    this._validate(c);\n    this._set.add(c);\n    this._afterUpdate(this); // eslint-disable-line @typescript-eslint/no-unsafe-call\n  }\n  replace(c1, c2) {\n    this._validate(c2);\n    this._set.delete(c1);\n    this._set.add(c2);\n    this._afterUpdate(this); // eslint-disable-line @typescript-eslint/no-unsafe-call\n  }\n  remove(c) {\n    this._set.delete(c) && this._afterUpdate(this); // eslint-disable-line @typescript-eslint/no-unsafe-call\n  }\n  toggle(c) {\n    this._validate(c);\n    if (this._set.has(c)) this._set.delete(c);else this._set.add(c);\n    this._afterUpdate(this); // eslint-disable-line @typescript-eslint/no-unsafe-call\n  }\n  contains(c) {\n    return this._set.has(c);\n  }\n  get length() {\n    return this._set.size;\n  }\n  values() {\n    return this._set.values();\n  }\n  get value() {\n    return Array.from(this._set.values());\n  }\n  toString() {\n    return Array.from(this._set.values()).join(' ');\n  }\n}\n/**\n * HTMLElement, which contains a set of children.\n *\n * Note: this is a minimalist implementation, no complete tree\n *   structure provided (no parentNode, nextSibling,\n *   previousSibling etc).\n * @class HTMLElement\n * @extends {Node}\n */\nclass HTMLElement extends node_1.default {\n  /**\n   * Quote attribute values\n   * @param attr attribute value\n   * @returns {string} quoted value\n   */\n  quoteAttribute(attr) {\n    if (attr == null) {\n      return 'null';\n    }\n    return JSON.stringify(attr.replace(/\"/g, '&quot;')).replace(/\\\\t/g, '\\t').replace(/\\\\n/g, '\\n').replace(/\\\\r/g, '\\r').replace(/\\\\/g, '');\n  }\n  /**\n   * Creates an instance of HTMLElement.\n   * @param keyAttrs\tid and class attribute\n   * @param [rawAttrs]\tattributes in string\n   *\n   * @memberof HTMLElement\n   */\n  constructor(tagName, keyAttrs, rawAttrs = '', parentNode = null, range, voidTag = new void_tag_1.default(), _parseOptions = {}) {\n    super(parentNode, range);\n    this.rawAttrs = rawAttrs;\n    this.voidTag = voidTag;\n    /**\n     * Node Type declaration.\n     */\n    this.nodeType = type_1.default.ELEMENT_NODE;\n    this.rawTagName = tagName;\n    this.rawAttrs = rawAttrs || '';\n    this.id = keyAttrs.id || '';\n    this.childNodes = [];\n    this._parseOptions = _parseOptions;\n    this.classList = new DOMTokenList(keyAttrs.class ? keyAttrs.class.split(/\\s+/) : [], classList => this.setAttribute('class', classList.toString()) // eslint-disable-line @typescript-eslint/no-unsafe-member-access, @typescript-eslint/no-unsafe-call\n    );\n    if (keyAttrs.id) {\n      if (!rawAttrs) {\n        this.rawAttrs = `id=\"${keyAttrs.id}\"`;\n      }\n    }\n    if (keyAttrs.class) {\n      if (!rawAttrs) {\n        const cls = `class=\"${this.classList.toString()}\"`;\n        if (this.rawAttrs) {\n          this.rawAttrs += ` ${cls}`;\n        } else {\n          this.rawAttrs = cls;\n        }\n      }\n    }\n  }\n  /**\n   * Remove Child element from childNodes array\n   * @param {HTMLElement} node     node to remove\n   */\n  removeChild(node) {\n    this.childNodes = this.childNodes.filter(child => {\n      return child !== node;\n    });\n    return this;\n  }\n  /**\n   * Exchanges given child with new child\n   * @param {HTMLElement} oldNode     node to exchange\n   * @param {HTMLElement} newNode     new node\n   */\n  exchangeChild(oldNode, newNode) {\n    const children = this.childNodes;\n    this.childNodes = children.map(child => {\n      if (child === oldNode) {\n        return newNode;\n      }\n      return child;\n    });\n    return this;\n  }\n  get tagName() {\n    return this.rawTagName ? this.rawTagName.toUpperCase() : this.rawTagName;\n  }\n  set tagName(newname) {\n    this.rawTagName = newname.toLowerCase();\n  }\n  get localName() {\n    return this.rawTagName.toLowerCase();\n  }\n  get isVoidElement() {\n    return this.voidTag.isVoidElement(this.localName);\n  }\n  /**\n   * Get escpaed (as-it) text value of current node and its children.\n   * @return {string} text content\n   */\n  get rawText() {\n    // https://github.com/taoqf/node-html-parser/issues/249\n    if (/^br$/i.test(this.rawTagName)) {\n      return '\\n';\n    }\n    return this.childNodes.reduce((pre, cur) => {\n      return pre += cur.rawText;\n    }, '');\n  }\n  get textContent() {\n    return decode(this.rawText);\n  }\n  set textContent(val) {\n    const content = [new text_1.default(val, this)];\n    this.childNodes = content;\n  }\n  /**\n   * Get unescaped text value of current node and its children.\n   * @return {string} text content\n   */\n  get text() {\n    return decode(this.rawText);\n  }\n  /**\n   * Get structured Text (with '\\n' etc.)\n   * @return {string} structured text\n   */\n  get structuredText() {\n    let currentBlock = [];\n    const blocks = [currentBlock];\n    function dfs(node) {\n      if (node.nodeType === type_1.default.ELEMENT_NODE) {\n        if (kBlockElements.has(node.rawTagName)) {\n          if (currentBlock.length > 0) {\n            blocks.push(currentBlock = []);\n          }\n          node.childNodes.forEach(dfs);\n          if (currentBlock.length > 0) {\n            blocks.push(currentBlock = []);\n          }\n        } else {\n          node.childNodes.forEach(dfs);\n        }\n      } else if (node.nodeType === type_1.default.TEXT_NODE) {\n        if (node.isWhitespace) {\n          // Whitespace node, postponed output\n          currentBlock.prependWhitespace = true;\n        } else {\n          let text = node.trimmedText;\n          if (currentBlock.prependWhitespace) {\n            text = ` ${text}`;\n            currentBlock.prependWhitespace = false;\n          }\n          currentBlock.push(text);\n        }\n      }\n    }\n    dfs(this);\n    return blocks.map(block => {\n      return block.join('').replace(/\\s{2,}/g, ' '); // Normalize each line's whitespace\n    }).join('\\n').replace(/\\s+$/, ''); // trimRight;\n  }\n  toString() {\n    const tag = this.rawTagName;\n    if (tag) {\n      const attrs = this.rawAttrs ? ` ${this.rawAttrs}` : '';\n      return this.voidTag.formatNode(tag, attrs, this.innerHTML);\n    }\n    return this.innerHTML;\n  }\n  get innerHTML() {\n    return this.childNodes.map(child => {\n      return child.toString();\n    }).join('');\n  }\n  set innerHTML(content) {\n    const r = parse(content, this._parseOptions);\n    const nodes = r.childNodes.length ? r.childNodes : [new text_1.default(content, this)];\n    resetParent(nodes, this);\n    resetParent(this.childNodes, null);\n    this.childNodes = nodes;\n  }\n  set_content(content, options = {}) {\n    if (content instanceof node_1.default) {\n      content = [content];\n    } else if (typeof content == 'string') {\n      options = Object.assign(Object.assign({}, this._parseOptions), options);\n      const r = parse(content, options);\n      content = r.childNodes.length ? r.childNodes : [new text_1.default(r.innerHTML, this)];\n    }\n    resetParent(this.childNodes, null);\n    resetParent(content, this);\n    this.childNodes = content;\n    return this;\n  }\n  replaceWith(...nodes) {\n    const parent = this.parentNode;\n    const content = nodes.map(node => {\n      if (node instanceof node_1.default) {\n        return [node];\n      } else if (typeof node == 'string') {\n        const r = parse(node, this._parseOptions);\n        return r.childNodes.length ? r.childNodes : [new text_1.default(node, this)];\n      }\n      return [];\n    }).flat();\n    const idx = parent.childNodes.findIndex(child => {\n      return child === this;\n    });\n    resetParent([this], null);\n    parent.childNodes = [...parent.childNodes.slice(0, idx), ...resetParent(content, parent), ...parent.childNodes.slice(idx + 1)];\n    return this;\n  }\n  get outerHTML() {\n    return this.toString();\n  }\n  /**\n   * Trim element from right (in block) after seeing pattern in a TextNode.\n   * @param  {RegExp} pattern pattern to find\n   * @return {HTMLElement}    reference to current node\n   */\n  trimRight(pattern) {\n    for (let i = 0; i < this.childNodes.length; i++) {\n      const childNode = this.childNodes[i];\n      if (childNode.nodeType === type_1.default.ELEMENT_NODE) {\n        childNode.trimRight(pattern);\n      } else {\n        const index = childNode.rawText.search(pattern);\n        if (index > -1) {\n          childNode.rawText = childNode.rawText.substr(0, index);\n          // trim all following nodes.\n          this.childNodes.length = i + 1;\n        }\n      }\n    }\n    return this;\n  }\n  /**\n   * Get DOM structure\n   * @return {string} structure\n   */\n  get structure() {\n    const res = [];\n    let indention = 0;\n    function write(str) {\n      res.push('  '.repeat(indention) + str);\n    }\n    function dfs(node) {\n      const idStr = node.id ? `#${node.id}` : '';\n      const classStr = node.classList.length ? `.${node.classList.value.join('.')}` : ''; // eslint-disable-line @typescript-eslint/no-unsafe-member-access, @typescript-eslint/no-unsafe-member-access, @typescript-eslint/restrict-template-expressions, @typescript-eslint/no-unsafe-call\n      write(`${node.rawTagName}${idStr}${classStr}`);\n      indention++;\n      node.childNodes.forEach(childNode => {\n        if (childNode.nodeType === type_1.default.ELEMENT_NODE) {\n          dfs(childNode);\n        } else if (childNode.nodeType === type_1.default.TEXT_NODE) {\n          if (!childNode.isWhitespace) {\n            write('#text');\n          }\n        }\n      });\n      indention--;\n    }\n    dfs(this);\n    return res.join('\\n');\n  }\n  /**\n   * Remove whitespaces in this sub tree.\n   * @return {HTMLElement} pointer to this\n   */\n  removeWhitespace() {\n    let o = 0;\n    this.childNodes.forEach(node => {\n      if (node.nodeType === type_1.default.TEXT_NODE) {\n        if (node.isWhitespace) {\n          return;\n        }\n        node.rawText = node.trimmedRawText;\n      } else if (node.nodeType === type_1.default.ELEMENT_NODE) {\n        node.removeWhitespace();\n      }\n      this.childNodes[o++] = node;\n    });\n    this.childNodes.length = o;\n    // remove whitespace between attributes\n    const attrs = Object.keys(this.rawAttributes).map(key => {\n      const val = this.rawAttributes[key];\n      return `${key}=${JSON.stringify(val)}`;\n    }).join(' ');\n    this.rawAttrs = attrs;\n    delete this._rawAttrs;\n    return this;\n  }\n  /**\n   * Query CSS selector to find matching nodes.\n   * @param  {string}         selector Simplified CSS selector\n   * @return {HTMLElement[]}  matching elements\n   */\n  querySelectorAll(selector) {\n    return (0, css_select_1.selectAll)(selector, this, {\n      xmlMode: true,\n      adapter: matcher_1.default\n    });\n  }\n  /**\n   * Query CSS Selector to find matching node.\n   * @param  {string}         selector Simplified CSS selector\n   * @return {(HTMLElement|null)}    matching node\n   */\n  querySelector(selector) {\n    return (0, css_select_1.selectOne)(selector, this, {\n      xmlMode: true,\n      adapter: matcher_1.default\n    });\n  }\n  /**\n   * find elements by their tagName\n   * @param {string} tagName the tagName of the elements to select\n   */\n  getElementsByTagName(tagName) {\n    const upperCasedTagName = tagName.toUpperCase();\n    const re = [];\n    const stack = [];\n    let currentNodeReference = this;\n    let index = 0;\n    // index turns to undefined once the stack is empty and the first condition occurs\n    // which happens once all relevant children are searched through\n    while (index !== undefined) {\n      let child;\n      // make it work with sparse arrays\n      do {\n        child = currentNodeReference.childNodes[index++];\n      } while (index < currentNodeReference.childNodes.length && child === undefined);\n      // if the child does not exist we move on with the last provided index (which belongs to the parentNode)\n      if (child === undefined) {\n        currentNodeReference = currentNodeReference.parentNode;\n        index = stack.pop();\n        continue;\n      }\n      if (child.nodeType === type_1.default.ELEMENT_NODE) {\n        // https://developer.mozilla.org/en-US/docs/Web/API/Element/getElementsByTagName#syntax\n        if (tagName === '*' || child.tagName === upperCasedTagName) re.push(child);\n        // if children are existing push the current status to the stack and keep searching for elements in the level below\n        if (child.childNodes.length > 0) {\n          stack.push(index);\n          currentNodeReference = child;\n          index = 0;\n        }\n      }\n    }\n    return re;\n  }\n  /**\n   * find element by it's id\n   * @param {string} id the id of the element to select\n   * @returns {HTMLElement | null} the element with the given id or null if not found\n   */\n  getElementById(id) {\n    const stack = [];\n    let currentNodeReference = this;\n    let index = 0;\n    // index turns to undefined once the stack is empty and the first condition occurs\n    // which happens once all relevant children are searched through\n    while (index !== undefined) {\n      let child;\n      // make it work with sparse arrays\n      do {\n        child = currentNodeReference.childNodes[index++];\n      } while (index < currentNodeReference.childNodes.length && child === undefined);\n      // if the child does not exist we move on with the last provided index (which belongs to the parentNode)\n      if (child === undefined) {\n        currentNodeReference = currentNodeReference.parentNode;\n        index = stack.pop();\n        continue;\n      }\n      if (child.nodeType === type_1.default.ELEMENT_NODE) {\n        if (child.id === id) {\n          return child;\n        }\n        // if children are existing push the current status to the stack and keep searching for elements in the level below\n        if (child.childNodes.length > 0) {\n          stack.push(index);\n          currentNodeReference = child;\n          index = 0;\n        }\n      }\n    }\n    return null;\n  }\n  /**\n   * traverses the Element and its parents (heading toward the document root) until it finds a node that matches the provided selector string. Will return itself or the matching ancestor. If no such element exists, it returns null.\n   * @param selector a DOMString containing a selector list\n   * @returns {HTMLElement | null} the element with the given id or null if not found\n   */\n  closest(selector) {\n    const mapChild = new Map();\n    let el = this;\n    let old = null;\n    function findOne(test, elems) {\n      let elem = null;\n      for (let i = 0, l = elems.length; i < l && !elem; i++) {\n        const el = elems[i];\n        if (test(el)) {\n          elem = el;\n        } else {\n          const child = mapChild.get(el);\n          if (child) {\n            elem = findOne(test, [child]);\n          }\n        }\n      }\n      return elem;\n    }\n    while (el) {\n      mapChild.set(el, old);\n      old = el;\n      el = el.parentNode;\n    }\n    el = this;\n    while (el) {\n      const e = (0, css_select_1.selectOne)(selector, el, {\n        xmlMode: true,\n        adapter: Object.assign(Object.assign({}, matcher_1.default), {\n          getChildren(node) {\n            const child = mapChild.get(node);\n            return child && [child];\n          },\n          getSiblings(node) {\n            return [node];\n          },\n          findOne,\n          findAll() {\n            return [];\n          }\n        })\n      });\n      if (e) {\n        return e;\n      }\n      el = el.parentNode;\n    }\n    return null;\n  }\n  /**\n   * Append a child node to childNodes\n   * @param  {Node} node node to append\n   * @return {Node}      node appended\n   */\n  appendChild(node) {\n    this.append(node);\n    return node;\n  }\n  /**\n   * Get attributes\n   * @access private\n   * @return {Object} parsed and unescaped attributes\n   */\n  get attrs() {\n    if (this._attrs) {\n      return this._attrs;\n    }\n    this._attrs = {};\n    const attrs = this.rawAttributes;\n    for (const key in attrs) {\n      const val = attrs[key] || '';\n      this._attrs[key.toLowerCase()] = decode(val);\n    }\n    return this._attrs;\n  }\n  get attributes() {\n    const ret_attrs = {};\n    const attrs = this.rawAttributes;\n    for (const key in attrs) {\n      const val = attrs[key] || '';\n      ret_attrs[key] = decode(val);\n    }\n    return ret_attrs;\n  }\n  /**\n   * Get escaped (as-is) attributes\n   * @return {Object} parsed attributes\n   */\n  get rawAttributes() {\n    if (this._rawAttrs) {\n      return this._rawAttrs;\n    }\n    const attrs = {};\n    if (this.rawAttrs) {\n      const re = /([a-zA-Z()[\\]#@$.?:][a-zA-Z0-9-._:()[\\]#]*)(?:\\s*=\\s*((?:'[^']*')|(?:\"[^\"]*\")|\\S+))?/g;\n      let match;\n      while (match = re.exec(this.rawAttrs)) {\n        const key = match[1];\n        let val = match[2] || null;\n        if (val && (val[0] === `'` || val[0] === `\"`)) val = val.slice(1, val.length - 1);\n        attrs[key] = attrs[key] || val;\n      }\n    }\n    this._rawAttrs = attrs;\n    return attrs;\n  }\n  removeAttribute(key) {\n    const attrs = this.rawAttributes;\n    delete attrs[key];\n    // Update this.attribute\n    if (this._attrs) {\n      delete this._attrs[key];\n    }\n    // Update rawString\n    this.rawAttrs = Object.keys(attrs).map(name => {\n      const val = this.quoteAttribute(attrs[name]);\n      if (val === 'null' || val === '\"\"') return name;\n      return `${name}=${val}`;\n    }).join(' ');\n    // Update this.id\n    if (key === 'id') {\n      this.id = '';\n    }\n    return this;\n  }\n  hasAttribute(key) {\n    return key.toLowerCase() in this.attrs;\n  }\n  /**\n   * Get an attribute\n   * @return {string | undefined} value of the attribute; or undefined if not exist\n   */\n  getAttribute(key) {\n    return this.attrs[key.toLowerCase()];\n  }\n  /**\n   * Set an attribute value to the HTMLElement\n   * @param {string} key The attribute name\n   * @param {string} value The value to set, or null / undefined to remove an attribute\n   */\n  setAttribute(key, value) {\n    if (arguments.length < 2) {\n      throw new Error(\"Failed to execute 'setAttribute' on 'Element'\");\n    }\n    const k2 = key.toLowerCase();\n    const attrs = this.rawAttributes;\n    for (const k in attrs) {\n      if (k.toLowerCase() === k2) {\n        key = k;\n        break;\n      }\n    }\n    attrs[key] = String(value);\n    // update this.attrs\n    if (this._attrs) {\n      this._attrs[k2] = decode(attrs[key]);\n    }\n    // Update rawString\n    this.rawAttrs = Object.keys(attrs).map(name => {\n      const val = this.quoteAttribute(attrs[name]);\n      if (val === 'null' || val === '\"\"') return name;\n      return `${name}=${val}`;\n    }).join(' ');\n    // Update this.id\n    if (key === 'id') {\n      this.id = value;\n    }\n    return this;\n  }\n  /**\n   * Replace all the attributes of the HTMLElement by the provided attributes\n   * @param {Attributes} attributes the new attribute set\n   */\n  setAttributes(attributes) {\n    // Invalidate current this.attributes\n    if (this._attrs) {\n      delete this._attrs;\n    }\n    // Invalidate current this.rawAttributes\n    if (this._rawAttrs) {\n      delete this._rawAttrs;\n    }\n    // Update rawString\n    this.rawAttrs = Object.keys(attributes).map(name => {\n      const val = attributes[name];\n      if (val === 'null' || val === '\"\"') return name;\n      return `${name}=${this.quoteAttribute(String(val))}`;\n    }).join(' ');\n    return this;\n  }\n  insertAdjacentHTML(where, html) {\n    if (arguments.length < 2) {\n      throw new Error('2 arguments required');\n    }\n    const p = parse(html, this._parseOptions);\n    if (where === 'afterend') {\n      this.after(...p.childNodes);\n    } else if (where === 'afterbegin') {\n      this.prepend(...p.childNodes);\n    } else if (where === 'beforeend') {\n      this.append(...p.childNodes);\n    } else if (where === 'beforebegin') {\n      this.before(...p.childNodes);\n    } else {\n      throw new Error(`The value provided ('${where}') is not one of 'beforebegin', 'afterbegin', 'beforeend', or 'afterend'`);\n    }\n    return this;\n  }\n  /** Prepend nodes or strings to this node's children. */\n  prepend(...insertable) {\n    const nodes = resolveInsertable(insertable);\n    resetParent(nodes, this);\n    this.childNodes.unshift(...nodes);\n  }\n  /** Append nodes or strings to this node's children. */\n  append(...insertable) {\n    const nodes = resolveInsertable(insertable);\n    resetParent(nodes, this);\n    this.childNodes.push(...nodes);\n  }\n  /** Insert nodes or strings before this node. */\n  before(...insertable) {\n    const nodes = resolveInsertable(insertable);\n    const siblings = this.parentNode.childNodes;\n    resetParent(nodes, this.parentNode);\n    siblings.splice(siblings.indexOf(this), 0, ...nodes);\n  }\n  /** Insert nodes or strings after this node. */\n  after(...insertable) {\n    const nodes = resolveInsertable(insertable);\n    const siblings = this.parentNode.childNodes;\n    resetParent(nodes, this.parentNode);\n    siblings.splice(siblings.indexOf(this) + 1, 0, ...nodes);\n  }\n  get nextSibling() {\n    if (this.parentNode) {\n      const children = this.parentNode.childNodes;\n      let i = 0;\n      while (i < children.length) {\n        const child = children[i++];\n        if (this === child) return children[i] || null;\n      }\n      return null;\n    }\n  }\n  get nextElementSibling() {\n    if (this.parentNode) {\n      const children = this.parentNode.childNodes;\n      let i = 0;\n      let find = false;\n      while (i < children.length) {\n        const child = children[i++];\n        if (find) {\n          if (child instanceof HTMLElement) {\n            return child || null;\n          }\n        } else if (this === child) {\n          find = true;\n        }\n      }\n      return null;\n    }\n  }\n  get previousSibling() {\n    if (this.parentNode) {\n      const children = this.parentNode.childNodes;\n      let i = children.length;\n      while (i > 0) {\n        const child = children[--i];\n        if (this === child) return children[i - 1] || null;\n      }\n      return null;\n    }\n  }\n  get previousElementSibling() {\n    if (this.parentNode) {\n      const children = this.parentNode.childNodes;\n      let i = children.length;\n      let find = false;\n      while (i > 0) {\n        const child = children[--i];\n        if (find) {\n          if (child instanceof HTMLElement) {\n            return child || null;\n          }\n        } else if (this === child) {\n          find = true;\n        }\n      }\n      return null;\n    }\n  }\n  /** Get all childNodes of type {@link HTMLElement}. */\n  get children() {\n    const children = [];\n    for (const childNode of this.childNodes) {\n      if (childNode instanceof HTMLElement) {\n        children.push(childNode);\n      }\n    }\n    return children;\n  }\n  /**\n   * Get the first child node.\n   * @return The first child or undefined if none exists.\n   */\n  get firstChild() {\n    return this.childNodes[0];\n  }\n  /**\n   * Get the first child node of type {@link HTMLElement}.\n   * @return The first child element or undefined if none exists.\n   */\n  get firstElementChild() {\n    return this.children[0];\n  }\n  /**\n   * Get the last child node.\n   * @return The last child or undefined if none exists.\n   */\n  get lastChild() {\n    return (0, back_1.default)(this.childNodes);\n  }\n  /**\n   * Get the last child node of type {@link HTMLElement}.\n   * @return The last child element or undefined if none exists.\n   */\n  get lastElementChild() {\n    return this.children[this.children.length - 1];\n  }\n  get childElementCount() {\n    return this.children.length;\n  }\n  get classNames() {\n    return this.classList.toString();\n  }\n  /** Clone this Node */\n  clone() {\n    return parse(this.toString(), this._parseOptions).firstChild;\n  }\n}\nexports.default = HTMLElement;\n// #xB7 | [#xC0-#xD6] | [#xD8-#xF6] | [#xF8-#x37D] | [#x37F-#x1FFF] | [#x200C-#x200D] | [#x203F-#x2040] | [#x2070-#x218F] | [#x2C00-#x2FEF] | [#x3001-#xD7FF] | [#xF900-#xFDCF] | [#xFDF0-#xFFFD] | [#x10000-#xEFFFF]\n// https://html.spec.whatwg.org/multipage/custom-elements.html#valid-custom-element-name\nconst kMarkupPattern = /<!--[\\s\\S]*?-->|<(\\/?)([a-zA-Z][-.:0-9_a-zA-Z@\\xB7\\xC0-\\xD6\\xD8-\\xF6\\u00F8-\\u03A1\\u03A3-\\u03D9\\u03DB-\\u03EF\\u03F7-\\u03FF\\u0400-\\u04FF\\u0500-\\u052F\\u1D00-\\u1D2B\\u1D6B-\\u1D77\\u1D79-\\u1D9A\\u1E00-\\u1E9B\\u1F00-\\u1F15\\u1F18-\\u1F1D\\u1F20-\\u1F45\\u1F48-\\u1F4D\\u1F50-\\u1F57\\u1F59\\u1F5B\\u1F5D\\u1F5F-\\u1F7D\\u1F80-\\u1FB4\\u1FB6-\\u1FBC\\u1FBE\\u1FC2-\\u1FC4\\u1FC6-\\u1FCC\\u1FD0-\\u1FD3\\u1FD6-\\u1FDB\\u1FE0-\\u1FEC\\u1FF2-\\u1FF4\\u1FF6-\\u1FFC\\u2126\\u212A-\\u212B\\u2132\\u214E\\u2160-\\u2188\\u2C60-\\u2C7F\\uA722-\\uA787\\uA78B-\\uA78E\\uA790-\\uA7AD\\uA7B0-\\uA7B7\\uA7F7-\\uA7FF\\uAB30-\\uAB5A\\uAB5C-\\uAB5F\\uAB64-\\uAB65\\uFB00-\\uFB06\\uFB13-\\uFB17\\uFF21-\\uFF3A\\uFF41-\\uFF5A\\x37F-\\u1FFF\\u200C-\\u200D\\u203F-\\u2040\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD]*)((?:\\s+[^>]*?(?:(?:'[^']*')|(?:\"[^\"]*\"))?)*)\\s*(\\/?)>/gu;\n// const kMarkupPattern = /<!--[\\s\\S]*?-->|<(\\/?)([a-zA-Z][-.:0-9_a-zA-Z]*)((?:\\s+[^>]*?(?:(?:'[^']*')|(?:\"[^\"]*\"))?)*)\\s*(\\/?)>/g;\nconst kAttributePattern = /(?:^|\\s)(id|class)\\s*=\\s*((?:'[^']*')|(?:\"[^\"]*\")|\\S+)/gi;\nconst kElementsClosedByOpening = {\n  li: {\n    li: true,\n    LI: true\n  },\n  LI: {\n    li: true,\n    LI: true\n  },\n  p: {\n    p: true,\n    div: true,\n    P: true,\n    DIV: true\n  },\n  P: {\n    p: true,\n    div: true,\n    P: true,\n    DIV: true\n  },\n  b: {\n    div: true,\n    DIV: true\n  },\n  B: {\n    div: true,\n    DIV: true\n  },\n  td: {\n    td: true,\n    th: true,\n    TD: true,\n    TH: true\n  },\n  TD: {\n    td: true,\n    th: true,\n    TD: true,\n    TH: true\n  },\n  th: {\n    td: true,\n    th: true,\n    TD: true,\n    TH: true\n  },\n  TH: {\n    td: true,\n    th: true,\n    TD: true,\n    TH: true\n  },\n  h1: {\n    h1: true,\n    H1: true\n  },\n  H1: {\n    h1: true,\n    H1: true\n  },\n  h2: {\n    h2: true,\n    H2: true\n  },\n  H2: {\n    h2: true,\n    H2: true\n  },\n  h3: {\n    h3: true,\n    H3: true\n  },\n  H3: {\n    h3: true,\n    H3: true\n  },\n  h4: {\n    h4: true,\n    H4: true\n  },\n  H4: {\n    h4: true,\n    H4: true\n  },\n  h5: {\n    h5: true,\n    H5: true\n  },\n  H5: {\n    h5: true,\n    H5: true\n  },\n  h6: {\n    h6: true,\n    H6: true\n  },\n  H6: {\n    h6: true,\n    H6: true\n  }\n};\nconst kElementsClosedByClosing = {\n  li: {\n    ul: true,\n    ol: true,\n    UL: true,\n    OL: true\n  },\n  LI: {\n    ul: true,\n    ol: true,\n    UL: true,\n    OL: true\n  },\n  a: {\n    div: true,\n    DIV: true\n  },\n  A: {\n    div: true,\n    DIV: true\n  },\n  b: {\n    div: true,\n    DIV: true\n  },\n  B: {\n    div: true,\n    DIV: true\n  },\n  i: {\n    div: true,\n    DIV: true\n  },\n  I: {\n    div: true,\n    DIV: true\n  },\n  p: {\n    div: true,\n    DIV: true\n  },\n  P: {\n    div: true,\n    DIV: true\n  },\n  td: {\n    tr: true,\n    table: true,\n    TR: true,\n    TABLE: true\n  },\n  TD: {\n    tr: true,\n    table: true,\n    TR: true,\n    TABLE: true\n  },\n  th: {\n    tr: true,\n    table: true,\n    TR: true,\n    TABLE: true\n  },\n  TH: {\n    tr: true,\n    table: true,\n    TR: true,\n    TABLE: true\n  }\n};\nconst frameflag = 'documentfragmentcontainer';\n/**\n * Parses HTML and returns a root element\n * Parse a chuck of HTML source.\n * @param  {string} data      html\n * @return {HTMLElement}      root element\n */\nfunction base_parse(data, options = {}) {\n  var _a, _b;\n  const voidTag = new void_tag_1.default((_a = options === null || options === void 0 ? void 0 : options.voidTag) === null || _a === void 0 ? void 0 : _a.closingSlash, (_b = options === null || options === void 0 ? void 0 : options.voidTag) === null || _b === void 0 ? void 0 : _b.tags);\n  const elements = options.blockTextElements || {\n    script: true,\n    noscript: true,\n    style: true,\n    pre: true\n  };\n  const element_names = Object.keys(elements);\n  const kBlockTextElements = element_names.map(it => new RegExp(`^${it}$`, 'i'));\n  const kIgnoreElements = element_names.filter(it => Boolean(elements[it])).map(it => new RegExp(`^${it}$`, 'i'));\n  function element_should_be_ignore(tag) {\n    return kIgnoreElements.some(it => it.test(tag));\n  }\n  function is_block_text_element(tag) {\n    return kBlockTextElements.some(it => it.test(tag));\n  }\n  const createRange = (startPos, endPos) => [startPos - frameFlagOffset, endPos - frameFlagOffset];\n  const root = new HTMLElement(null, {}, '', null, [0, data.length], voidTag, options);\n  let currentParent = root;\n  const stack = [root];\n  let lastTextPos = -1;\n  let noNestedTagIndex = undefined;\n  let match;\n  // https://github.com/taoqf/node-html-parser/issues/38\n  data = `<${frameflag}>${data}</${frameflag}>`;\n  const {\n    lowerCaseTagName,\n    fixNestedATags\n  } = options;\n  const dataEndPos = data.length - (frameflag.length + 2);\n  const frameFlagOffset = frameflag.length + 2;\n  while (match = kMarkupPattern.exec(data)) {\n    // Note: Object destructuring here consistently tests as higher performance than array destructuring\n    // eslint-disable-next-line prefer-const\n    let {\n      0: matchText,\n      1: leadingSlash,\n      2: tagName,\n      3: attributes,\n      4: closingSlash\n    } = match;\n    const matchLength = matchText.length;\n    const tagStartPos = kMarkupPattern.lastIndex - matchLength;\n    const tagEndPos = kMarkupPattern.lastIndex;\n    // Add TextNode if content\n    if (lastTextPos > -1) {\n      if (lastTextPos + matchLength < tagEndPos) {\n        const text = data.substring(lastTextPos, tagStartPos);\n        currentParent.appendChild(new text_1.default(text, currentParent, createRange(lastTextPos, tagStartPos)));\n      }\n    }\n    lastTextPos = kMarkupPattern.lastIndex;\n    // https://github.com/taoqf/node-html-parser/issues/38\n    // Skip frameflag node\n    if (tagName === frameflag) continue;\n    // Handle comments\n    if (matchText[1] === '!') {\n      if (options.comment) {\n        // Only keep what is in between <!-- and -->\n        const text = data.substring(tagStartPos + 4, tagEndPos - 3);\n        currentParent.appendChild(new comment_1.default(text, currentParent, createRange(tagStartPos, tagEndPos)));\n      }\n      continue;\n    }\n    /* -- Handle tag matching -- */\n    // Fix tag casing if necessary\n    if (lowerCaseTagName) tagName = tagName.toLowerCase();\n    // Handle opening tags (ie. <this> not </that>)\n    if (!leadingSlash) {\n      /* Populate attributes */\n      const attrs = {};\n      for (let attMatch; attMatch = kAttributePattern.exec(attributes);) {\n        const {\n          1: key,\n          2: val\n        } = attMatch;\n        const isQuoted = val[0] === `'` || val[0] === `\"`;\n        attrs[key.toLowerCase()] = isQuoted ? val.slice(1, val.length - 1) : val;\n      }\n      const parentTagName = currentParent.rawTagName;\n      if (!closingSlash && kElementsClosedByOpening[parentTagName]) {\n        if (kElementsClosedByOpening[parentTagName][tagName]) {\n          stack.pop();\n          currentParent = (0, back_1.default)(stack);\n        }\n      }\n      // Prevent nested A tags by terminating the last A and starting a new one : see issue #144\n      if (fixNestedATags && (tagName === 'a' || tagName === 'A')) {\n        if (noNestedTagIndex !== undefined) {\n          stack.splice(noNestedTagIndex);\n          currentParent = (0, back_1.default)(stack);\n        }\n        noNestedTagIndex = stack.length;\n      }\n      const tagEndPos = kMarkupPattern.lastIndex;\n      const tagStartPos = tagEndPos - matchLength;\n      currentParent = currentParent.appendChild(\n      // Initialize range (end position updated later for closed tags)\n      new HTMLElement(tagName, attrs, attributes.slice(1), null, createRange(tagStartPos, tagEndPos), voidTag, options));\n      stack.push(currentParent);\n      if (is_block_text_element(tagName)) {\n        // Find closing tag\n        const closeMarkup = `</${tagName}>`;\n        const closeIndex = lowerCaseTagName ? data.toLocaleLowerCase().indexOf(closeMarkup, kMarkupPattern.lastIndex) : data.indexOf(closeMarkup, kMarkupPattern.lastIndex);\n        const textEndPos = closeIndex === -1 ? dataEndPos : closeIndex;\n        if (element_should_be_ignore(tagName)) {\n          const text = data.substring(tagEndPos, textEndPos);\n          if (text.length > 0 && /\\S/.test(text)) {\n            currentParent.appendChild(new text_1.default(text, currentParent, createRange(tagEndPos, textEndPos)));\n          }\n        }\n        if (closeIndex === -1) {\n          lastTextPos = kMarkupPattern.lastIndex = data.length + 1;\n        } else {\n          lastTextPos = kMarkupPattern.lastIndex = closeIndex + closeMarkup.length;\n          // Cause to be treated as self-closing, because no close found\n          leadingSlash = '/';\n        }\n      }\n    }\n    // Handle closing tags or self-closed elements (ie </tag> or <br>)\n    if (leadingSlash || closingSlash || voidTag.isVoidElement(tagName)) {\n      while (true) {\n        if (noNestedTagIndex != null && (tagName === 'a' || tagName === 'A')) noNestedTagIndex = undefined;\n        if (currentParent.rawTagName === tagName) {\n          // Update range end for closed tag\n          currentParent.range[1] = createRange(-1, Math.max(lastTextPos, tagEndPos))[1];\n          stack.pop();\n          currentParent = (0, back_1.default)(stack);\n          break;\n        } else {\n          const parentTagName = currentParent.tagName;\n          // Trying to close current tag, and move on\n          if (kElementsClosedByClosing[parentTagName]) {\n            if (kElementsClosedByClosing[parentTagName][tagName]) {\n              stack.pop();\n              currentParent = (0, back_1.default)(stack);\n              continue;\n            }\n          }\n          // Use aggressive strategy to handle unmatching markups.\n          break;\n        }\n      }\n    }\n  }\n  return stack;\n}\nexports.base_parse = base_parse;\n/**\n * Parses HTML and returns a root element\n * Parse a chuck of HTML source.\n */\nfunction parse(data, options = {}) {\n  const stack = base_parse(data, options);\n  const [root] = stack;\n  while (stack.length > 1) {\n    // Handle each error elements.\n    const last = stack.pop();\n    const oneBefore = (0, back_1.default)(stack);\n    if (last.parentNode && last.parentNode.parentNode) {\n      if (last.parentNode === oneBefore && last.tagName === oneBefore.tagName) {\n        // Pair error case <h3> <h3> handle : Fixes to <h3> </h3>\n        // this is wrong, becouse this will put the H3 outside the current right position which should be inside the current Html Element, see issue 152 for more info\n        if (options.parseNoneClosedTags !== true) {\n          oneBefore.removeChild(last);\n          last.childNodes.forEach(child => {\n            oneBefore.parentNode.appendChild(child);\n          });\n          stack.pop();\n        }\n      } else {\n        // Single error  <div> <h3> </div> handle: Just removes <h3>\n        // Why remove? this is already a HtmlElement and the missing <H3> is already added in this case. see issue 152 for more info\n        // eslint-disable-next-line no-lonely-if\n        if (options.parseNoneClosedTags !== true) {\n          oneBefore.removeChild(last);\n          last.childNodes.forEach(child => {\n            oneBefore.appendChild(child);\n          });\n        }\n      }\n    } else {\n      // If it's final element just skip.\n    }\n  }\n  // response.childNodes.forEach((node) => {\n  // \tif (node instanceof HTMLElement) {\n  // \t\tnode.parentNode = null;\n  // \t}\n  // });\n  return root;\n}\nexports.parse = parse;\n/**\n * Resolves a list of {@link NodeInsertable} to a list of nodes,\n * and removes nodes from any potential parent.\n */\nfunction resolveInsertable(insertable) {\n  return insertable.map(val => {\n    if (typeof val === 'string') {\n      return new text_1.default(val);\n    }\n    val.remove();\n    return val;\n  });\n}\nfunction resetParent(nodes, parent) {\n  return nodes.map(node => {\n    node.parentNode = parent;\n    return node;\n  });\n}","map":{"version":3,"names":["__importDefault","mod","__esModule","Object","defineProperty","exports","value","parse","base_parse","css_select_1","require","he_1","back_1","matcher_1","void_tag_1","comment_1","node_1","text_1","type_1","decode","val","JSON","stringify","default","Htags","Dtags","Ftags","tableTags","htmlTags","kBlockElements","Set","addToKBlockElement","args","addToSet","array","index","length","element","add","toUpperCase","arg","DOMTokenList","_validate","c","test","Error","constructor","valuesInit","afterUpdate","_set","_afterUpdate","replace","c1","c2","delete","remove","toggle","has","contains","size","values","Array","from","toString","join","HTMLElement","quoteAttribute","attr","tagName","keyAttrs","rawAttrs","parentNode","range","voidTag","_parseOptions","nodeType","ELEMENT_NODE","rawTagName","id","childNodes","classList","class","split","setAttribute","cls","removeChild","node","filter","child","exchangeChild","oldNode","newNode","children","map","newname","toLowerCase","localName","isVoidElement","rawText","reduce","pre","cur","textContent","content","text","structuredText","currentBlock","blocks","dfs","push","forEach","TEXT_NODE","isWhitespace","prependWhitespace","trimmedText","block","tag","attrs","formatNode","innerHTML","r","nodes","resetParent","set_content","options","assign","replaceWith","parent","flat","idx","findIndex","slice","outerHTML","trimRight","pattern","i","childNode","search","substr","structure","res","indention","write","str","repeat","idStr","classStr","removeWhitespace","o","trimmedRawText","keys","rawAttributes","key","_rawAttrs","querySelectorAll","selector","selectAll","xmlMode","adapter","querySelector","selectOne","getElementsByTagName","upperCasedTagName","re","stack","currentNodeReference","undefined","pop","getElementById","closest","mapChild","Map","el","old","findOne","elems","elem","l","get","set","e","getChildren","getSiblings","findAll","appendChild","append","_attrs","attributes","ret_attrs","match","exec","removeAttribute","name","hasAttribute","getAttribute","arguments","k2","k","String","setAttributes","insertAdjacentHTML","where","html","p","after","prepend","before","insertable","resolveInsertable","unshift","siblings","splice","indexOf","nextSibling","nextElementSibling","find","previousSibling","previousElementSibling","firstChild","firstElementChild","lastChild","lastElementChild","childElementCount","classNames","clone","kMarkupPattern","kAttributePattern","kElementsClosedByOpening","li","LI","div","P","DIV","b","B","td","th","TD","TH","h1","H1","h2","H2","h3","H3","h4","H4","h5","H5","h6","H6","kElementsClosedByClosing","ul","ol","UL","OL","a","A","I","tr","table","TR","TABLE","frameflag","data","_a","_b","closingSlash","tags","elements","blockTextElements","script","noscript","style","element_names","kBlockTextElements","it","RegExp","kIgnoreElements","Boolean","element_should_be_ignore","some","is_block_text_element","createRange","startPos","endPos","frameFlagOffset","root","currentParent","lastTextPos","noNestedTagIndex","lowerCaseTagName","fixNestedATags","dataEndPos","matchText","leadingSlash","matchLength","tagStartPos","lastIndex","tagEndPos","substring","comment","attMatch","isQuoted","parentTagName","closeMarkup","closeIndex","toLocaleLowerCase","textEndPos","Math","max","last","oneBefore","parseNoneClosedTags"],"sources":["F:/landinghub-iconic/node_modules/.pnpm/node-html-parser@7.0.1/node_modules/node-html-parser/dist/nodes/html.js"],"sourcesContent":["\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.parse = exports.base_parse = void 0;\nconst css_select_1 = require(\"css-select\");\nconst he_1 = __importDefault(require(\"he\"));\nconst back_1 = __importDefault(require(\"../back\"));\nconst matcher_1 = __importDefault(require(\"../matcher\"));\nconst void_tag_1 = __importDefault(require(\"../void-tag\"));\nconst comment_1 = __importDefault(require(\"./comment\"));\nconst node_1 = __importDefault(require(\"./node\"));\nconst text_1 = __importDefault(require(\"./text\"));\nconst type_1 = __importDefault(require(\"./type\"));\nfunction decode(val) {\n    // clone string\n    return JSON.parse(JSON.stringify(he_1.default.decode(val)));\n}\n// https://developer.mozilla.org/en-US/docs/Web/HTML/Block-level_elements\nconst Htags = ['h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'header', 'hgroup'];\nconst Dtags = ['details', 'dialog', 'dd', 'div', 'dt'];\nconst Ftags = ['fieldset', 'figcaption', 'figure', 'footer', 'form'];\nconst tableTags = ['table', 'td', 'tr'];\nconst htmlTags = ['address', 'article', 'aside', 'blockquote', 'br', 'hr', 'li', 'main', 'nav', 'ol', 'p', 'pre', 'section', 'ul'];\nconst kBlockElements = new Set();\nfunction addToKBlockElement(...args) {\n    const addToSet = (array) => {\n        for (let index = 0; index < array.length; index++) {\n            const element = array[index];\n            kBlockElements.add(element);\n            kBlockElements.add(element.toUpperCase());\n        }\n    };\n    for (const arg of args)\n        addToSet(arg);\n}\naddToKBlockElement(Htags, Dtags, Ftags, tableTags, htmlTags);\nclass DOMTokenList {\n    _validate(c) {\n        if (/\\s/.test(c)) {\n            throw new Error(`DOMException in DOMTokenList.add: The token '${c}' contains HTML space characters, which are not valid in tokens.`);\n        }\n    }\n    constructor(valuesInit = [], afterUpdate = () => null) {\n        this._set = new Set(valuesInit);\n        this._afterUpdate = afterUpdate;\n    }\n    add(c) {\n        this._validate(c);\n        this._set.add(c);\n        this._afterUpdate(this); // eslint-disable-line @typescript-eslint/no-unsafe-call\n    }\n    replace(c1, c2) {\n        this._validate(c2);\n        this._set.delete(c1);\n        this._set.add(c2);\n        this._afterUpdate(this); // eslint-disable-line @typescript-eslint/no-unsafe-call\n    }\n    remove(c) {\n        this._set.delete(c) && this._afterUpdate(this); // eslint-disable-line @typescript-eslint/no-unsafe-call\n    }\n    toggle(c) {\n        this._validate(c);\n        if (this._set.has(c))\n            this._set.delete(c);\n        else\n            this._set.add(c);\n        this._afterUpdate(this); // eslint-disable-line @typescript-eslint/no-unsafe-call\n    }\n    contains(c) {\n        return this._set.has(c);\n    }\n    get length() {\n        return this._set.size;\n    }\n    values() {\n        return this._set.values();\n    }\n    get value() {\n        return Array.from(this._set.values());\n    }\n    toString() {\n        return Array.from(this._set.values()).join(' ');\n    }\n}\n/**\n * HTMLElement, which contains a set of children.\n *\n * Note: this is a minimalist implementation, no complete tree\n *   structure provided (no parentNode, nextSibling,\n *   previousSibling etc).\n * @class HTMLElement\n * @extends {Node}\n */\nclass HTMLElement extends node_1.default {\n    /**\n     * Quote attribute values\n     * @param attr attribute value\n     * @returns {string} quoted value\n     */\n    quoteAttribute(attr) {\n        if (attr == null) {\n            return 'null';\n        }\n        return JSON.stringify(attr.replace(/\"/g, '&quot;'))\n            .replace(/\\\\t/g, '\\t')\n            .replace(/\\\\n/g, '\\n')\n            .replace(/\\\\r/g, '\\r')\n            .replace(/\\\\/g, '');\n    }\n    /**\n     * Creates an instance of HTMLElement.\n     * @param keyAttrs\tid and class attribute\n     * @param [rawAttrs]\tattributes in string\n     *\n     * @memberof HTMLElement\n     */\n    constructor(tagName, keyAttrs, rawAttrs = '', parentNode = null, range, voidTag = new void_tag_1.default(), _parseOptions = {}) {\n        super(parentNode, range);\n        this.rawAttrs = rawAttrs;\n        this.voidTag = voidTag;\n        /**\n         * Node Type declaration.\n         */\n        this.nodeType = type_1.default.ELEMENT_NODE;\n        this.rawTagName = tagName;\n        this.rawAttrs = rawAttrs || '';\n        this.id = keyAttrs.id || '';\n        this.childNodes = [];\n        this._parseOptions = _parseOptions;\n        this.classList = new DOMTokenList(keyAttrs.class ? keyAttrs.class.split(/\\s+/) : [], (classList) => this.setAttribute('class', classList.toString()) // eslint-disable-line @typescript-eslint/no-unsafe-member-access, @typescript-eslint/no-unsafe-call\n        );\n        if (keyAttrs.id) {\n            if (!rawAttrs) {\n                this.rawAttrs = `id=\"${keyAttrs.id}\"`;\n            }\n        }\n        if (keyAttrs.class) {\n            if (!rawAttrs) {\n                const cls = `class=\"${this.classList.toString()}\"`;\n                if (this.rawAttrs) {\n                    this.rawAttrs += ` ${cls}`;\n                }\n                else {\n                    this.rawAttrs = cls;\n                }\n            }\n        }\n    }\n    /**\n     * Remove Child element from childNodes array\n     * @param {HTMLElement} node     node to remove\n     */\n    removeChild(node) {\n        this.childNodes = this.childNodes.filter((child) => {\n            return child !== node;\n        });\n        return this;\n    }\n    /**\n     * Exchanges given child with new child\n     * @param {HTMLElement} oldNode     node to exchange\n     * @param {HTMLElement} newNode     new node\n     */\n    exchangeChild(oldNode, newNode) {\n        const children = this.childNodes;\n        this.childNodes = children.map((child) => {\n            if (child === oldNode) {\n                return newNode;\n            }\n            return child;\n        });\n        return this;\n    }\n    get tagName() {\n        return this.rawTagName ? this.rawTagName.toUpperCase() : this.rawTagName;\n    }\n    set tagName(newname) {\n        this.rawTagName = newname.toLowerCase();\n    }\n    get localName() {\n        return this.rawTagName.toLowerCase();\n    }\n    get isVoidElement() {\n        return this.voidTag.isVoidElement(this.localName);\n    }\n    /**\n     * Get escpaed (as-it) text value of current node and its children.\n     * @return {string} text content\n     */\n    get rawText() {\n        // https://github.com/taoqf/node-html-parser/issues/249\n        if (/^br$/i.test(this.rawTagName)) {\n            return '\\n';\n        }\n        return this.childNodes.reduce((pre, cur) => {\n            return (pre += cur.rawText);\n        }, '');\n    }\n    get textContent() {\n        return decode(this.rawText);\n    }\n    set textContent(val) {\n        const content = [new text_1.default(val, this)];\n        this.childNodes = content;\n    }\n    /**\n     * Get unescaped text value of current node and its children.\n     * @return {string} text content\n     */\n    get text() {\n        return decode(this.rawText);\n    }\n    /**\n     * Get structured Text (with '\\n' etc.)\n     * @return {string} structured text\n     */\n    get structuredText() {\n        let currentBlock = [];\n        const blocks = [currentBlock];\n        function dfs(node) {\n            if (node.nodeType === type_1.default.ELEMENT_NODE) {\n                if (kBlockElements.has(node.rawTagName)) {\n                    if (currentBlock.length > 0) {\n                        blocks.push((currentBlock = []));\n                    }\n                    node.childNodes.forEach(dfs);\n                    if (currentBlock.length > 0) {\n                        blocks.push((currentBlock = []));\n                    }\n                }\n                else {\n                    node.childNodes.forEach(dfs);\n                }\n            }\n            else if (node.nodeType === type_1.default.TEXT_NODE) {\n                if (node.isWhitespace) {\n                    // Whitespace node, postponed output\n                    currentBlock.prependWhitespace = true;\n                }\n                else {\n                    let text = node.trimmedText;\n                    if (currentBlock.prependWhitespace) {\n                        text = ` ${text}`;\n                        currentBlock.prependWhitespace = false;\n                    }\n                    currentBlock.push(text);\n                }\n            }\n        }\n        dfs(this);\n        return blocks\n            .map((block) => {\n            return block.join('').replace(/\\s{2,}/g, ' '); // Normalize each line's whitespace\n        })\n            .join('\\n')\n            .replace(/\\s+$/, ''); // trimRight;\n    }\n    toString() {\n        const tag = this.rawTagName;\n        if (tag) {\n            const attrs = this.rawAttrs ? ` ${this.rawAttrs}` : '';\n            return this.voidTag.formatNode(tag, attrs, this.innerHTML);\n        }\n        return this.innerHTML;\n    }\n    get innerHTML() {\n        return this.childNodes\n            .map((child) => {\n            return child.toString();\n        })\n            .join('');\n    }\n    set innerHTML(content) {\n        const r = parse(content, this._parseOptions);\n        const nodes = r.childNodes.length ? r.childNodes : [new text_1.default(content, this)];\n        resetParent(nodes, this);\n        resetParent(this.childNodes, null);\n        this.childNodes = nodes;\n    }\n    set_content(content, options = {}) {\n        if (content instanceof node_1.default) {\n            content = [content];\n        }\n        else if (typeof content == 'string') {\n            options = Object.assign(Object.assign({}, this._parseOptions), options);\n            const r = parse(content, options);\n            content = r.childNodes.length ? r.childNodes : [new text_1.default(r.innerHTML, this)];\n        }\n        resetParent(this.childNodes, null);\n        resetParent(content, this);\n        this.childNodes = content;\n        return this;\n    }\n    replaceWith(...nodes) {\n        const parent = this.parentNode;\n        const content = nodes\n            .map((node) => {\n            if (node instanceof node_1.default) {\n                return [node];\n            }\n            else if (typeof node == 'string') {\n                const r = parse(node, this._parseOptions);\n                return r.childNodes.length ? r.childNodes : [new text_1.default(node, this)];\n            }\n            return [];\n        })\n            .flat();\n        const idx = parent.childNodes.findIndex((child) => {\n            return child === this;\n        });\n        resetParent([this], null);\n        parent.childNodes = [...parent.childNodes.slice(0, idx), ...resetParent(content, parent), ...parent.childNodes.slice(idx + 1)];\n        return this;\n    }\n    get outerHTML() {\n        return this.toString();\n    }\n    /**\n     * Trim element from right (in block) after seeing pattern in a TextNode.\n     * @param  {RegExp} pattern pattern to find\n     * @return {HTMLElement}    reference to current node\n     */\n    trimRight(pattern) {\n        for (let i = 0; i < this.childNodes.length; i++) {\n            const childNode = this.childNodes[i];\n            if (childNode.nodeType === type_1.default.ELEMENT_NODE) {\n                childNode.trimRight(pattern);\n            }\n            else {\n                const index = childNode.rawText.search(pattern);\n                if (index > -1) {\n                    childNode.rawText = childNode.rawText.substr(0, index);\n                    // trim all following nodes.\n                    this.childNodes.length = i + 1;\n                }\n            }\n        }\n        return this;\n    }\n    /**\n     * Get DOM structure\n     * @return {string} structure\n     */\n    get structure() {\n        const res = [];\n        let indention = 0;\n        function write(str) {\n            res.push('  '.repeat(indention) + str);\n        }\n        function dfs(node) {\n            const idStr = node.id ? `#${node.id}` : '';\n            const classStr = node.classList.length ? `.${node.classList.value.join('.')}` : ''; // eslint-disable-line @typescript-eslint/no-unsafe-member-access, @typescript-eslint/no-unsafe-member-access, @typescript-eslint/restrict-template-expressions, @typescript-eslint/no-unsafe-call\n            write(`${node.rawTagName}${idStr}${classStr}`);\n            indention++;\n            node.childNodes.forEach((childNode) => {\n                if (childNode.nodeType === type_1.default.ELEMENT_NODE) {\n                    dfs(childNode);\n                }\n                else if (childNode.nodeType === type_1.default.TEXT_NODE) {\n                    if (!childNode.isWhitespace) {\n                        write('#text');\n                    }\n                }\n            });\n            indention--;\n        }\n        dfs(this);\n        return res.join('\\n');\n    }\n    /**\n     * Remove whitespaces in this sub tree.\n     * @return {HTMLElement} pointer to this\n     */\n    removeWhitespace() {\n        let o = 0;\n        this.childNodes.forEach((node) => {\n            if (node.nodeType === type_1.default.TEXT_NODE) {\n                if (node.isWhitespace) {\n                    return;\n                }\n                node.rawText = node.trimmedRawText;\n            }\n            else if (node.nodeType === type_1.default.ELEMENT_NODE) {\n                node.removeWhitespace();\n            }\n            this.childNodes[o++] = node;\n        });\n        this.childNodes.length = o;\n        // remove whitespace between attributes\n        const attrs = Object.keys(this.rawAttributes)\n            .map((key) => {\n            const val = this.rawAttributes[key];\n            return `${key}=${JSON.stringify(val)}`;\n        })\n            .join(' ');\n        this.rawAttrs = attrs;\n        delete this._rawAttrs;\n        return this;\n    }\n    /**\n     * Query CSS selector to find matching nodes.\n     * @param  {string}         selector Simplified CSS selector\n     * @return {HTMLElement[]}  matching elements\n     */\n    querySelectorAll(selector) {\n        return (0, css_select_1.selectAll)(selector, this, {\n            xmlMode: true,\n            adapter: matcher_1.default,\n        });\n    }\n    /**\n     * Query CSS Selector to find matching node.\n     * @param  {string}         selector Simplified CSS selector\n     * @return {(HTMLElement|null)}    matching node\n     */\n    querySelector(selector) {\n        return (0, css_select_1.selectOne)(selector, this, {\n            xmlMode: true,\n            adapter: matcher_1.default,\n        });\n    }\n    /**\n     * find elements by their tagName\n     * @param {string} tagName the tagName of the elements to select\n     */\n    getElementsByTagName(tagName) {\n        const upperCasedTagName = tagName.toUpperCase();\n        const re = [];\n        const stack = [];\n        let currentNodeReference = this;\n        let index = 0;\n        // index turns to undefined once the stack is empty and the first condition occurs\n        // which happens once all relevant children are searched through\n        while (index !== undefined) {\n            let child;\n            // make it work with sparse arrays\n            do {\n                child = currentNodeReference.childNodes[index++];\n            } while (index < currentNodeReference.childNodes.length && child === undefined);\n            // if the child does not exist we move on with the last provided index (which belongs to the parentNode)\n            if (child === undefined) {\n                currentNodeReference = currentNodeReference.parentNode;\n                index = stack.pop();\n                continue;\n            }\n            if (child.nodeType === type_1.default.ELEMENT_NODE) {\n                // https://developer.mozilla.org/en-US/docs/Web/API/Element/getElementsByTagName#syntax\n                if (tagName === '*' || child.tagName === upperCasedTagName)\n                    re.push(child);\n                // if children are existing push the current status to the stack and keep searching for elements in the level below\n                if (child.childNodes.length > 0) {\n                    stack.push(index);\n                    currentNodeReference = child;\n                    index = 0;\n                }\n            }\n        }\n        return re;\n    }\n    /**\n     * find element by it's id\n     * @param {string} id the id of the element to select\n     * @returns {HTMLElement | null} the element with the given id or null if not found\n     */\n    getElementById(id) {\n        const stack = [];\n        let currentNodeReference = this;\n        let index = 0;\n        // index turns to undefined once the stack is empty and the first condition occurs\n        // which happens once all relevant children are searched through\n        while (index !== undefined) {\n            let child;\n            // make it work with sparse arrays\n            do {\n                child = currentNodeReference.childNodes[index++];\n            } while (index < currentNodeReference.childNodes.length && child === undefined);\n            // if the child does not exist we move on with the last provided index (which belongs to the parentNode)\n            if (child === undefined) {\n                currentNodeReference = currentNodeReference.parentNode;\n                index = stack.pop();\n                continue;\n            }\n            if (child.nodeType === type_1.default.ELEMENT_NODE) {\n                if (child.id === id) {\n                    return child;\n                }\n                // if children are existing push the current status to the stack and keep searching for elements in the level below\n                if (child.childNodes.length > 0) {\n                    stack.push(index);\n                    currentNodeReference = child;\n                    index = 0;\n                }\n            }\n        }\n        return null;\n    }\n    /**\n     * traverses the Element and its parents (heading toward the document root) until it finds a node that matches the provided selector string. Will return itself or the matching ancestor. If no such element exists, it returns null.\n     * @param selector a DOMString containing a selector list\n     * @returns {HTMLElement | null} the element with the given id or null if not found\n     */\n    closest(selector) {\n        const mapChild = new Map();\n        let el = this;\n        let old = null;\n        function findOne(test, elems) {\n            let elem = null;\n            for (let i = 0, l = elems.length; i < l && !elem; i++) {\n                const el = elems[i];\n                if (test(el)) {\n                    elem = el;\n                }\n                else {\n                    const child = mapChild.get(el);\n                    if (child) {\n                        elem = findOne(test, [child]);\n                    }\n                }\n            }\n            return elem;\n        }\n        while (el) {\n            mapChild.set(el, old);\n            old = el;\n            el = el.parentNode;\n        }\n        el = this;\n        while (el) {\n            const e = (0, css_select_1.selectOne)(selector, el, {\n                xmlMode: true,\n                adapter: Object.assign(Object.assign({}, matcher_1.default), { getChildren(node) {\n                        const child = mapChild.get(node);\n                        return child && [child];\n                    },\n                    getSiblings(node) {\n                        return [node];\n                    },\n                    findOne,\n                    findAll() {\n                        return [];\n                    } }),\n            });\n            if (e) {\n                return e;\n            }\n            el = el.parentNode;\n        }\n        return null;\n    }\n    /**\n     * Append a child node to childNodes\n     * @param  {Node} node node to append\n     * @return {Node}      node appended\n     */\n    appendChild(node) {\n        this.append(node);\n        return node;\n    }\n    /**\n     * Get attributes\n     * @access private\n     * @return {Object} parsed and unescaped attributes\n     */\n    get attrs() {\n        if (this._attrs) {\n            return this._attrs;\n        }\n        this._attrs = {};\n        const attrs = this.rawAttributes;\n        for (const key in attrs) {\n            const val = attrs[key] || '';\n            this._attrs[key.toLowerCase()] = decode(val);\n        }\n        return this._attrs;\n    }\n    get attributes() {\n        const ret_attrs = {};\n        const attrs = this.rawAttributes;\n        for (const key in attrs) {\n            const val = attrs[key] || '';\n            ret_attrs[key] = decode(val);\n        }\n        return ret_attrs;\n    }\n    /**\n     * Get escaped (as-is) attributes\n     * @return {Object} parsed attributes\n     */\n    get rawAttributes() {\n        if (this._rawAttrs) {\n            return this._rawAttrs;\n        }\n        const attrs = {};\n        if (this.rawAttrs) {\n            const re = /([a-zA-Z()[\\]#@$.?:][a-zA-Z0-9-._:()[\\]#]*)(?:\\s*=\\s*((?:'[^']*')|(?:\"[^\"]*\")|\\S+))?/g;\n            let match;\n            while ((match = re.exec(this.rawAttrs))) {\n                const key = match[1];\n                let val = match[2] || null;\n                if (val && (val[0] === `'` || val[0] === `\"`))\n                    val = val.slice(1, val.length - 1);\n                attrs[key] = attrs[key] || val;\n            }\n        }\n        this._rawAttrs = attrs;\n        return attrs;\n    }\n    removeAttribute(key) {\n        const attrs = this.rawAttributes;\n        delete attrs[key];\n        // Update this.attribute\n        if (this._attrs) {\n            delete this._attrs[key];\n        }\n        // Update rawString\n        this.rawAttrs = Object.keys(attrs)\n            .map((name) => {\n            const val = this.quoteAttribute(attrs[name]);\n            if (val === 'null' || val === '\"\"')\n                return name;\n            return `${name}=${val}`;\n        })\n            .join(' ');\n        // Update this.id\n        if (key === 'id') {\n            this.id = '';\n        }\n        return this;\n    }\n    hasAttribute(key) {\n        return key.toLowerCase() in this.attrs;\n    }\n    /**\n     * Get an attribute\n     * @return {string | undefined} value of the attribute; or undefined if not exist\n     */\n    getAttribute(key) {\n        return this.attrs[key.toLowerCase()];\n    }\n    /**\n     * Set an attribute value to the HTMLElement\n     * @param {string} key The attribute name\n     * @param {string} value The value to set, or null / undefined to remove an attribute\n     */\n    setAttribute(key, value) {\n        if (arguments.length < 2) {\n            throw new Error(\"Failed to execute 'setAttribute' on 'Element'\");\n        }\n        const k2 = key.toLowerCase();\n        const attrs = this.rawAttributes;\n        for (const k in attrs) {\n            if (k.toLowerCase() === k2) {\n                key = k;\n                break;\n            }\n        }\n        attrs[key] = String(value);\n        // update this.attrs\n        if (this._attrs) {\n            this._attrs[k2] = decode(attrs[key]);\n        }\n        // Update rawString\n        this.rawAttrs = Object.keys(attrs)\n            .map((name) => {\n            const val = this.quoteAttribute(attrs[name]);\n            if (val === 'null' || val === '\"\"')\n                return name;\n            return `${name}=${val}`;\n        })\n            .join(' ');\n        // Update this.id\n        if (key === 'id') {\n            this.id = value;\n        }\n        return this;\n    }\n    /**\n     * Replace all the attributes of the HTMLElement by the provided attributes\n     * @param {Attributes} attributes the new attribute set\n     */\n    setAttributes(attributes) {\n        // Invalidate current this.attributes\n        if (this._attrs) {\n            delete this._attrs;\n        }\n        // Invalidate current this.rawAttributes\n        if (this._rawAttrs) {\n            delete this._rawAttrs;\n        }\n        // Update rawString\n        this.rawAttrs = Object.keys(attributes)\n            .map((name) => {\n            const val = attributes[name];\n            if (val === 'null' || val === '\"\"')\n                return name;\n            return `${name}=${this.quoteAttribute(String(val))}`;\n        })\n            .join(' ');\n        return this;\n    }\n    insertAdjacentHTML(where, html) {\n        if (arguments.length < 2) {\n            throw new Error('2 arguments required');\n        }\n        const p = parse(html, this._parseOptions);\n        if (where === 'afterend') {\n            this.after(...p.childNodes);\n        }\n        else if (where === 'afterbegin') {\n            this.prepend(...p.childNodes);\n        }\n        else if (where === 'beforeend') {\n            this.append(...p.childNodes);\n        }\n        else if (where === 'beforebegin') {\n            this.before(...p.childNodes);\n        }\n        else {\n            throw new Error(`The value provided ('${where}') is not one of 'beforebegin', 'afterbegin', 'beforeend', or 'afterend'`);\n        }\n        return this;\n    }\n    /** Prepend nodes or strings to this node's children. */\n    prepend(...insertable) {\n        const nodes = resolveInsertable(insertable);\n        resetParent(nodes, this);\n        this.childNodes.unshift(...nodes);\n    }\n    /** Append nodes or strings to this node's children. */\n    append(...insertable) {\n        const nodes = resolveInsertable(insertable);\n        resetParent(nodes, this);\n        this.childNodes.push(...nodes);\n    }\n    /** Insert nodes or strings before this node. */\n    before(...insertable) {\n        const nodes = resolveInsertable(insertable);\n        const siblings = this.parentNode.childNodes;\n        resetParent(nodes, this.parentNode);\n        siblings.splice(siblings.indexOf(this), 0, ...nodes);\n    }\n    /** Insert nodes or strings after this node. */\n    after(...insertable) {\n        const nodes = resolveInsertable(insertable);\n        const siblings = this.parentNode.childNodes;\n        resetParent(nodes, this.parentNode);\n        siblings.splice(siblings.indexOf(this) + 1, 0, ...nodes);\n    }\n    get nextSibling() {\n        if (this.parentNode) {\n            const children = this.parentNode.childNodes;\n            let i = 0;\n            while (i < children.length) {\n                const child = children[i++];\n                if (this === child)\n                    return children[i] || null;\n            }\n            return null;\n        }\n    }\n    get nextElementSibling() {\n        if (this.parentNode) {\n            const children = this.parentNode.childNodes;\n            let i = 0;\n            let find = false;\n            while (i < children.length) {\n                const child = children[i++];\n                if (find) {\n                    if (child instanceof HTMLElement) {\n                        return child || null;\n                    }\n                }\n                else if (this === child) {\n                    find = true;\n                }\n            }\n            return null;\n        }\n    }\n    get previousSibling() {\n        if (this.parentNode) {\n            const children = this.parentNode.childNodes;\n            let i = children.length;\n            while (i > 0) {\n                const child = children[--i];\n                if (this === child)\n                    return children[i - 1] || null;\n            }\n            return null;\n        }\n    }\n    get previousElementSibling() {\n        if (this.parentNode) {\n            const children = this.parentNode.childNodes;\n            let i = children.length;\n            let find = false;\n            while (i > 0) {\n                const child = children[--i];\n                if (find) {\n                    if (child instanceof HTMLElement) {\n                        return child || null;\n                    }\n                }\n                else if (this === child) {\n                    find = true;\n                }\n            }\n            return null;\n        }\n    }\n    /** Get all childNodes of type {@link HTMLElement}. */\n    get children() {\n        const children = [];\n        for (const childNode of this.childNodes) {\n            if (childNode instanceof HTMLElement) {\n                children.push(childNode);\n            }\n        }\n        return children;\n    }\n    /**\n     * Get the first child node.\n     * @return The first child or undefined if none exists.\n     */\n    get firstChild() {\n        return this.childNodes[0];\n    }\n    /**\n     * Get the first child node of type {@link HTMLElement}.\n     * @return The first child element or undefined if none exists.\n     */\n    get firstElementChild() {\n        return this.children[0];\n    }\n    /**\n     * Get the last child node.\n     * @return The last child or undefined if none exists.\n     */\n    get lastChild() {\n        return (0, back_1.default)(this.childNodes);\n    }\n    /**\n     * Get the last child node of type {@link HTMLElement}.\n     * @return The last child element or undefined if none exists.\n     */\n    get lastElementChild() {\n        return this.children[this.children.length - 1];\n    }\n    get childElementCount() {\n        return this.children.length;\n    }\n    get classNames() {\n        return this.classList.toString();\n    }\n    /** Clone this Node */\n    clone() {\n        return parse(this.toString(), this._parseOptions).firstChild;\n    }\n}\nexports.default = HTMLElement;\n// #xB7 | [#xC0-#xD6] | [#xD8-#xF6] | [#xF8-#x37D] | [#x37F-#x1FFF] | [#x200C-#x200D] | [#x203F-#x2040] | [#x2070-#x218F] | [#x2C00-#x2FEF] | [#x3001-#xD7FF] | [#xF900-#xFDCF] | [#xFDF0-#xFFFD] | [#x10000-#xEFFFF]\n// https://html.spec.whatwg.org/multipage/custom-elements.html#valid-custom-element-name\nconst kMarkupPattern = /<!--[\\s\\S]*?-->|<(\\/?)([a-zA-Z][-.:0-9_a-zA-Z@\\xB7\\xC0-\\xD6\\xD8-\\xF6\\u00F8-\\u03A1\\u03A3-\\u03D9\\u03DB-\\u03EF\\u03F7-\\u03FF\\u0400-\\u04FF\\u0500-\\u052F\\u1D00-\\u1D2B\\u1D6B-\\u1D77\\u1D79-\\u1D9A\\u1E00-\\u1E9B\\u1F00-\\u1F15\\u1F18-\\u1F1D\\u1F20-\\u1F45\\u1F48-\\u1F4D\\u1F50-\\u1F57\\u1F59\\u1F5B\\u1F5D\\u1F5F-\\u1F7D\\u1F80-\\u1FB4\\u1FB6-\\u1FBC\\u1FBE\\u1FC2-\\u1FC4\\u1FC6-\\u1FCC\\u1FD0-\\u1FD3\\u1FD6-\\u1FDB\\u1FE0-\\u1FEC\\u1FF2-\\u1FF4\\u1FF6-\\u1FFC\\u2126\\u212A-\\u212B\\u2132\\u214E\\u2160-\\u2188\\u2C60-\\u2C7F\\uA722-\\uA787\\uA78B-\\uA78E\\uA790-\\uA7AD\\uA7B0-\\uA7B7\\uA7F7-\\uA7FF\\uAB30-\\uAB5A\\uAB5C-\\uAB5F\\uAB64-\\uAB65\\uFB00-\\uFB06\\uFB13-\\uFB17\\uFF21-\\uFF3A\\uFF41-\\uFF5A\\x37F-\\u1FFF\\u200C-\\u200D\\u203F-\\u2040\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD]*)((?:\\s+[^>]*?(?:(?:'[^']*')|(?:\"[^\"]*\"))?)*)\\s*(\\/?)>/gu;\n// const kMarkupPattern = /<!--[\\s\\S]*?-->|<(\\/?)([a-zA-Z][-.:0-9_a-zA-Z]*)((?:\\s+[^>]*?(?:(?:'[^']*')|(?:\"[^\"]*\"))?)*)\\s*(\\/?)>/g;\nconst kAttributePattern = /(?:^|\\s)(id|class)\\s*=\\s*((?:'[^']*')|(?:\"[^\"]*\")|\\S+)/gi;\nconst kElementsClosedByOpening = {\n    li: { li: true, LI: true },\n    LI: { li: true, LI: true },\n    p: { p: true, div: true, P: true, DIV: true },\n    P: { p: true, div: true, P: true, DIV: true },\n    b: { div: true, DIV: true },\n    B: { div: true, DIV: true },\n    td: { td: true, th: true, TD: true, TH: true },\n    TD: { td: true, th: true, TD: true, TH: true },\n    th: { td: true, th: true, TD: true, TH: true },\n    TH: { td: true, th: true, TD: true, TH: true },\n    h1: { h1: true, H1: true },\n    H1: { h1: true, H1: true },\n    h2: { h2: true, H2: true },\n    H2: { h2: true, H2: true },\n    h3: { h3: true, H3: true },\n    H3: { h3: true, H3: true },\n    h4: { h4: true, H4: true },\n    H4: { h4: true, H4: true },\n    h5: { h5: true, H5: true },\n    H5: { h5: true, H5: true },\n    h6: { h6: true, H6: true },\n    H6: { h6: true, H6: true },\n};\nconst kElementsClosedByClosing = {\n    li: { ul: true, ol: true, UL: true, OL: true },\n    LI: { ul: true, ol: true, UL: true, OL: true },\n    a: { div: true, DIV: true },\n    A: { div: true, DIV: true },\n    b: { div: true, DIV: true },\n    B: { div: true, DIV: true },\n    i: { div: true, DIV: true },\n    I: { div: true, DIV: true },\n    p: { div: true, DIV: true },\n    P: { div: true, DIV: true },\n    td: { tr: true, table: true, TR: true, TABLE: true },\n    TD: { tr: true, table: true, TR: true, TABLE: true },\n    th: { tr: true, table: true, TR: true, TABLE: true },\n    TH: { tr: true, table: true, TR: true, TABLE: true },\n};\nconst frameflag = 'documentfragmentcontainer';\n/**\n * Parses HTML and returns a root element\n * Parse a chuck of HTML source.\n * @param  {string} data      html\n * @return {HTMLElement}      root element\n */\nfunction base_parse(data, options = {}) {\n    var _a, _b;\n    const voidTag = new void_tag_1.default((_a = options === null || options === void 0 ? void 0 : options.voidTag) === null || _a === void 0 ? void 0 : _a.closingSlash, (_b = options === null || options === void 0 ? void 0 : options.voidTag) === null || _b === void 0 ? void 0 : _b.tags);\n    const elements = options.blockTextElements || {\n        script: true,\n        noscript: true,\n        style: true,\n        pre: true,\n    };\n    const element_names = Object.keys(elements);\n    const kBlockTextElements = element_names.map((it) => new RegExp(`^${it}$`, 'i'));\n    const kIgnoreElements = element_names.filter((it) => Boolean(elements[it])).map((it) => new RegExp(`^${it}$`, 'i'));\n    function element_should_be_ignore(tag) {\n        return kIgnoreElements.some((it) => it.test(tag));\n    }\n    function is_block_text_element(tag) {\n        return kBlockTextElements.some((it) => it.test(tag));\n    }\n    const createRange = (startPos, endPos) => [startPos - frameFlagOffset, endPos - frameFlagOffset];\n    const root = new HTMLElement(null, {}, '', null, [0, data.length], voidTag, options);\n    let currentParent = root;\n    const stack = [root];\n    let lastTextPos = -1;\n    let noNestedTagIndex = undefined;\n    let match;\n    // https://github.com/taoqf/node-html-parser/issues/38\n    data = `<${frameflag}>${data}</${frameflag}>`;\n    const { lowerCaseTagName, fixNestedATags } = options;\n    const dataEndPos = data.length - (frameflag.length + 2);\n    const frameFlagOffset = frameflag.length + 2;\n    while ((match = kMarkupPattern.exec(data))) {\n        // Note: Object destructuring here consistently tests as higher performance than array destructuring\n        // eslint-disable-next-line prefer-const\n        let { 0: matchText, 1: leadingSlash, 2: tagName, 3: attributes, 4: closingSlash } = match;\n        const matchLength = matchText.length;\n        const tagStartPos = kMarkupPattern.lastIndex - matchLength;\n        const tagEndPos = kMarkupPattern.lastIndex;\n        // Add TextNode if content\n        if (lastTextPos > -1) {\n            if (lastTextPos + matchLength < tagEndPos) {\n                const text = data.substring(lastTextPos, tagStartPos);\n                currentParent.appendChild(new text_1.default(text, currentParent, createRange(lastTextPos, tagStartPos)));\n            }\n        }\n        lastTextPos = kMarkupPattern.lastIndex;\n        // https://github.com/taoqf/node-html-parser/issues/38\n        // Skip frameflag node\n        if (tagName === frameflag)\n            continue;\n        // Handle comments\n        if (matchText[1] === '!') {\n            if (options.comment) {\n                // Only keep what is in between <!-- and -->\n                const text = data.substring(tagStartPos + 4, tagEndPos - 3);\n                currentParent.appendChild(new comment_1.default(text, currentParent, createRange(tagStartPos, tagEndPos)));\n            }\n            continue;\n        }\n        /* -- Handle tag matching -- */\n        // Fix tag casing if necessary\n        if (lowerCaseTagName)\n            tagName = tagName.toLowerCase();\n        // Handle opening tags (ie. <this> not </that>)\n        if (!leadingSlash) {\n            /* Populate attributes */\n            const attrs = {};\n            for (let attMatch; (attMatch = kAttributePattern.exec(attributes));) {\n                const { 1: key, 2: val } = attMatch;\n                const isQuoted = val[0] === `'` || val[0] === `\"`;\n                attrs[key.toLowerCase()] = isQuoted ? val.slice(1, val.length - 1) : val;\n            }\n            const parentTagName = currentParent.rawTagName;\n            if (!closingSlash && kElementsClosedByOpening[parentTagName]) {\n                if (kElementsClosedByOpening[parentTagName][tagName]) {\n                    stack.pop();\n                    currentParent = (0, back_1.default)(stack);\n                }\n            }\n            // Prevent nested A tags by terminating the last A and starting a new one : see issue #144\n            if (fixNestedATags && (tagName === 'a' || tagName === 'A')) {\n                if (noNestedTagIndex !== undefined) {\n                    stack.splice(noNestedTagIndex);\n                    currentParent = (0, back_1.default)(stack);\n                }\n                noNestedTagIndex = stack.length;\n            }\n            const tagEndPos = kMarkupPattern.lastIndex;\n            const tagStartPos = tagEndPos - matchLength;\n            currentParent = currentParent.appendChild(\n            // Initialize range (end position updated later for closed tags)\n            new HTMLElement(tagName, attrs, attributes.slice(1), null, createRange(tagStartPos, tagEndPos), voidTag, options));\n            stack.push(currentParent);\n            if (is_block_text_element(tagName)) {\n                // Find closing tag\n                const closeMarkup = `</${tagName}>`;\n                const closeIndex = lowerCaseTagName\n                    ? data.toLocaleLowerCase().indexOf(closeMarkup, kMarkupPattern.lastIndex)\n                    : data.indexOf(closeMarkup, kMarkupPattern.lastIndex);\n                const textEndPos = closeIndex === -1 ? dataEndPos : closeIndex;\n                if (element_should_be_ignore(tagName)) {\n                    const text = data.substring(tagEndPos, textEndPos);\n                    if (text.length > 0 && /\\S/.test(text)) {\n                        currentParent.appendChild(new text_1.default(text, currentParent, createRange(tagEndPos, textEndPos)));\n                    }\n                }\n                if (closeIndex === -1) {\n                    lastTextPos = kMarkupPattern.lastIndex = data.length + 1;\n                }\n                else {\n                    lastTextPos = kMarkupPattern.lastIndex = closeIndex + closeMarkup.length;\n                    // Cause to be treated as self-closing, because no close found\n                    leadingSlash = '/';\n                }\n            }\n        }\n        // Handle closing tags or self-closed elements (ie </tag> or <br>)\n        if (leadingSlash || closingSlash || voidTag.isVoidElement(tagName)) {\n            while (true) {\n                if (noNestedTagIndex != null && (tagName === 'a' || tagName === 'A'))\n                    noNestedTagIndex = undefined;\n                if (currentParent.rawTagName === tagName) {\n                    // Update range end for closed tag\n                    currentParent.range[1] = createRange(-1, Math.max(lastTextPos, tagEndPos))[1];\n                    stack.pop();\n                    currentParent = (0, back_1.default)(stack);\n                    break;\n                }\n                else {\n                    const parentTagName = currentParent.tagName;\n                    // Trying to close current tag, and move on\n                    if (kElementsClosedByClosing[parentTagName]) {\n                        if (kElementsClosedByClosing[parentTagName][tagName]) {\n                            stack.pop();\n                            currentParent = (0, back_1.default)(stack);\n                            continue;\n                        }\n                    }\n                    // Use aggressive strategy to handle unmatching markups.\n                    break;\n                }\n            }\n        }\n    }\n    return stack;\n}\nexports.base_parse = base_parse;\n/**\n * Parses HTML and returns a root element\n * Parse a chuck of HTML source.\n */\nfunction parse(data, options = {}) {\n    const stack = base_parse(data, options);\n    const [root] = stack;\n    while (stack.length > 1) {\n        // Handle each error elements.\n        const last = stack.pop();\n        const oneBefore = (0, back_1.default)(stack);\n        if (last.parentNode && last.parentNode.parentNode) {\n            if (last.parentNode === oneBefore && last.tagName === oneBefore.tagName) {\n                // Pair error case <h3> <h3> handle : Fixes to <h3> </h3>\n                // this is wrong, becouse this will put the H3 outside the current right position which should be inside the current Html Element, see issue 152 for more info\n                if (options.parseNoneClosedTags !== true) {\n                    oneBefore.removeChild(last);\n                    last.childNodes.forEach((child) => {\n                        oneBefore.parentNode.appendChild(child);\n                    });\n                    stack.pop();\n                }\n            }\n            else {\n                // Single error  <div> <h3> </div> handle: Just removes <h3>\n                // Why remove? this is already a HtmlElement and the missing <H3> is already added in this case. see issue 152 for more info\n                // eslint-disable-next-line no-lonely-if\n                if (options.parseNoneClosedTags !== true) {\n                    oneBefore.removeChild(last);\n                    last.childNodes.forEach((child) => {\n                        oneBefore.appendChild(child);\n                    });\n                }\n            }\n        }\n        else {\n            // If it's final element just skip.\n        }\n    }\n    // response.childNodes.forEach((node) => {\n    // \tif (node instanceof HTMLElement) {\n    // \t\tnode.parentNode = null;\n    // \t}\n    // });\n    return root;\n}\nexports.parse = parse;\n/**\n * Resolves a list of {@link NodeInsertable} to a list of nodes,\n * and removes nodes from any potential parent.\n */\nfunction resolveInsertable(insertable) {\n    return insertable.map((val) => {\n        if (typeof val === 'string') {\n            return new text_1.default(val);\n        }\n        val.remove();\n        return val;\n    });\n}\nfunction resetParent(nodes, parent) {\n    return nodes.map((node) => {\n        node.parentNode = parent;\n        return node;\n    });\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}