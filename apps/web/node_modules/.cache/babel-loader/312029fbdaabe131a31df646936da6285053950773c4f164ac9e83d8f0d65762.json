{"ast":null,"code":"var fs = require('fs');\nvar path = require('path');\nvar isAllowedResource = require('./is-allowed-resource');\nvar matchDataUri = require('./match-data-uri');\nvar rebaseLocalMap = require('./rebase-local-map');\nvar rebaseRemoteMap = require('./rebase-remote-map');\nvar Token = require('../tokenizer/token');\nvar hasProtocol = require('../utils/has-protocol');\nvar isDataUriResource = require('../utils/is-data-uri-resource');\nvar isRemoteResource = require('../utils/is-remote-resource');\nvar MAP_MARKER_PATTERN = /^\\/\\*# sourceMappingURL=(\\S+) \\*\\/$/;\nfunction applySourceMaps(tokens, context, callback) {\n  var applyContext = {\n    callback: callback,\n    fetch: context.options.fetch,\n    index: 0,\n    inline: context.options.inline,\n    inlineRequest: context.options.inlineRequest,\n    inlineTimeout: context.options.inlineTimeout,\n    inputSourceMapTracker: context.inputSourceMapTracker,\n    localOnly: context.localOnly,\n    processedTokens: [],\n    rebaseTo: context.options.rebaseTo,\n    sourceTokens: tokens,\n    warnings: context.warnings\n  };\n  return context.options.sourceMap && tokens.length > 0 ? doApplySourceMaps(applyContext) : callback(tokens);\n}\nfunction doApplySourceMaps(applyContext) {\n  var singleSourceTokens = [];\n  var lastSource = findTokenSource(applyContext.sourceTokens[0]);\n  var source;\n  var token;\n  var l;\n  for (l = applyContext.sourceTokens.length; applyContext.index < l; applyContext.index++) {\n    token = applyContext.sourceTokens[applyContext.index];\n    source = findTokenSource(token);\n    if (source != lastSource) {\n      singleSourceTokens = [];\n      lastSource = source;\n    }\n    singleSourceTokens.push(token);\n    applyContext.processedTokens.push(token);\n    if (token[0] == Token.COMMENT && MAP_MARKER_PATTERN.test(token[1])) {\n      return fetchAndApplySourceMap(token[1], source, singleSourceTokens, applyContext);\n    }\n  }\n  return applyContext.callback(applyContext.processedTokens);\n}\nfunction findTokenSource(token) {\n  var scope;\n  var metadata;\n  if (token[0] == Token.AT_RULE || token[0] == Token.COMMENT) {\n    metadata = token[2][0];\n  } else {\n    scope = token[1][0];\n    metadata = scope[2][0];\n  }\n  return metadata[2];\n}\nfunction fetchAndApplySourceMap(sourceMapComment, source, singleSourceTokens, applyContext) {\n  return extractInputSourceMapFrom(sourceMapComment, applyContext, function (inputSourceMap) {\n    if (inputSourceMap) {\n      applyContext.inputSourceMapTracker.track(source, inputSourceMap);\n      applySourceMapRecursively(singleSourceTokens, applyContext.inputSourceMapTracker);\n    }\n    applyContext.index++;\n    return doApplySourceMaps(applyContext);\n  });\n}\nfunction extractInputSourceMapFrom(sourceMapComment, applyContext, whenSourceMapReady) {\n  var uri = MAP_MARKER_PATTERN.exec(sourceMapComment)[1];\n  var absoluteUri;\n  var sourceMap;\n  var rebasedMap;\n  if (isDataUriResource(uri)) {\n    sourceMap = extractInputSourceMapFromDataUri(uri);\n    return whenSourceMapReady(sourceMap);\n  } else if (isRemoteResource(uri)) {\n    return loadInputSourceMapFromRemoteUri(uri, applyContext, function (sourceMap) {\n      var parsedMap;\n      if (sourceMap) {\n        parsedMap = JSON.parse(sourceMap);\n        rebasedMap = rebaseRemoteMap(parsedMap, uri);\n        whenSourceMapReady(rebasedMap);\n      } else {\n        whenSourceMapReady(null);\n      }\n    });\n  } else {\n    // at this point `uri` is already rebased, see lib/reader/rebase.js#rebaseSourceMapComment\n    // it is rebased to be consistent with rebasing other URIs\n    // however here we need to resolve it back to read it from disk\n    absoluteUri = path.resolve(applyContext.rebaseTo, uri);\n    sourceMap = loadInputSourceMapFromLocalUri(absoluteUri, applyContext);\n    if (sourceMap) {\n      rebasedMap = rebaseLocalMap(sourceMap, absoluteUri, applyContext.rebaseTo);\n      return whenSourceMapReady(rebasedMap);\n    } else {\n      return whenSourceMapReady(null);\n    }\n  }\n}\nfunction extractInputSourceMapFromDataUri(uri) {\n  var dataUriMatch = matchDataUri(uri);\n  var charset = dataUriMatch[2] ? dataUriMatch[2].split(/[=;]/)[2] : 'us-ascii';\n  var encoding = dataUriMatch[3] ? dataUriMatch[3].split(';')[1] : 'utf8';\n  var data = encoding == 'utf8' ? global.unescape(dataUriMatch[4]) : dataUriMatch[4];\n  var buffer = new Buffer(data, encoding);\n  buffer.charset = charset;\n  return JSON.parse(buffer.toString());\n}\nfunction loadInputSourceMapFromRemoteUri(uri, applyContext, whenLoaded) {\n  var isAllowed = isAllowedResource(uri, true, applyContext.inline);\n  var isRuntimeResource = !hasProtocol(uri);\n  if (applyContext.localOnly) {\n    applyContext.warnings.push('Cannot fetch remote resource from \"' + uri + '\" as no callback given.');\n    return whenLoaded(null);\n  } else if (isRuntimeResource) {\n    applyContext.warnings.push('Cannot fetch \"' + uri + '\" as no protocol given.');\n    return whenLoaded(null);\n  } else if (!isAllowed) {\n    applyContext.warnings.push('Cannot fetch \"' + uri + '\" as resource is not allowed.');\n    return whenLoaded(null);\n  }\n  applyContext.fetch(uri, applyContext.inlineRequest, applyContext.inlineTimeout, function (error, body) {\n    if (error) {\n      applyContext.warnings.push('Missing source map at \"' + uri + '\" - ' + error);\n      return whenLoaded(null);\n    }\n    whenLoaded(body);\n  });\n}\nfunction loadInputSourceMapFromLocalUri(uri, applyContext) {\n  var isAllowed = isAllowedResource(uri, false, applyContext.inline);\n  var sourceMap;\n  if (!fs.existsSync(uri) || !fs.statSync(uri).isFile()) {\n    applyContext.warnings.push('Ignoring local source map at \"' + uri + '\" as resource is missing.');\n    return null;\n  } else if (!isAllowed) {\n    applyContext.warnings.push('Cannot fetch \"' + uri + '\" as resource is not allowed.');\n    return null;\n  }\n  sourceMap = fs.readFileSync(uri, 'utf-8');\n  return JSON.parse(sourceMap);\n}\nfunction applySourceMapRecursively(tokens, inputSourceMapTracker) {\n  var token;\n  var i, l;\n  for (i = 0, l = tokens.length; i < l; i++) {\n    token = tokens[i];\n    switch (token[0]) {\n      case Token.AT_RULE:\n        applySourceMapTo(token, inputSourceMapTracker);\n        break;\n      case Token.AT_RULE_BLOCK:\n        applySourceMapRecursively(token[1], inputSourceMapTracker);\n        applySourceMapRecursively(token[2], inputSourceMapTracker);\n        break;\n      case Token.AT_RULE_BLOCK_SCOPE:\n        applySourceMapTo(token, inputSourceMapTracker);\n        break;\n      case Token.NESTED_BLOCK:\n        applySourceMapRecursively(token[1], inputSourceMapTracker);\n        applySourceMapRecursively(token[2], inputSourceMapTracker);\n        break;\n      case Token.NESTED_BLOCK_SCOPE:\n        applySourceMapTo(token, inputSourceMapTracker);\n        break;\n      case Token.COMMENT:\n        applySourceMapTo(token, inputSourceMapTracker);\n        break;\n      case Token.PROPERTY:\n        applySourceMapRecursively(token, inputSourceMapTracker);\n        break;\n      case Token.PROPERTY_BLOCK:\n        applySourceMapRecursively(token[1], inputSourceMapTracker);\n        break;\n      case Token.PROPERTY_NAME:\n        applySourceMapTo(token, inputSourceMapTracker);\n        break;\n      case Token.PROPERTY_VALUE:\n        applySourceMapTo(token, inputSourceMapTracker);\n        break;\n      case Token.RULE:\n        applySourceMapRecursively(token[1], inputSourceMapTracker);\n        applySourceMapRecursively(token[2], inputSourceMapTracker);\n        break;\n      case Token.RULE_SCOPE:\n        applySourceMapTo(token, inputSourceMapTracker);\n    }\n  }\n  return tokens;\n}\nfunction applySourceMapTo(token, inputSourceMapTracker) {\n  var value = token[1];\n  var metadata = token[2];\n  var newMetadata = [];\n  var i, l;\n  for (i = 0, l = metadata.length; i < l; i++) {\n    newMetadata.push(inputSourceMapTracker.originalPositionFor(metadata[i], value.length));\n  }\n  token[2] = newMetadata;\n}\nmodule.exports = applySourceMaps;","map":{"version":3,"names":["fs","require","path","isAllowedResource","matchDataUri","rebaseLocalMap","rebaseRemoteMap","Token","hasProtocol","isDataUriResource","isRemoteResource","MAP_MARKER_PATTERN","applySourceMaps","tokens","context","callback","applyContext","fetch","options","index","inline","inlineRequest","inlineTimeout","inputSourceMapTracker","localOnly","processedTokens","rebaseTo","sourceTokens","warnings","sourceMap","length","doApplySourceMaps","singleSourceTokens","lastSource","findTokenSource","source","token","l","push","COMMENT","test","fetchAndApplySourceMap","scope","metadata","AT_RULE","sourceMapComment","extractInputSourceMapFrom","inputSourceMap","track","applySourceMapRecursively","whenSourceMapReady","uri","exec","absoluteUri","rebasedMap","extractInputSourceMapFromDataUri","loadInputSourceMapFromRemoteUri","parsedMap","JSON","parse","resolve","loadInputSourceMapFromLocalUri","dataUriMatch","charset","split","encoding","data","global","unescape","buffer","Buffer","toString","whenLoaded","isAllowed","isRuntimeResource","error","body","existsSync","statSync","isFile","readFileSync","i","applySourceMapTo","AT_RULE_BLOCK","AT_RULE_BLOCK_SCOPE","NESTED_BLOCK","NESTED_BLOCK_SCOPE","PROPERTY","PROPERTY_BLOCK","PROPERTY_NAME","PROPERTY_VALUE","RULE","RULE_SCOPE","value","newMetadata","originalPositionFor","module","exports"],"sources":["F:/landinghub-iconic/node_modules/.pnpm/clean-css@4.2.4/node_modules/clean-css/lib/reader/apply-source-maps.js"],"sourcesContent":["var fs = require('fs');\nvar path = require('path');\n\nvar isAllowedResource = require('./is-allowed-resource');\nvar matchDataUri = require('./match-data-uri');\nvar rebaseLocalMap = require('./rebase-local-map');\nvar rebaseRemoteMap = require('./rebase-remote-map');\n\nvar Token = require('../tokenizer/token');\nvar hasProtocol = require('../utils/has-protocol');\nvar isDataUriResource = require('../utils/is-data-uri-resource');\nvar isRemoteResource = require('../utils/is-remote-resource');\n\nvar MAP_MARKER_PATTERN = /^\\/\\*# sourceMappingURL=(\\S+) \\*\\/$/;\n\nfunction applySourceMaps(tokens, context, callback) {\n  var applyContext = {\n    callback: callback,\n    fetch: context.options.fetch,\n    index: 0,\n    inline: context.options.inline,\n    inlineRequest: context.options.inlineRequest,\n    inlineTimeout: context.options.inlineTimeout,\n    inputSourceMapTracker: context.inputSourceMapTracker,\n    localOnly: context.localOnly,\n    processedTokens: [],\n    rebaseTo: context.options.rebaseTo,\n    sourceTokens: tokens,\n    warnings: context.warnings\n  };\n\n  return context.options.sourceMap && tokens.length > 0 ?\n    doApplySourceMaps(applyContext) :\n    callback(tokens);\n}\n\nfunction doApplySourceMaps(applyContext) {\n  var singleSourceTokens = [];\n  var lastSource = findTokenSource(applyContext.sourceTokens[0]);\n  var source;\n  var token;\n  var l;\n\n  for (l = applyContext.sourceTokens.length; applyContext.index < l; applyContext.index++) {\n    token = applyContext.sourceTokens[applyContext.index];\n    source = findTokenSource(token);\n\n    if (source != lastSource) {\n      singleSourceTokens = [];\n      lastSource = source;\n    }\n\n    singleSourceTokens.push(token);\n    applyContext.processedTokens.push(token);\n\n    if (token[0] == Token.COMMENT && MAP_MARKER_PATTERN.test(token[1])) {\n      return fetchAndApplySourceMap(token[1], source, singleSourceTokens, applyContext);\n    }\n  }\n\n  return applyContext.callback(applyContext.processedTokens);\n}\n\nfunction findTokenSource(token) {\n  var scope;\n  var metadata;\n\n  if (token[0] == Token.AT_RULE || token[0] == Token.COMMENT) {\n    metadata = token[2][0];\n  } else {\n    scope = token[1][0];\n    metadata = scope[2][0];\n  }\n\n  return metadata[2];\n}\n\nfunction fetchAndApplySourceMap(sourceMapComment, source, singleSourceTokens, applyContext) {\n  return extractInputSourceMapFrom(sourceMapComment, applyContext, function (inputSourceMap) {\n    if (inputSourceMap) {\n      applyContext.inputSourceMapTracker.track(source, inputSourceMap);\n      applySourceMapRecursively(singleSourceTokens, applyContext.inputSourceMapTracker);\n    }\n\n    applyContext.index++;\n    return doApplySourceMaps(applyContext);\n  });\n}\n\nfunction extractInputSourceMapFrom(sourceMapComment, applyContext, whenSourceMapReady) {\n  var uri = MAP_MARKER_PATTERN.exec(sourceMapComment)[1];\n  var absoluteUri;\n  var sourceMap;\n  var rebasedMap;\n\n  if (isDataUriResource(uri)) {\n    sourceMap = extractInputSourceMapFromDataUri(uri);\n    return whenSourceMapReady(sourceMap);\n  } else if (isRemoteResource(uri)) {\n    return loadInputSourceMapFromRemoteUri(uri, applyContext, function (sourceMap) {\n      var parsedMap;\n\n      if (sourceMap) {\n        parsedMap = JSON.parse(sourceMap);\n        rebasedMap = rebaseRemoteMap(parsedMap, uri);\n        whenSourceMapReady(rebasedMap);\n      } else {\n        whenSourceMapReady(null);\n      }\n    });\n  } else {\n    // at this point `uri` is already rebased, see lib/reader/rebase.js#rebaseSourceMapComment\n    // it is rebased to be consistent with rebasing other URIs\n    // however here we need to resolve it back to read it from disk\n    absoluteUri = path.resolve(applyContext.rebaseTo, uri);\n    sourceMap = loadInputSourceMapFromLocalUri(absoluteUri, applyContext);\n\n    if (sourceMap) {\n      rebasedMap = rebaseLocalMap(sourceMap, absoluteUri, applyContext.rebaseTo);\n      return whenSourceMapReady(rebasedMap);\n    } else {\n      return whenSourceMapReady(null);\n    }\n  }\n}\n\nfunction extractInputSourceMapFromDataUri(uri) {\n  var dataUriMatch = matchDataUri(uri);\n  var charset = dataUriMatch[2] ? dataUriMatch[2].split(/[=;]/)[2] : 'us-ascii';\n  var encoding = dataUriMatch[3] ? dataUriMatch[3].split(';')[1] : 'utf8';\n  var data = encoding == 'utf8' ? global.unescape(dataUriMatch[4]) : dataUriMatch[4];\n\n  var buffer = new Buffer(data, encoding);\n  buffer.charset = charset;\n\n  return JSON.parse(buffer.toString());\n}\n\nfunction loadInputSourceMapFromRemoteUri(uri, applyContext, whenLoaded) {\n  var isAllowed = isAllowedResource(uri, true, applyContext.inline);\n  var isRuntimeResource = !hasProtocol(uri);\n\n  if (applyContext.localOnly) {\n    applyContext.warnings.push('Cannot fetch remote resource from \"' + uri + '\" as no callback given.');\n    return whenLoaded(null);\n  } else if (isRuntimeResource) {\n    applyContext.warnings.push('Cannot fetch \"' + uri + '\" as no protocol given.');\n    return whenLoaded(null);\n  } else if (!isAllowed) {\n    applyContext.warnings.push('Cannot fetch \"' + uri + '\" as resource is not allowed.');\n    return whenLoaded(null);\n  }\n\n  applyContext.fetch(uri, applyContext.inlineRequest, applyContext.inlineTimeout, function (error, body) {\n    if (error) {\n      applyContext.warnings.push('Missing source map at \"' + uri + '\" - ' + error);\n      return whenLoaded(null);\n    }\n\n    whenLoaded(body);\n  });\n}\n\nfunction loadInputSourceMapFromLocalUri(uri, applyContext) {\n  var isAllowed = isAllowedResource(uri, false, applyContext.inline);\n  var sourceMap;\n\n  if (!fs.existsSync(uri) || !fs.statSync(uri).isFile()) {\n    applyContext.warnings.push('Ignoring local source map at \"' + uri + '\" as resource is missing.');\n    return null;\n  } else if (!isAllowed) {\n    applyContext.warnings.push('Cannot fetch \"' + uri + '\" as resource is not allowed.');\n    return null;\n  }\n\n  sourceMap = fs.readFileSync(uri, 'utf-8');\n  return JSON.parse(sourceMap);\n}\n\nfunction applySourceMapRecursively(tokens, inputSourceMapTracker) {\n  var token;\n  var i, l;\n\n  for (i = 0, l = tokens.length; i < l; i++) {\n    token = tokens[i];\n\n    switch (token[0]) {\n      case Token.AT_RULE:\n        applySourceMapTo(token, inputSourceMapTracker);\n        break;\n      case Token.AT_RULE_BLOCK:\n        applySourceMapRecursively(token[1], inputSourceMapTracker);\n        applySourceMapRecursively(token[2], inputSourceMapTracker);\n        break;\n      case Token.AT_RULE_BLOCK_SCOPE:\n        applySourceMapTo(token, inputSourceMapTracker);\n        break;\n      case Token.NESTED_BLOCK:\n        applySourceMapRecursively(token[1], inputSourceMapTracker);\n        applySourceMapRecursively(token[2], inputSourceMapTracker);\n        break;\n      case Token.NESTED_BLOCK_SCOPE:\n        applySourceMapTo(token, inputSourceMapTracker);\n        break;\n      case Token.COMMENT:\n        applySourceMapTo(token, inputSourceMapTracker);\n        break;\n      case Token.PROPERTY:\n        applySourceMapRecursively(token, inputSourceMapTracker);\n        break;\n      case Token.PROPERTY_BLOCK:\n        applySourceMapRecursively(token[1], inputSourceMapTracker);\n        break;\n      case Token.PROPERTY_NAME:\n        applySourceMapTo(token, inputSourceMapTracker);\n        break;\n      case Token.PROPERTY_VALUE:\n        applySourceMapTo(token, inputSourceMapTracker);\n        break;\n      case Token.RULE:\n        applySourceMapRecursively(token[1], inputSourceMapTracker);\n        applySourceMapRecursively(token[2], inputSourceMapTracker);\n        break;\n      case Token.RULE_SCOPE:\n        applySourceMapTo(token, inputSourceMapTracker);\n    }\n  }\n\n  return tokens;\n}\n\nfunction applySourceMapTo(token, inputSourceMapTracker) {\n  var value = token[1];\n  var metadata = token[2];\n  var newMetadata = [];\n  var i, l;\n\n  for (i = 0, l = metadata.length; i < l; i++) {\n    newMetadata.push(inputSourceMapTracker.originalPositionFor(metadata[i], value.length));\n  }\n\n  token[2] = newMetadata;\n}\n\nmodule.exports = applySourceMaps;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}