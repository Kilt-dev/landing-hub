{"ast":null,"code":"// src/trace-mapping.ts\nimport { encode, decode } from \"@jridgewell/sourcemap-codec\";\n\n// src/resolve.ts\nimport resolveUri from \"@jridgewell/resolve-uri\";\n\n// src/strip-filename.ts\nfunction stripFilename(path) {\n  if (!path) return \"\";\n  const index = path.lastIndexOf(\"/\");\n  return path.slice(0, index + 1);\n}\n\n// src/resolve.ts\nfunction resolver(mapUrl, sourceRoot) {\n  const from = stripFilename(mapUrl);\n  const prefix = sourceRoot ? sourceRoot + \"/\" : \"\";\n  return source => resolveUri(prefix + (source || \"\"), from);\n}\n\n// src/sourcemap-segment.ts\nvar COLUMN = 0;\nvar SOURCES_INDEX = 1;\nvar SOURCE_LINE = 2;\nvar SOURCE_COLUMN = 3;\nvar NAMES_INDEX = 4;\nvar REV_GENERATED_LINE = 1;\nvar REV_GENERATED_COLUMN = 2;\n\n// src/sort.ts\nfunction maybeSort(mappings, owned) {\n  const unsortedIndex = nextUnsortedSegmentLine(mappings, 0);\n  if (unsortedIndex === mappings.length) return mappings;\n  if (!owned) mappings = mappings.slice();\n  for (let i = unsortedIndex; i < mappings.length; i = nextUnsortedSegmentLine(mappings, i + 1)) {\n    mappings[i] = sortSegments(mappings[i], owned);\n  }\n  return mappings;\n}\nfunction nextUnsortedSegmentLine(mappings, start) {\n  for (let i = start; i < mappings.length; i++) {\n    if (!isSorted(mappings[i])) return i;\n  }\n  return mappings.length;\n}\nfunction isSorted(line) {\n  for (let j = 1; j < line.length; j++) {\n    if (line[j][COLUMN] < line[j - 1][COLUMN]) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction sortSegments(line, owned) {\n  if (!owned) line = line.slice();\n  return line.sort(sortComparator);\n}\nfunction sortComparator(a, b) {\n  return a[COLUMN] - b[COLUMN];\n}\n\n// src/by-source.ts\nfunction buildBySources(decoded, memos) {\n  const sources = memos.map(() => []);\n  for (let i = 0; i < decoded.length; i++) {\n    const line = decoded[i];\n    for (let j = 0; j < line.length; j++) {\n      const seg = line[j];\n      if (seg.length === 1) continue;\n      const sourceIndex2 = seg[SOURCES_INDEX];\n      const sourceLine = seg[SOURCE_LINE];\n      const sourceColumn = seg[SOURCE_COLUMN];\n      const source = sources[sourceIndex2];\n      const segs = source[sourceLine] || (source[sourceLine] = []);\n      segs.push([sourceColumn, i, seg[COLUMN]]);\n    }\n  }\n  for (let i = 0; i < sources.length; i++) {\n    const source = sources[i];\n    for (let j = 0; j < source.length; j++) {\n      const line = source[j];\n      if (line) line.sort(sortComparator);\n    }\n  }\n  return sources;\n}\n\n// src/binary-search.ts\nvar found = false;\nfunction binarySearch(haystack, needle, low, high) {\n  while (low <= high) {\n    const mid = low + (high - low >> 1);\n    const cmp = haystack[mid][COLUMN] - needle;\n    if (cmp === 0) {\n      found = true;\n      return mid;\n    }\n    if (cmp < 0) {\n      low = mid + 1;\n    } else {\n      high = mid - 1;\n    }\n  }\n  found = false;\n  return low - 1;\n}\nfunction upperBound(haystack, needle, index) {\n  for (let i = index + 1; i < haystack.length; index = i++) {\n    if (haystack[i][COLUMN] !== needle) break;\n  }\n  return index;\n}\nfunction lowerBound(haystack, needle, index) {\n  for (let i = index - 1; i >= 0; index = i--) {\n    if (haystack[i][COLUMN] !== needle) break;\n  }\n  return index;\n}\nfunction memoizedState() {\n  return {\n    lastKey: -1,\n    lastNeedle: -1,\n    lastIndex: -1\n  };\n}\nfunction memoizedBinarySearch(haystack, needle, state, key) {\n  const {\n    lastKey,\n    lastNeedle,\n    lastIndex\n  } = state;\n  let low = 0;\n  let high = haystack.length - 1;\n  if (key === lastKey) {\n    if (needle === lastNeedle) {\n      found = lastIndex !== -1 && haystack[lastIndex][COLUMN] === needle;\n      return lastIndex;\n    }\n    if (needle >= lastNeedle) {\n      low = lastIndex === -1 ? 0 : lastIndex;\n    } else {\n      high = lastIndex;\n    }\n  }\n  state.lastKey = key;\n  state.lastNeedle = needle;\n  return state.lastIndex = binarySearch(haystack, needle, low, high);\n}\n\n// src/types.ts\nfunction parse(map) {\n  return typeof map === \"string\" ? JSON.parse(map) : map;\n}\n\n// src/flatten-map.ts\nvar FlattenMap = function (map, mapUrl) {\n  const parsed = parse(map);\n  if (!(\"sections\" in parsed)) {\n    return new TraceMap(parsed, mapUrl);\n  }\n  const mappings = [];\n  const sources = [];\n  const sourcesContent = [];\n  const names = [];\n  const ignoreList = [];\n  recurse(parsed, mapUrl, mappings, sources, sourcesContent, names, ignoreList, 0, 0, Infinity, Infinity);\n  const joined = {\n    version: 3,\n    file: parsed.file,\n    names,\n    sources,\n    sourcesContent,\n    mappings,\n    ignoreList\n  };\n  return presortedDecodedMap(joined);\n};\nfunction recurse(input, mapUrl, mappings, sources, sourcesContent, names, ignoreList, lineOffset, columnOffset, stopLine, stopColumn) {\n  const {\n    sections\n  } = input;\n  for (let i = 0; i < sections.length; i++) {\n    const {\n      map,\n      offset\n    } = sections[i];\n    let sl = stopLine;\n    let sc = stopColumn;\n    if (i + 1 < sections.length) {\n      const nextOffset = sections[i + 1].offset;\n      sl = Math.min(stopLine, lineOffset + nextOffset.line);\n      if (sl === stopLine) {\n        sc = Math.min(stopColumn, columnOffset + nextOffset.column);\n      } else if (sl < stopLine) {\n        sc = columnOffset + nextOffset.column;\n      }\n    }\n    addSection(map, mapUrl, mappings, sources, sourcesContent, names, ignoreList, lineOffset + offset.line, columnOffset + offset.column, sl, sc);\n  }\n}\nfunction addSection(input, mapUrl, mappings, sources, sourcesContent, names, ignoreList, lineOffset, columnOffset, stopLine, stopColumn) {\n  const parsed = parse(input);\n  if (\"sections\" in parsed) return recurse(...arguments);\n  const map = new TraceMap(parsed, mapUrl);\n  const sourcesOffset = sources.length;\n  const namesOffset = names.length;\n  const decoded = decodedMappings(map);\n  const {\n    resolvedSources,\n    sourcesContent: contents,\n    ignoreList: ignores\n  } = map;\n  append(sources, resolvedSources);\n  append(names, map.names);\n  if (contents) append(sourcesContent, contents);else for (let i = 0; i < resolvedSources.length; i++) sourcesContent.push(null);\n  if (ignores) for (let i = 0; i < ignores.length; i++) ignoreList.push(ignores[i] + sourcesOffset);\n  for (let i = 0; i < decoded.length; i++) {\n    const lineI = lineOffset + i;\n    if (lineI > stopLine) return;\n    const out = getLine(mappings, lineI);\n    const cOffset = i === 0 ? columnOffset : 0;\n    const line = decoded[i];\n    for (let j = 0; j < line.length; j++) {\n      const seg = line[j];\n      const column = cOffset + seg[COLUMN];\n      if (lineI === stopLine && column >= stopColumn) return;\n      if (seg.length === 1) {\n        out.push([column]);\n        continue;\n      }\n      const sourcesIndex = sourcesOffset + seg[SOURCES_INDEX];\n      const sourceLine = seg[SOURCE_LINE];\n      const sourceColumn = seg[SOURCE_COLUMN];\n      out.push(seg.length === 4 ? [column, sourcesIndex, sourceLine, sourceColumn] : [column, sourcesIndex, sourceLine, sourceColumn, namesOffset + seg[NAMES_INDEX]]);\n    }\n  }\n}\nfunction append(arr, other) {\n  for (let i = 0; i < other.length; i++) arr.push(other[i]);\n}\nfunction getLine(arr, index) {\n  for (let i = arr.length; i <= index; i++) arr[i] = [];\n  return arr[index];\n}\n\n// src/trace-mapping.ts\nvar LINE_GTR_ZERO = \"`line` must be greater than 0 (lines start at line 1)\";\nvar COL_GTR_EQ_ZERO = \"`column` must be greater than or equal to 0 (columns start at column 0)\";\nvar LEAST_UPPER_BOUND = -1;\nvar GREATEST_LOWER_BOUND = 1;\nvar TraceMap = class {\n  constructor(map, mapUrl) {\n    const isString = typeof map === \"string\";\n    if (!isString && map._decodedMemo) return map;\n    const parsed = parse(map);\n    const {\n      version,\n      file,\n      names,\n      sourceRoot,\n      sources,\n      sourcesContent\n    } = parsed;\n    this.version = version;\n    this.file = file;\n    this.names = names || [];\n    this.sourceRoot = sourceRoot;\n    this.sources = sources;\n    this.sourcesContent = sourcesContent;\n    this.ignoreList = parsed.ignoreList || parsed.x_google_ignoreList || void 0;\n    const resolve = resolver(mapUrl, sourceRoot);\n    this.resolvedSources = sources.map(resolve);\n    const {\n      mappings\n    } = parsed;\n    if (typeof mappings === \"string\") {\n      this._encoded = mappings;\n      this._decoded = void 0;\n    } else if (Array.isArray(mappings)) {\n      this._encoded = void 0;\n      this._decoded = maybeSort(mappings, isString);\n    } else if (parsed.sections) {\n      throw new Error(`TraceMap passed sectioned source map, please use FlattenMap export instead`);\n    } else {\n      throw new Error(`invalid source map: ${JSON.stringify(parsed)}`);\n    }\n    this._decodedMemo = memoizedState();\n    this._bySources = void 0;\n    this._bySourceMemos = void 0;\n  }\n};\nfunction cast(map) {\n  return map;\n}\nfunction encodedMappings(map) {\n  var _a, _b;\n  return (_b = (_a = cast(map))._encoded) != null ? _b : _a._encoded = encode(cast(map)._decoded);\n}\nfunction decodedMappings(map) {\n  var _a;\n  return (_a = cast(map))._decoded || (_a._decoded = decode(cast(map)._encoded));\n}\nfunction traceSegment(map, line, column) {\n  const decoded = decodedMappings(map);\n  if (line >= decoded.length) return null;\n  const segments = decoded[line];\n  const index = traceSegmentInternal(segments, cast(map)._decodedMemo, line, column, GREATEST_LOWER_BOUND);\n  return index === -1 ? null : segments[index];\n}\nfunction originalPositionFor(map, needle) {\n  let {\n    line,\n    column,\n    bias\n  } = needle;\n  line--;\n  if (line < 0) throw new Error(LINE_GTR_ZERO);\n  if (column < 0) throw new Error(COL_GTR_EQ_ZERO);\n  const decoded = decodedMappings(map);\n  if (line >= decoded.length) return OMapping(null, null, null, null);\n  const segments = decoded[line];\n  const index = traceSegmentInternal(segments, cast(map)._decodedMemo, line, column, bias || GREATEST_LOWER_BOUND);\n  if (index === -1) return OMapping(null, null, null, null);\n  const segment = segments[index];\n  if (segment.length === 1) return OMapping(null, null, null, null);\n  const {\n    names,\n    resolvedSources\n  } = map;\n  return OMapping(resolvedSources[segment[SOURCES_INDEX]], segment[SOURCE_LINE] + 1, segment[SOURCE_COLUMN], segment.length === 5 ? names[segment[NAMES_INDEX]] : null);\n}\nfunction generatedPositionFor(map, needle) {\n  const {\n    source,\n    line,\n    column,\n    bias\n  } = needle;\n  return generatedPosition(map, source, line, column, bias || GREATEST_LOWER_BOUND, false);\n}\nfunction allGeneratedPositionsFor(map, needle) {\n  const {\n    source,\n    line,\n    column,\n    bias\n  } = needle;\n  return generatedPosition(map, source, line, column, bias || LEAST_UPPER_BOUND, true);\n}\nfunction eachMapping(map, cb) {\n  const decoded = decodedMappings(map);\n  const {\n    names,\n    resolvedSources\n  } = map;\n  for (let i = 0; i < decoded.length; i++) {\n    const line = decoded[i];\n    for (let j = 0; j < line.length; j++) {\n      const seg = line[j];\n      const generatedLine = i + 1;\n      const generatedColumn = seg[0];\n      let source = null;\n      let originalLine = null;\n      let originalColumn = null;\n      let name = null;\n      if (seg.length !== 1) {\n        source = resolvedSources[seg[1]];\n        originalLine = seg[2] + 1;\n        originalColumn = seg[3];\n      }\n      if (seg.length === 5) name = names[seg[4]];\n      cb({\n        generatedLine,\n        generatedColumn,\n        source,\n        originalLine,\n        originalColumn,\n        name\n      });\n    }\n  }\n}\nfunction sourceIndex(map, source) {\n  const {\n    sources,\n    resolvedSources\n  } = map;\n  let index = sources.indexOf(source);\n  if (index === -1) index = resolvedSources.indexOf(source);\n  return index;\n}\nfunction sourceContentFor(map, source) {\n  const {\n    sourcesContent\n  } = map;\n  if (sourcesContent == null) return null;\n  const index = sourceIndex(map, source);\n  return index === -1 ? null : sourcesContent[index];\n}\nfunction isIgnored(map, source) {\n  const {\n    ignoreList\n  } = map;\n  if (ignoreList == null) return false;\n  const index = sourceIndex(map, source);\n  return index === -1 ? false : ignoreList.includes(index);\n}\nfunction presortedDecodedMap(map, mapUrl) {\n  const tracer = new TraceMap(clone(map, []), mapUrl);\n  cast(tracer)._decoded = map.mappings;\n  return tracer;\n}\nfunction decodedMap(map) {\n  return clone(map, decodedMappings(map));\n}\nfunction encodedMap(map) {\n  return clone(map, encodedMappings(map));\n}\nfunction clone(map, mappings) {\n  return {\n    version: map.version,\n    file: map.file,\n    names: map.names,\n    sourceRoot: map.sourceRoot,\n    sources: map.sources,\n    sourcesContent: map.sourcesContent,\n    mappings,\n    ignoreList: map.ignoreList || map.x_google_ignoreList\n  };\n}\nfunction OMapping(source, line, column, name) {\n  return {\n    source,\n    line,\n    column,\n    name\n  };\n}\nfunction GMapping(line, column) {\n  return {\n    line,\n    column\n  };\n}\nfunction traceSegmentInternal(segments, memo, line, column, bias) {\n  let index = memoizedBinarySearch(segments, column, memo, line);\n  if (found) {\n    index = (bias === LEAST_UPPER_BOUND ? upperBound : lowerBound)(segments, column, index);\n  } else if (bias === LEAST_UPPER_BOUND) index++;\n  if (index === -1 || index === segments.length) return -1;\n  return index;\n}\nfunction sliceGeneratedPositions(segments, memo, line, column, bias) {\n  let min = traceSegmentInternal(segments, memo, line, column, GREATEST_LOWER_BOUND);\n  if (!found && bias === LEAST_UPPER_BOUND) min++;\n  if (min === -1 || min === segments.length) return [];\n  const matchedColumn = found ? column : segments[min][COLUMN];\n  if (!found) min = lowerBound(segments, matchedColumn, min);\n  const max = upperBound(segments, matchedColumn, min);\n  const result = [];\n  for (; min <= max; min++) {\n    const segment = segments[min];\n    result.push(GMapping(segment[REV_GENERATED_LINE] + 1, segment[REV_GENERATED_COLUMN]));\n  }\n  return result;\n}\nfunction generatedPosition(map, source, line, column, bias, all) {\n  var _a, _b;\n  line--;\n  if (line < 0) throw new Error(LINE_GTR_ZERO);\n  if (column < 0) throw new Error(COL_GTR_EQ_ZERO);\n  const {\n    sources,\n    resolvedSources\n  } = map;\n  let sourceIndex2 = sources.indexOf(source);\n  if (sourceIndex2 === -1) sourceIndex2 = resolvedSources.indexOf(source);\n  if (sourceIndex2 === -1) return all ? [] : GMapping(null, null);\n  const bySourceMemos = (_a = cast(map))._bySourceMemos || (_a._bySourceMemos = sources.map(memoizedState));\n  const generated = (_b = cast(map))._bySources || (_b._bySources = buildBySources(decodedMappings(map), bySourceMemos));\n  const segments = generated[sourceIndex2][line];\n  if (segments == null) return all ? [] : GMapping(null, null);\n  const memo = bySourceMemos[sourceIndex2];\n  if (all) return sliceGeneratedPositions(segments, memo, line, column, bias);\n  const index = traceSegmentInternal(segments, memo, line, column, bias);\n  if (index === -1) return GMapping(null, null);\n  const segment = segments[index];\n  return GMapping(segment[REV_GENERATED_LINE] + 1, segment[REV_GENERATED_COLUMN]);\n}\nexport { FlattenMap as AnyMap, FlattenMap, GREATEST_LOWER_BOUND, LEAST_UPPER_BOUND, TraceMap, allGeneratedPositionsFor, decodedMap, decodedMappings, eachMapping, encodedMap, encodedMappings, generatedPositionFor, isIgnored, originalPositionFor, presortedDecodedMap, sourceContentFor, traceSegment };","map":{"version":3,"names":["encode","decode","resolveUri","stripFilename","path","index","lastIndexOf","slice","resolver","mapUrl","sourceRoot","from","prefix","source","COLUMN","SOURCES_INDEX","SOURCE_LINE","SOURCE_COLUMN","NAMES_INDEX","REV_GENERATED_LINE","REV_GENERATED_COLUMN","maybeSort","mappings","owned","unsortedIndex","nextUnsortedSegmentLine","length","i","sortSegments","start","isSorted","line","j","sort","sortComparator","a","b","buildBySources","decoded","memos","sources","map","seg","sourceIndex2","sourceLine","sourceColumn","segs","push","found","binarySearch","haystack","needle","low","high","mid","cmp","upperBound","lowerBound","memoizedState","lastKey","lastNeedle","lastIndex","memoizedBinarySearch","state","key","parse","JSON","FlattenMap","parsed","TraceMap","sourcesContent","names","ignoreList","recurse","Infinity","joined","version","file","presortedDecodedMap","input","lineOffset","columnOffset","stopLine","stopColumn","sections","offset","sl","sc","nextOffset","Math","min","column","addSection","arguments","sourcesOffset","namesOffset","decodedMappings","resolvedSources","contents","ignores","append","lineI","out","getLine","cOffset","sourcesIndex","arr","other","LINE_GTR_ZERO","COL_GTR_EQ_ZERO","LEAST_UPPER_BOUND","GREATEST_LOWER_BOUND","constructor","isString","_decodedMemo","x_google_ignoreList","resolve","_encoded","_decoded","Array","isArray","Error","stringify","_bySources","_bySourceMemos","cast","encodedMappings","_a","_b","traceSegment","segments","traceSegmentInternal","originalPositionFor","bias","OMapping","segment","generatedPositionFor","generatedPosition","allGeneratedPositionsFor","eachMapping","cb","generatedLine","generatedColumn","originalLine","originalColumn","name","sourceIndex","indexOf","sourceContentFor","isIgnored","includes","tracer","clone","decodedMap","encodedMap","GMapping","memo","sliceGeneratedPositions","matchedColumn","max","result","all","bySourceMemos","generated"],"sources":["F:\\landinghub-iconic\\node_modules\\.pnpm\\@jridgewell+trace-mapping@0.3.31\\node_modules\\@jridgewell\\trace-mapping\\src\\trace-mapping.ts","F:\\landinghub-iconic\\node_modules\\.pnpm\\@jridgewell+trace-mapping@0.3.31\\node_modules\\@jridgewell\\trace-mapping\\src\\resolve.ts","F:\\landinghub-iconic\\node_modules\\.pnpm\\@jridgewell+trace-mapping@0.3.31\\node_modules\\@jridgewell\\trace-mapping\\src\\strip-filename.ts","F:\\landinghub-iconic\\node_modules\\.pnpm\\@jridgewell+trace-mapping@0.3.31\\node_modules\\@jridgewell\\trace-mapping\\src\\sourcemap-segment.ts","F:\\landinghub-iconic\\node_modules\\.pnpm\\@jridgewell+trace-mapping@0.3.31\\node_modules\\@jridgewell\\trace-mapping\\src\\sort.ts","F:\\landinghub-iconic\\node_modules\\.pnpm\\@jridgewell+trace-mapping@0.3.31\\node_modules\\@jridgewell\\trace-mapping\\src\\by-source.ts","F:\\landinghub-iconic\\node_modules\\.pnpm\\@jridgewell+trace-mapping@0.3.31\\node_modules\\@jridgewell\\trace-mapping\\src\\binary-search.ts","F:\\landinghub-iconic\\node_modules\\.pnpm\\@jridgewell+trace-mapping@0.3.31\\node_modules\\@jridgewell\\trace-mapping\\src\\types.ts","F:\\landinghub-iconic\\node_modules\\.pnpm\\@jridgewell+trace-mapping@0.3.31\\node_modules\\@jridgewell\\trace-mapping\\src\\flatten-map.ts"],"sourcesContent":["import { encode, decode } from '@jridgewell/sourcemap-codec';\n\nimport resolver from './resolve';\nimport maybeSort from './sort';\nimport buildBySources from './by-source';\nimport {\n  memoizedState,\n  memoizedBinarySearch,\n  upperBound,\n  lowerBound,\n  found as bsFound,\n} from './binary-search';\nimport {\n  COLUMN,\n  SOURCES_INDEX,\n  SOURCE_LINE,\n  SOURCE_COLUMN,\n  NAMES_INDEX,\n  REV_GENERATED_LINE,\n  REV_GENERATED_COLUMN,\n} from './sourcemap-segment';\nimport { parse } from './types';\n\nimport type { SourceMapSegment, ReverseSegment } from './sourcemap-segment';\nimport type {\n  SourceMapV3,\n  DecodedSourceMap,\n  EncodedSourceMap,\n  InvalidOriginalMapping,\n  OriginalMapping,\n  InvalidGeneratedMapping,\n  GeneratedMapping,\n  SourceMapInput,\n  Needle,\n  SourceNeedle,\n  SourceMap,\n  EachMapping,\n  Bias,\n  XInput,\n  SectionedSourceMap,\n  Ro,\n} from './types';\nimport type { Source } from './by-source';\nimport type { MemoState } from './binary-search';\n\nexport type { SourceMapSegment } from './sourcemap-segment';\nexport type {\n  SourceMap,\n  DecodedSourceMap,\n  EncodedSourceMap,\n  Section,\n  SectionedSourceMap,\n  SourceMapV3,\n  Bias,\n  EachMapping,\n  GeneratedMapping,\n  InvalidGeneratedMapping,\n  InvalidOriginalMapping,\n  Needle,\n  OriginalMapping,\n  OriginalMapping as Mapping,\n  SectionedSourceMapInput,\n  SourceMapInput,\n  SourceNeedle,\n  XInput,\n  EncodedSourceMapXInput,\n  DecodedSourceMapXInput,\n  SectionedSourceMapXInput,\n  SectionXInput,\n} from './types';\n\ninterface PublicMap {\n  _encoded: TraceMap['_encoded'];\n  _decoded: TraceMap['_decoded'];\n  _decodedMemo: TraceMap['_decodedMemo'];\n  _bySources: TraceMap['_bySources'];\n  _bySourceMemos: TraceMap['_bySourceMemos'];\n}\n\nconst LINE_GTR_ZERO = '`line` must be greater than 0 (lines start at line 1)';\nconst COL_GTR_EQ_ZERO = '`column` must be greater than or equal to 0 (columns start at column 0)';\n\nexport const LEAST_UPPER_BOUND = -1;\nexport const GREATEST_LOWER_BOUND = 1;\n\nexport { FlattenMap, FlattenMap as AnyMap } from './flatten-map';\n\nexport class TraceMap implements SourceMap {\n  declare version: SourceMapV3['version'];\n  declare file: SourceMapV3['file'];\n  declare names: SourceMapV3['names'];\n  declare sourceRoot: SourceMapV3['sourceRoot'];\n  declare sources: SourceMapV3['sources'];\n  declare sourcesContent: SourceMapV3['sourcesContent'];\n  declare ignoreList: SourceMapV3['ignoreList'];\n\n  declare resolvedSources: string[];\n  declare private _encoded: string | undefined;\n\n  declare private _decoded: SourceMapSegment[][] | undefined;\n  declare private _decodedMemo: MemoState;\n\n  declare private _bySources: Source[] | undefined;\n  declare private _bySourceMemos: MemoState[] | undefined;\n\n  constructor(map: Ro<SourceMapInput>, mapUrl?: string | null) {\n    const isString = typeof map === 'string';\n    if (!isString && (map as unknown as { _decodedMemo: any })._decodedMemo) return map as TraceMap;\n\n    const parsed = parse(map as Exclude<SourceMapInput, TraceMap>);\n\n    const { version, file, names, sourceRoot, sources, sourcesContent } = parsed;\n    this.version = version;\n    this.file = file;\n    this.names = names || [];\n    this.sourceRoot = sourceRoot;\n    this.sources = sources;\n    this.sourcesContent = sourcesContent;\n    this.ignoreList = parsed.ignoreList || (parsed as XInput).x_google_ignoreList || undefined;\n\n    const resolve = resolver(mapUrl, sourceRoot);\n    this.resolvedSources = sources.map(resolve);\n\n    const { mappings } = parsed;\n    if (typeof mappings === 'string') {\n      this._encoded = mappings;\n      this._decoded = undefined;\n    } else if (Array.isArray(mappings)) {\n      this._encoded = undefined;\n      this._decoded = maybeSort(mappings, isString);\n    } else if ((parsed as unknown as SectionedSourceMap).sections) {\n      throw new Error(`TraceMap passed sectioned source map, please use FlattenMap export instead`);\n    } else {\n      throw new Error(`invalid source map: ${JSON.stringify(parsed)}`);\n    }\n\n    this._decodedMemo = memoizedState();\n    this._bySources = undefined;\n    this._bySourceMemos = undefined;\n  }\n}\n\n/**\n * Typescript doesn't allow friend access to private fields, so this just casts the map into a type\n * with public access modifiers.\n */\nfunction cast(map: unknown): PublicMap {\n  return map as any;\n}\n\n/**\n * Returns the encoded (VLQ string) form of the SourceMap's mappings field.\n */\nexport function encodedMappings(map: TraceMap): EncodedSourceMap['mappings'] {\n  return (cast(map)._encoded ??= encode(cast(map)._decoded!));\n}\n\n/**\n * Returns the decoded (array of lines of segments) form of the SourceMap's mappings field.\n */\nexport function decodedMappings(map: TraceMap): Readonly<DecodedSourceMap['mappings']> {\n  return (cast(map)._decoded ||= decode(cast(map)._encoded!));\n}\n\n/**\n * A low-level API to find the segment associated with a generated line/column (think, from a\n * stack trace). Line and column here are 0-based, unlike `originalPositionFor`.\n */\nexport function traceSegment(\n  map: TraceMap,\n  line: number,\n  column: number,\n): Readonly<SourceMapSegment> | null {\n  const decoded = decodedMappings(map);\n\n  // It's common for parent source maps to have pointers to lines that have no\n  // mapping (like a \"//# sourceMappingURL=\") at the end of the child file.\n  if (line >= decoded.length) return null;\n\n  const segments = decoded[line];\n  const index = traceSegmentInternal(\n    segments,\n    cast(map)._decodedMemo,\n    line,\n    column,\n    GREATEST_LOWER_BOUND,\n  );\n\n  return index === -1 ? null : segments[index];\n}\n\n/**\n * A higher-level API to find the source/line/column associated with a generated line/column\n * (think, from a stack trace). Line is 1-based, but column is 0-based, due to legacy behavior in\n * `source-map` library.\n */\nexport function originalPositionFor(\n  map: TraceMap,\n  needle: Needle,\n): OriginalMapping | InvalidOriginalMapping {\n  let { line, column, bias } = needle;\n  line--;\n  if (line < 0) throw new Error(LINE_GTR_ZERO);\n  if (column < 0) throw new Error(COL_GTR_EQ_ZERO);\n\n  const decoded = decodedMappings(map);\n\n  // It's common for parent source maps to have pointers to lines that have no\n  // mapping (like a \"//# sourceMappingURL=\") at the end of the child file.\n  if (line >= decoded.length) return OMapping(null, null, null, null);\n\n  const segments = decoded[line];\n  const index = traceSegmentInternal(\n    segments,\n    cast(map)._decodedMemo,\n    line,\n    column,\n    bias || GREATEST_LOWER_BOUND,\n  );\n\n  if (index === -1) return OMapping(null, null, null, null);\n\n  const segment = segments[index];\n  if (segment.length === 1) return OMapping(null, null, null, null);\n\n  const { names, resolvedSources } = map;\n  return OMapping(\n    resolvedSources[segment[SOURCES_INDEX]],\n    segment[SOURCE_LINE] + 1,\n    segment[SOURCE_COLUMN],\n    segment.length === 5 ? names[segment[NAMES_INDEX]] : null,\n  );\n}\n\n/**\n * Finds the generated line/column position of the provided source/line/column source position.\n */\nexport function generatedPositionFor(\n  map: TraceMap,\n  needle: SourceNeedle,\n): GeneratedMapping | InvalidGeneratedMapping {\n  const { source, line, column, bias } = needle;\n  return generatedPosition(map, source, line, column, bias || GREATEST_LOWER_BOUND, false);\n}\n\n/**\n * Finds all generated line/column positions of the provided source/line/column source position.\n */\nexport function allGeneratedPositionsFor(map: TraceMap, needle: SourceNeedle): GeneratedMapping[] {\n  const { source, line, column, bias } = needle;\n  // SourceMapConsumer uses LEAST_UPPER_BOUND for some reason, so we follow suit.\n  return generatedPosition(map, source, line, column, bias || LEAST_UPPER_BOUND, true);\n}\n\n/**\n * Iterates each mapping in generated position order.\n */\nexport function eachMapping(map: TraceMap, cb: (mapping: EachMapping) => void): void {\n  const decoded = decodedMappings(map);\n  const { names, resolvedSources } = map;\n\n  for (let i = 0; i < decoded.length; i++) {\n    const line = decoded[i];\n    for (let j = 0; j < line.length; j++) {\n      const seg = line[j];\n\n      const generatedLine = i + 1;\n      const generatedColumn = seg[0];\n      let source = null;\n      let originalLine = null;\n      let originalColumn = null;\n      let name = null;\n      if (seg.length !== 1) {\n        source = resolvedSources[seg[1]];\n        originalLine = seg[2] + 1;\n        originalColumn = seg[3];\n      }\n      if (seg.length === 5) name = names[seg[4]];\n\n      cb({\n        generatedLine,\n        generatedColumn,\n        source,\n        originalLine,\n        originalColumn,\n        name,\n      } as EachMapping);\n    }\n  }\n}\n\nfunction sourceIndex(map: TraceMap, source: string): number {\n  const { sources, resolvedSources } = map;\n  let index = sources.indexOf(source);\n  if (index === -1) index = resolvedSources.indexOf(source);\n  return index;\n}\n\n/**\n * Retrieves the source content for a particular source, if its found. Returns null if not.\n */\nexport function sourceContentFor(map: TraceMap, source: string): string | null {\n  const { sourcesContent } = map;\n  if (sourcesContent == null) return null;\n  const index = sourceIndex(map, source);\n  return index === -1 ? null : sourcesContent[index];\n}\n\n/**\n * Determines if the source is marked to ignore by the source map.\n */\nexport function isIgnored(map: TraceMap, source: string): boolean {\n  const { ignoreList } = map;\n  if (ignoreList == null) return false;\n  const index = sourceIndex(map, source);\n  return index === -1 ? false : ignoreList.includes(index);\n}\n\n/**\n * A helper that skips sorting of the input map's mappings array, which can be expensive for larger\n * maps.\n */\nexport function presortedDecodedMap(map: DecodedSourceMap, mapUrl?: string): TraceMap {\n  const tracer = new TraceMap(clone(map, []), mapUrl);\n  cast(tracer)._decoded = map.mappings;\n  return tracer;\n}\n\n/**\n * Returns a sourcemap object (with decoded mappings) suitable for passing to a library that expects\n * a sourcemap, or to JSON.stringify.\n */\nexport function decodedMap(\n  map: TraceMap,\n): Omit<DecodedSourceMap, 'mappings'> & { mappings: readonly SourceMapSegment[][] } {\n  return clone(map, decodedMappings(map));\n}\n\n/**\n * Returns a sourcemap object (with encoded mappings) suitable for passing to a library that expects\n * a sourcemap, or to JSON.stringify.\n */\nexport function encodedMap(map: TraceMap): EncodedSourceMap {\n  return clone(map, encodedMappings(map));\n}\n\nfunction clone<T extends string | readonly SourceMapSegment[][]>(\n  map: TraceMap | DecodedSourceMap,\n  mappings: T,\n): T extends string ? EncodedSourceMap : DecodedSourceMap {\n  return {\n    version: map.version,\n    file: map.file,\n    names: map.names,\n    sourceRoot: map.sourceRoot,\n    sources: map.sources,\n    sourcesContent: map.sourcesContent,\n    mappings,\n    ignoreList: map.ignoreList || (map as XInput).x_google_ignoreList,\n  } as any;\n}\n\nfunction OMapping(source: null, line: null, column: null, name: null): InvalidOriginalMapping;\nfunction OMapping(\n  source: string,\n  line: number,\n  column: number,\n  name: string | null,\n): OriginalMapping;\nfunction OMapping(\n  source: string | null,\n  line: number | null,\n  column: number | null,\n  name: string | null,\n): OriginalMapping | InvalidOriginalMapping {\n  return { source, line, column, name } as any;\n}\n\nfunction GMapping(line: null, column: null): InvalidGeneratedMapping;\nfunction GMapping(line: number, column: number): GeneratedMapping;\nfunction GMapping(\n  line: number | null,\n  column: number | null,\n): GeneratedMapping | InvalidGeneratedMapping {\n  return { line, column } as any;\n}\n\nfunction traceSegmentInternal(\n  segments: SourceMapSegment[],\n  memo: MemoState,\n  line: number,\n  column: number,\n  bias: Bias,\n): number;\nfunction traceSegmentInternal(\n  segments: ReverseSegment[],\n  memo: MemoState,\n  line: number,\n  column: number,\n  bias: Bias,\n): number;\nfunction traceSegmentInternal(\n  segments: SourceMapSegment[] | ReverseSegment[],\n  memo: MemoState,\n  line: number,\n  column: number,\n  bias: Bias,\n): number {\n  let index = memoizedBinarySearch(segments, column, memo, line);\n  if (bsFound) {\n    index = (bias === LEAST_UPPER_BOUND ? upperBound : lowerBound)(segments, column, index);\n  } else if (bias === LEAST_UPPER_BOUND) index++;\n\n  if (index === -1 || index === segments.length) return -1;\n  return index;\n}\n\nfunction sliceGeneratedPositions(\n  segments: ReverseSegment[],\n  memo: MemoState,\n  line: number,\n  column: number,\n  bias: Bias,\n): GeneratedMapping[] {\n  let min = traceSegmentInternal(segments, memo, line, column, GREATEST_LOWER_BOUND);\n\n  // We ignored the bias when tracing the segment so that we're guarnateed to find the first (in\n  // insertion order) segment that matched. Even if we did respect the bias when tracing, we would\n  // still need to call `lowerBound()` to find the first segment, which is slower than just looking\n  // for the GREATEST_LOWER_BOUND to begin with. The only difference that matters for us is when the\n  // binary search didn't match, in which case GREATEST_LOWER_BOUND just needs to increment to\n  // match LEAST_UPPER_BOUND.\n  if (!bsFound && bias === LEAST_UPPER_BOUND) min++;\n\n  if (min === -1 || min === segments.length) return [];\n\n  // We may have found the segment that started at an earlier column. If this is the case, then we\n  // need to slice all generated segments that match _that_ column, because all such segments span\n  // to our desired column.\n  const matchedColumn = bsFound ? column : segments[min][COLUMN];\n\n  // The binary search is not guaranteed to find the lower bound when a match wasn't found.\n  if (!bsFound) min = lowerBound(segments, matchedColumn, min);\n  const max = upperBound(segments, matchedColumn, min);\n\n  const result = [];\n  for (; min <= max; min++) {\n    const segment = segments[min];\n    result.push(GMapping(segment[REV_GENERATED_LINE] + 1, segment[REV_GENERATED_COLUMN]));\n  }\n  return result;\n}\n\nfunction generatedPosition(\n  map: TraceMap,\n  source: string,\n  line: number,\n  column: number,\n  bias: Bias,\n  all: false,\n): GeneratedMapping | InvalidGeneratedMapping;\nfunction generatedPosition(\n  map: TraceMap,\n  source: string,\n  line: number,\n  column: number,\n  bias: Bias,\n  all: true,\n): GeneratedMapping[];\nfunction generatedPosition(\n  map: TraceMap,\n  source: string,\n  line: number,\n  column: number,\n  bias: Bias,\n  all: boolean,\n): GeneratedMapping | InvalidGeneratedMapping | GeneratedMapping[] {\n  line--;\n  if (line < 0) throw new Error(LINE_GTR_ZERO);\n  if (column < 0) throw new Error(COL_GTR_EQ_ZERO);\n\n  const { sources, resolvedSources } = map;\n  let sourceIndex = sources.indexOf(source);\n  if (sourceIndex === -1) sourceIndex = resolvedSources.indexOf(source);\n  if (sourceIndex === -1) return all ? [] : GMapping(null, null);\n\n  const bySourceMemos = (cast(map)._bySourceMemos ||= sources.map(memoizedState));\n  const generated = (cast(map)._bySources ||= buildBySources(decodedMappings(map), bySourceMemos));\n\n  const segments = generated[sourceIndex][line];\n  if (segments == null) return all ? [] : GMapping(null, null);\n\n  const memo = bySourceMemos[sourceIndex];\n\n  if (all) return sliceGeneratedPositions(segments, memo, line, column, bias);\n\n  const index = traceSegmentInternal(segments, memo, line, column, bias);\n  if (index === -1) return GMapping(null, null);\n\n  const segment = segments[index];\n  return GMapping(segment[REV_GENERATED_LINE] + 1, segment[REV_GENERATED_COLUMN]);\n}\n","import resolveUri from '@jridgewell/resolve-uri';\nimport stripFilename from './strip-filename';\n\ntype Resolve = (source: string | null) => string;\nexport default function resolver(\n  mapUrl: string | null | undefined,\n  sourceRoot: string | undefined,\n): Resolve {\n  const from = stripFilename(mapUrl);\n  // The sourceRoot is always treated as a directory, if it's not empty.\n  // https://github.com/mozilla/source-map/blob/8cb3ee57/lib/util.js#L327\n  // https://github.com/chromium/chromium/blob/da4adbb3/third_party/blink/renderer/devtools/front_end/sdk/SourceMap.js#L400-L401\n  const prefix = sourceRoot ? sourceRoot + '/' : '';\n\n  return (source) => resolveUri(prefix + (source || ''), from);\n}\n","/**\n * Removes everything after the last \"/\", but leaves the slash.\n */\nexport default function stripFilename(path: string | undefined | null): string {\n  if (!path) return '';\n  const index = path.lastIndexOf('/');\n  return path.slice(0, index + 1);\n}\n","type GeneratedColumn = number;\ntype SourcesIndex = number;\ntype SourceLine = number;\ntype SourceColumn = number;\ntype NamesIndex = number;\n\ntype GeneratedLine = number;\n\nexport type SourceMapSegment =\n  | [GeneratedColumn]\n  | [GeneratedColumn, SourcesIndex, SourceLine, SourceColumn]\n  | [GeneratedColumn, SourcesIndex, SourceLine, SourceColumn, NamesIndex];\n\nexport type ReverseSegment = [SourceColumn, GeneratedLine, GeneratedColumn];\n\nexport const COLUMN = 0;\nexport const SOURCES_INDEX = 1;\nexport const SOURCE_LINE = 2;\nexport const SOURCE_COLUMN = 3;\nexport const NAMES_INDEX = 4;\n\nexport const REV_GENERATED_LINE = 1;\nexport const REV_GENERATED_COLUMN = 2;\n","import { COLUMN } from './sourcemap-segment';\n\nimport type { ReverseSegment, SourceMapSegment } from './sourcemap-segment';\n\nexport default function maybeSort(\n  mappings: SourceMapSegment[][],\n  owned: boolean,\n): SourceMapSegment[][] {\n  const unsortedIndex = nextUnsortedSegmentLine(mappings, 0);\n  if (unsortedIndex === mappings.length) return mappings;\n\n  // If we own the array (meaning we parsed it from JSON), then we're free to directly mutate it. If\n  // not, we do not want to modify the consumer's input array.\n  if (!owned) mappings = mappings.slice();\n\n  for (let i = unsortedIndex; i < mappings.length; i = nextUnsortedSegmentLine(mappings, i + 1)) {\n    mappings[i] = sortSegments(mappings[i], owned);\n  }\n  return mappings;\n}\n\nfunction nextUnsortedSegmentLine(mappings: SourceMapSegment[][], start: number): number {\n  for (let i = start; i < mappings.length; i++) {\n    if (!isSorted(mappings[i])) return i;\n  }\n  return mappings.length;\n}\n\nfunction isSorted(line: SourceMapSegment[]): boolean {\n  for (let j = 1; j < line.length; j++) {\n    if (line[j][COLUMN] < line[j - 1][COLUMN]) {\n      return false;\n    }\n  }\n  return true;\n}\n\nfunction sortSegments(line: SourceMapSegment[], owned: boolean): SourceMapSegment[] {\n  if (!owned) line = line.slice();\n  return line.sort(sortComparator);\n}\n\nexport function sortComparator<T extends SourceMapSegment | ReverseSegment>(a: T, b: T): number {\n  return a[COLUMN] - b[COLUMN];\n}\n","import { COLUMN, SOURCES_INDEX, SOURCE_LINE, SOURCE_COLUMN } from './sourcemap-segment';\nimport { sortComparator } from './sort';\n\nimport type { ReverseSegment, SourceMapSegment } from './sourcemap-segment';\n\nexport type Source = ReverseSegment[][];\n\n// Rebuilds the original source files, with mappings that are ordered by source line/column instead\n// of generated line/column.\nexport default function buildBySources(\n  decoded: readonly SourceMapSegment[][],\n  memos: unknown[],\n): Source[] {\n  const sources: Source[] = memos.map(() => []);\n\n  for (let i = 0; i < decoded.length; i++) {\n    const line = decoded[i];\n    for (let j = 0; j < line.length; j++) {\n      const seg = line[j];\n      if (seg.length === 1) continue;\n\n      const sourceIndex = seg[SOURCES_INDEX];\n      const sourceLine = seg[SOURCE_LINE];\n      const sourceColumn = seg[SOURCE_COLUMN];\n\n      const source = sources[sourceIndex];\n      const segs = (source[sourceLine] ||= []);\n      segs.push([sourceColumn, i, seg[COLUMN]]);\n    }\n  }\n\n  for (let i = 0; i < sources.length; i++) {\n    const source = sources[i];\n    for (let j = 0; j < source.length; j++) {\n      const line = source[j];\n      if (line) line.sort(sortComparator);\n    }\n  }\n\n  return sources;\n}\n","import type { SourceMapSegment, ReverseSegment } from './sourcemap-segment';\nimport { COLUMN } from './sourcemap-segment';\n\nexport type MemoState = {\n  lastKey: number;\n  lastNeedle: number;\n  lastIndex: number;\n};\n\nexport let found = false;\n\n/**\n * A binary search implementation that returns the index if a match is found.\n * If no match is found, then the left-index (the index associated with the item that comes just\n * before the desired index) is returned. To maintain proper sort order, a splice would happen at\n * the next index:\n *\n * ```js\n * const array = [1, 3];\n * const needle = 2;\n * const index = binarySearch(array, needle, (item, needle) => item - needle);\n *\n * assert.equal(index, 0);\n * array.splice(index + 1, 0, needle);\n * assert.deepEqual(array, [1, 2, 3]);\n * ```\n */\nexport function binarySearch(\n  haystack: SourceMapSegment[] | ReverseSegment[],\n  needle: number,\n  low: number,\n  high: number,\n): number {\n  while (low <= high) {\n    const mid = low + ((high - low) >> 1);\n    const cmp = haystack[mid][COLUMN] - needle;\n\n    if (cmp === 0) {\n      found = true;\n      return mid;\n    }\n\n    if (cmp < 0) {\n      low = mid + 1;\n    } else {\n      high = mid - 1;\n    }\n  }\n\n  found = false;\n  return low - 1;\n}\n\nexport function upperBound(\n  haystack: SourceMapSegment[] | ReverseSegment[],\n  needle: number,\n  index: number,\n): number {\n  for (let i = index + 1; i < haystack.length; index = i++) {\n    if (haystack[i][COLUMN] !== needle) break;\n  }\n  return index;\n}\n\nexport function lowerBound(\n  haystack: SourceMapSegment[] | ReverseSegment[],\n  needle: number,\n  index: number,\n): number {\n  for (let i = index - 1; i >= 0; index = i--) {\n    if (haystack[i][COLUMN] !== needle) break;\n  }\n  return index;\n}\n\nexport function memoizedState(): MemoState {\n  return {\n    lastKey: -1,\n    lastNeedle: -1,\n    lastIndex: -1,\n  };\n}\n\n/**\n * This overly complicated beast is just to record the last tested line/column and the resulting\n * index, allowing us to skip a few tests if mappings are monotonically increasing.\n */\nexport function memoizedBinarySearch(\n  haystack: SourceMapSegment[] | ReverseSegment[],\n  needle: number,\n  state: MemoState,\n  key: number,\n): number {\n  const { lastKey, lastNeedle, lastIndex } = state;\n\n  let low = 0;\n  let high = haystack.length - 1;\n  if (key === lastKey) {\n    if (needle === lastNeedle) {\n      found = lastIndex !== -1 && haystack[lastIndex][COLUMN] === needle;\n      return lastIndex;\n    }\n\n    if (needle >= lastNeedle) {\n      // lastIndex may be -1 if the previous needle was not found.\n      low = lastIndex === -1 ? 0 : lastIndex;\n    } else {\n      high = lastIndex;\n    }\n  }\n  state.lastKey = key;\n  state.lastNeedle = needle;\n\n  return (state.lastIndex = binarySearch(haystack, needle, low, high));\n}\n","import type { SourceMapSegment } from './sourcemap-segment';\nimport type { GREATEST_LOWER_BOUND, LEAST_UPPER_BOUND, TraceMap } from './trace-mapping';\n\nexport interface SourceMapV3 {\n  file?: string | null;\n  names: string[];\n  sourceRoot?: string;\n  sources: (string | null)[];\n  sourcesContent?: (string | null)[];\n  version: 3;\n  ignoreList?: number[];\n}\n\nexport interface EncodedSourceMap extends SourceMapV3 {\n  mappings: string;\n}\n\nexport interface DecodedSourceMap extends SourceMapV3 {\n  mappings: SourceMapSegment[][];\n}\n\nexport interface Section {\n  offset: { line: number; column: number };\n  map: EncodedSourceMap | DecodedSourceMap | SectionedSourceMap;\n}\n\nexport interface SectionedSourceMap {\n  file?: string | null;\n  sections: Section[];\n  version: 3;\n}\n\nexport type OriginalMapping = {\n  source: string | null;\n  line: number;\n  column: number;\n  name: string | null;\n};\n\nexport type InvalidOriginalMapping = {\n  source: null;\n  line: null;\n  column: null;\n  name: null;\n};\n\nexport type GeneratedMapping = {\n  line: number;\n  column: number;\n};\nexport type InvalidGeneratedMapping = {\n  line: null;\n  column: null;\n};\n\nexport type Bias = typeof GREATEST_LOWER_BOUND | typeof LEAST_UPPER_BOUND;\n\nexport type XInput = { x_google_ignoreList?: SourceMapV3['ignoreList'] };\nexport type EncodedSourceMapXInput = EncodedSourceMap & XInput;\nexport type DecodedSourceMapXInput = DecodedSourceMap & XInput;\nexport type SectionedSourceMapXInput = Omit<SectionedSourceMap, 'sections'> & {\n  sections: SectionXInput[];\n};\nexport type SectionXInput = Omit<Section, 'map'> & {\n  map: SectionedSourceMapInput;\n};\n\nexport type SourceMapInput = string | EncodedSourceMapXInput | DecodedSourceMapXInput | TraceMap;\nexport type SectionedSourceMapInput = SourceMapInput | SectionedSourceMapXInput;\n\nexport type Needle = { line: number; column: number; bias?: Bias };\nexport type SourceNeedle = { source: string; line: number; column: number; bias?: Bias };\n\nexport type EachMapping =\n  | {\n      generatedLine: number;\n      generatedColumn: number;\n      source: null;\n      originalLine: null;\n      originalColumn: null;\n      name: null;\n    }\n  | {\n      generatedLine: number;\n      generatedColumn: number;\n      source: string | null;\n      originalLine: number;\n      originalColumn: number;\n      name: string | null;\n    };\n\nexport abstract class SourceMap {\n  declare version: SourceMapV3['version'];\n  declare file: SourceMapV3['file'];\n  declare names: SourceMapV3['names'];\n  declare sourceRoot: SourceMapV3['sourceRoot'];\n  declare sources: SourceMapV3['sources'];\n  declare sourcesContent: SourceMapV3['sourcesContent'];\n  declare resolvedSources: SourceMapV3['sources'];\n  declare ignoreList: SourceMapV3['ignoreList'];\n}\n\nexport type Ro<T> =\n  T extends Array<infer V>\n    ? V[] | Readonly<V[]> | RoArray<V> | Readonly<RoArray<V>>\n    : T extends object\n      ? T | Readonly<T> | RoObject<T> | Readonly<RoObject<T>>\n      : T;\ntype RoArray<T> = Ro<T>[];\ntype RoObject<T> = { [K in keyof T]: T[K] | Ro<T[K]> };\n\nexport function parse<T>(map: T): Exclude<T, string> {\n  return typeof map === 'string' ? JSON.parse(map) : (map as Exclude<T, string>);\n}\n","import { TraceMap, presortedDecodedMap, decodedMappings } from './trace-mapping';\nimport {\n  COLUMN,\n  SOURCES_INDEX,\n  SOURCE_LINE,\n  SOURCE_COLUMN,\n  NAMES_INDEX,\n} from './sourcemap-segment';\nimport { parse } from './types';\n\nimport type {\n  DecodedSourceMap,\n  DecodedSourceMapXInput,\n  EncodedSourceMapXInput,\n  SectionedSourceMapXInput,\n  SectionedSourceMapInput,\n  SectionXInput,\n  Ro,\n} from './types';\nimport type { SourceMapSegment } from './sourcemap-segment';\n\ntype FlattenMap = {\n  new (map: Ro<SectionedSourceMapInput>, mapUrl?: string | null): TraceMap;\n  (map: Ro<SectionedSourceMapInput>, mapUrl?: string | null): TraceMap;\n};\n\nexport const FlattenMap: FlattenMap = function (map, mapUrl) {\n  const parsed = parse(map as SectionedSourceMapInput);\n\n  if (!('sections' in parsed)) {\n    return new TraceMap(parsed as DecodedSourceMapXInput | EncodedSourceMapXInput, mapUrl);\n  }\n\n  const mappings: SourceMapSegment[][] = [];\n  const sources: string[] = [];\n  const sourcesContent: (string | null)[] = [];\n  const names: string[] = [];\n  const ignoreList: number[] = [];\n\n  recurse(\n    parsed,\n    mapUrl,\n    mappings,\n    sources,\n    sourcesContent,\n    names,\n    ignoreList,\n    0,\n    0,\n    Infinity,\n    Infinity,\n  );\n\n  const joined: DecodedSourceMap = {\n    version: 3,\n    file: parsed.file,\n    names,\n    sources,\n    sourcesContent,\n    mappings,\n    ignoreList,\n  };\n\n  return presortedDecodedMap(joined);\n} as FlattenMap;\n\nfunction recurse(\n  input: SectionedSourceMapXInput,\n  mapUrl: string | null | undefined,\n  mappings: SourceMapSegment[][],\n  sources: string[],\n  sourcesContent: (string | null)[],\n  names: string[],\n  ignoreList: number[],\n  lineOffset: number,\n  columnOffset: number,\n  stopLine: number,\n  stopColumn: number,\n) {\n  const { sections } = input;\n  for (let i = 0; i < sections.length; i++) {\n    const { map, offset } = sections[i];\n\n    let sl = stopLine;\n    let sc = stopColumn;\n    if (i + 1 < sections.length) {\n      const nextOffset = sections[i + 1].offset;\n      sl = Math.min(stopLine, lineOffset + nextOffset.line);\n\n      if (sl === stopLine) {\n        sc = Math.min(stopColumn, columnOffset + nextOffset.column);\n      } else if (sl < stopLine) {\n        sc = columnOffset + nextOffset.column;\n      }\n    }\n\n    addSection(\n      map,\n      mapUrl,\n      mappings,\n      sources,\n      sourcesContent,\n      names,\n      ignoreList,\n      lineOffset + offset.line,\n      columnOffset + offset.column,\n      sl,\n      sc,\n    );\n  }\n}\n\nfunction addSection(\n  input: SectionXInput['map'],\n  mapUrl: string | null | undefined,\n  mappings: SourceMapSegment[][],\n  sources: string[],\n  sourcesContent: (string | null)[],\n  names: string[],\n  ignoreList: number[],\n  lineOffset: number,\n  columnOffset: number,\n  stopLine: number,\n  stopColumn: number,\n) {\n  const parsed = parse(input);\n  if ('sections' in parsed) return recurse(...(arguments as unknown as Parameters<typeof recurse>));\n\n  const map = new TraceMap(parsed, mapUrl);\n  const sourcesOffset = sources.length;\n  const namesOffset = names.length;\n  const decoded = decodedMappings(map);\n  const { resolvedSources, sourcesContent: contents, ignoreList: ignores } = map;\n\n  append(sources, resolvedSources);\n  append(names, map.names);\n\n  if (contents) append(sourcesContent, contents);\n  else for (let i = 0; i < resolvedSources.length; i++) sourcesContent.push(null);\n\n  if (ignores) for (let i = 0; i < ignores.length; i++) ignoreList.push(ignores[i] + sourcesOffset);\n\n  for (let i = 0; i < decoded.length; i++) {\n    const lineI = lineOffset + i;\n\n    // We can only add so many lines before we step into the range that the next section's map\n    // controls. When we get to the last line, then we'll start checking the segments to see if\n    // they've crossed into the column range. But it may not have any columns that overstep, so we\n    // still need to check that we don't overstep lines, too.\n    if (lineI > stopLine) return;\n\n    // The out line may already exist in mappings (if we're continuing the line started by a\n    // previous section). Or, we may have jumped ahead several lines to start this section.\n    const out = getLine(mappings, lineI);\n    // On the 0th loop, the section's column offset shifts us forward. On all other lines (since the\n    // map can be multiple lines), it doesn't.\n    const cOffset = i === 0 ? columnOffset : 0;\n\n    const line = decoded[i];\n    for (let j = 0; j < line.length; j++) {\n      const seg = line[j];\n      const column = cOffset + seg[COLUMN];\n\n      // If this segment steps into the column range that the next section's map controls, we need\n      // to stop early.\n      if (lineI === stopLine && column >= stopColumn) return;\n\n      if (seg.length === 1) {\n        out.push([column]);\n        continue;\n      }\n\n      const sourcesIndex = sourcesOffset + seg[SOURCES_INDEX];\n      const sourceLine = seg[SOURCE_LINE];\n      const sourceColumn = seg[SOURCE_COLUMN];\n      out.push(\n        seg.length === 4\n          ? [column, sourcesIndex, sourceLine, sourceColumn]\n          : [column, sourcesIndex, sourceLine, sourceColumn, namesOffset + seg[NAMES_INDEX]],\n      );\n    }\n  }\n}\n\nfunction append<T>(arr: T[], other: T[]) {\n  for (let i = 0; i < other.length; i++) arr.push(other[i]);\n}\n\nfunction getLine<T>(arr: T[][], index: number): T[] {\n  for (let i = arr.length; i <= index; i++) arr[i] = [];\n  return arr[index];\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}