{"ast":null,"code":"/***********************************************************************\n\n  A JavaScript tokenizer / parser / beautifier / compressor.\n  https://github.com/mishoo/UglifyJS2\n\n  -------------------------------- (C) ---------------------------------\n\n                           Author: Mihai Bazon\n                         <mihai.bazon@gmail.com>\n                       http://mihai.bazon.net/blog\n\n  Distributed under the BSD license:\n\n    Copyright 2012 (c) Mihai Bazon <mihai.bazon@gmail.com>\n\n    Redistribution and use in source and binary forms, with or without\n    modification, are permitted provided that the following conditions\n    are met:\n\n        * Redistributions of source code must retain the above\n          copyright notice, this list of conditions and the following\n          disclaimer.\n\n        * Redistributions in binary form must reproduce the above\n          copyright notice, this list of conditions and the following\n          disclaimer in the documentation and/or other materials\n          provided with the distribution.\n\n    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER “AS IS” AND ANY\n    EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n    IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n    PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER BE\n    LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,\n    OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n    PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n    PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR\n    TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF\n    THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n    SUCH DAMAGE.\n\n ***********************************************************************/\n\nimport { AST_Array, AST_Arrow, AST_Assign, AST_BigInt, AST_Binary, AST_Block, AST_BlockStatement, AST_Call, AST_Case, AST_Chain, AST_Class, AST_DefClass, AST_ClassStaticBlock, AST_ClassPrivateProperty, AST_ClassProperty, AST_ConciseMethod, AST_Conditional, AST_Constant, AST_Definitions, AST_Dot, AST_EmptyStatement, AST_Expansion, AST_False, AST_ForIn, AST_Function, AST_If, AST_Import, AST_ImportMeta, AST_Jump, AST_LabeledStatement, AST_Lambda, AST_New, AST_Node, AST_Null, AST_Number, AST_Object, AST_ObjectGetter, AST_ObjectKeyVal, AST_ObjectProperty, AST_ObjectSetter, AST_PrivateGetter, AST_PrivateMethod, AST_PrivateSetter, AST_PropAccess, AST_RegExp, AST_Return, AST_Scope, AST_Sequence, AST_SimpleStatement, AST_Statement, AST_String, AST_Sub, AST_Switch, AST_SwitchBranch, AST_SymbolClassProperty, AST_SymbolDeclaration, AST_SymbolRef, AST_TemplateSegment, AST_TemplateString, AST_This, AST_True, AST_Try, AST_Unary, AST_UnaryPostfix, AST_UnaryPrefix, AST_Undefined, AST_VarDef, walk, walk_abort, _PURE } from \"../ast.js\";\nimport { makePredicate, return_true, return_false, return_null, return_this, make_node, member, has_annotation } from \"../utils/index.js\";\nimport { make_sequence, best_of_expression, read_property, requires_sequence_to_maintain_binding } from \"./common.js\";\nimport { INLINED, UNDEFINED, has_flag } from \"./compressor-flags.js\";\nimport { pure_prop_access_globals, is_pure_native_fn, is_pure_native_method } from \"./native-objects.js\";\n\n// Functions and methods to infer certain facts about expressions\n// It's not always possible to be 100% sure about something just by static analysis,\n// so `true` means yes, and `false` means maybe\n\nexport const is_undeclared_ref = node => node instanceof AST_SymbolRef && node.definition().undeclared;\nexport const bitwise_binop = makePredicate(\"<<< >> << & | ^ ~\");\nexport const lazy_op = makePredicate(\"&& || ??\");\nexport const unary_side_effects = makePredicate(\"delete ++ --\");\n\n// methods to determine whether an expression has a boolean result type\n(function (def_is_boolean) {\n  const unary_bool = makePredicate(\"! delete\");\n  const binary_bool = makePredicate(\"in instanceof == != === !== < <= >= >\");\n  def_is_boolean(AST_Node, return_false);\n  def_is_boolean(AST_UnaryPrefix, function () {\n    return unary_bool.has(this.operator);\n  });\n  def_is_boolean(AST_Binary, function () {\n    return binary_bool.has(this.operator) || lazy_op.has(this.operator) && this.left.is_boolean() && this.right.is_boolean();\n  });\n  def_is_boolean(AST_Conditional, function () {\n    return this.consequent.is_boolean() && this.alternative.is_boolean();\n  });\n  def_is_boolean(AST_Assign, function () {\n    return this.operator == \"=\" && this.right.is_boolean();\n  });\n  def_is_boolean(AST_Sequence, function () {\n    return this.tail_node().is_boolean();\n  });\n  def_is_boolean(AST_True, return_true);\n  def_is_boolean(AST_False, return_true);\n})(function (node, func) {\n  node.DEFMETHOD(\"is_boolean\", func);\n});\n\n// methods to determine if an expression has a numeric result type\n(function (def_is_number) {\n  def_is_number(AST_Node, return_false);\n  def_is_number(AST_Number, return_true);\n  const unary = makePredicate(\"+ - ~ ++ --\");\n  def_is_number(AST_Unary, function (compressor) {\n    return unary.has(this.operator) && this.expression.is_number(compressor);\n  });\n  const numeric_ops = makePredicate(\"- * / % & | ^ << >> >>>\");\n  def_is_number(AST_Binary, function (compressor) {\n    if (this.operator === \"+\") {\n      // Both sides need to be `number`. Or one is a `number` and the other is number-ish.\n      return this.left.is_number(compressor) && this.right.is_number_or_bigint(compressor) || this.right.is_number(compressor) && this.left.is_number_or_bigint(compressor);\n    } else if (numeric_ops.has(this.operator)) {\n      return this.left.is_number(compressor) || this.right.is_number(compressor);\n    } else {\n      return false;\n    }\n  });\n  def_is_number(AST_Assign, function (compressor) {\n    return (this.operator === \"=\" || numeric_ops.has(this.operator.slice(0, -1))) && this.right.is_number(compressor);\n  });\n  def_is_number(AST_Sequence, function (compressor) {\n    return this.tail_node().is_number(compressor);\n  });\n  def_is_number(AST_Conditional, function (compressor) {\n    return this.consequent.is_number(compressor) && this.alternative.is_number(compressor);\n  });\n})(function (node, func) {\n  node.DEFMETHOD(\"is_number\", func);\n});\n\n// methods to determine if an expression returns a BigInt\n(function (def_is_bigint) {\n  def_is_bigint(AST_Node, return_false);\n  def_is_bigint(AST_BigInt, return_true);\n  const unary = makePredicate(\"+ - ~ ++ --\");\n  def_is_bigint(AST_Unary, function (compressor) {\n    return unary.has(this.operator) && this.expression.is_bigint(compressor);\n  });\n  const numeric_ops = makePredicate(\"- * / % & | ^ << >>\");\n  def_is_bigint(AST_Binary, function (compressor) {\n    if (this.operator === \"+\") {\n      return this.left.is_bigint(compressor) && this.right.is_number_or_bigint(compressor) || this.right.is_bigint(compressor) && this.left.is_number_or_bigint(compressor);\n    } else if (numeric_ops.has(this.operator)) {\n      return this.left.is_bigint(compressor) || this.right.is_bigint(compressor);\n    } else {\n      return false;\n    }\n  });\n  def_is_bigint(AST_Assign, function (compressor) {\n    return (numeric_ops.has(this.operator.slice(0, -1)) || this.operator == \"=\") && this.right.is_bigint(compressor);\n  });\n  def_is_bigint(AST_Sequence, function (compressor) {\n    return this.tail_node().is_bigint(compressor);\n  });\n  def_is_bigint(AST_Conditional, function (compressor) {\n    return this.consequent.is_bigint(compressor) && this.alternative.is_bigint(compressor);\n  });\n})(function (node, func) {\n  node.DEFMETHOD(\"is_bigint\", func);\n});\n\n// methods to determine if an expression is a number or a bigint\n(function (def_is_number_or_bigint) {\n  def_is_number_or_bigint(AST_Node, return_false);\n  def_is_number_or_bigint(AST_Number, return_true);\n  def_is_number_or_bigint(AST_BigInt, return_true);\n  const numeric_unary_ops = makePredicate(\"+ - ~ ++ --\");\n  def_is_number_or_bigint(AST_Unary, function (_compressor) {\n    return numeric_unary_ops.has(this.operator);\n  });\n  const numeric_ops = makePredicate(\"- * / % & | ^ << >>\");\n  def_is_number_or_bigint(AST_Binary, function (compressor) {\n    return this.operator === \"+\" ? this.left.is_number_or_bigint(compressor) && this.right.is_number_or_bigint(compressor) : numeric_ops.has(this.operator);\n  });\n  def_is_number_or_bigint(AST_Assign, function (compressor) {\n    return numeric_ops.has(this.operator.slice(0, -1)) || this.operator == \"=\" && this.right.is_number_or_bigint(compressor);\n  });\n  def_is_number_or_bigint(AST_Sequence, function (compressor) {\n    return this.tail_node().is_number_or_bigint(compressor);\n  });\n  def_is_number_or_bigint(AST_Conditional, function (compressor) {\n    return this.consequent.is_number_or_bigint(compressor) && this.alternative.is_number_or_bigint(compressor);\n  });\n})(function (node, func) {\n  node.DEFMETHOD(\"is_number_or_bigint\", func);\n});\n\n// methods to determine if an expression is a 32 bit integer (IE results from bitwise ops, or is an integer constant fitting in that size\n(function (def_is_32_bit_integer) {\n  def_is_32_bit_integer(AST_Node, return_false);\n  def_is_32_bit_integer(AST_Number, function (_compressor) {\n    return this.value === (this.value | 0);\n  });\n  def_is_32_bit_integer(AST_UnaryPrefix, function (compressor) {\n    return this.operator == \"~\" ? this.expression.is_number(compressor) : this.operator === \"+\" ? this.expression.is_32_bit_integer(compressor) : false;\n  });\n  def_is_32_bit_integer(AST_Binary, function (compressor) {\n    return bitwise_binop.has(this.operator) && (this.left.is_number(compressor) || this.right.is_number(compressor));\n  });\n})(function (node, func) {\n  node.DEFMETHOD(\"is_32_bit_integer\", func);\n});\n\n// methods to determine if an expression has a string result type\n(function (def_is_string) {\n  def_is_string(AST_Node, return_false);\n  def_is_string(AST_String, return_true);\n  def_is_string(AST_TemplateString, return_true);\n  def_is_string(AST_UnaryPrefix, function () {\n    return this.operator == \"typeof\";\n  });\n  def_is_string(AST_Binary, function (compressor) {\n    return this.operator == \"+\" && (this.left.is_string(compressor) || this.right.is_string(compressor));\n  });\n  def_is_string(AST_Assign, function (compressor) {\n    return (this.operator == \"=\" || this.operator == \"+=\") && this.right.is_string(compressor);\n  });\n  def_is_string(AST_Sequence, function (compressor) {\n    return this.tail_node().is_string(compressor);\n  });\n  def_is_string(AST_Conditional, function (compressor) {\n    return this.consequent.is_string(compressor) && this.alternative.is_string(compressor);\n  });\n})(function (node, func) {\n  node.DEFMETHOD(\"is_string\", func);\n});\nexport function is_undefined(node, compressor) {\n  return has_flag(node, UNDEFINED) || node instanceof AST_Undefined || node instanceof AST_UnaryPrefix && node.operator == \"void\" && !node.expression.has_side_effects(compressor);\n}\n\n// Is the node explicitly null or undefined.\nfunction is_null_or_undefined(node, compressor) {\n  let fixed;\n  return node instanceof AST_Null || is_undefined(node, compressor) || node instanceof AST_SymbolRef && (fixed = node.definition().fixed) instanceof AST_Node && is_nullish(fixed, compressor);\n}\n\n// Find out if this expression is optionally chained from a base-point that we\n// can statically analyze as null or undefined.\nexport function is_nullish_shortcircuited(node, compressor) {\n  if (node instanceof AST_PropAccess || node instanceof AST_Call) {\n    return node.optional && is_null_or_undefined(node.expression, compressor) || is_nullish_shortcircuited(node.expression, compressor);\n  }\n  if (node instanceof AST_Chain) return is_nullish_shortcircuited(node.expression, compressor);\n  return false;\n}\n\n// Find out if something is == null, or can short circuit into nullish.\n// Used to optimize ?. and ??\nexport function is_nullish(node, compressor) {\n  if (is_null_or_undefined(node, compressor)) return true;\n  return is_nullish_shortcircuited(node, compressor);\n}\n\n// Determine if expression might cause side effects\n// If there's a possibility that a node may change something when it's executed, this returns true\n(function (def_has_side_effects) {\n  def_has_side_effects(AST_Node, return_true);\n  def_has_side_effects(AST_EmptyStatement, return_false);\n  def_has_side_effects(AST_Constant, return_false);\n  def_has_side_effects(AST_This, return_false);\n  function any(list, compressor) {\n    for (var i = list.length; --i >= 0;) if (list[i].has_side_effects(compressor)) return true;\n    return false;\n  }\n  def_has_side_effects(AST_Block, function (compressor) {\n    return any(this.body, compressor);\n  });\n  def_has_side_effects(AST_Call, function (compressor) {\n    if (!this.is_callee_pure(compressor) && (!this.expression.is_call_pure(compressor) || this.expression.has_side_effects(compressor))) {\n      return true;\n    }\n    return any(this.args, compressor);\n  });\n  def_has_side_effects(AST_Switch, function (compressor) {\n    return this.expression.has_side_effects(compressor) || any(this.body, compressor);\n  });\n  def_has_side_effects(AST_Case, function (compressor) {\n    return this.expression.has_side_effects(compressor) || any(this.body, compressor);\n  });\n  def_has_side_effects(AST_Try, function (compressor) {\n    return this.body.has_side_effects(compressor) || this.bcatch && this.bcatch.has_side_effects(compressor) || this.bfinally && this.bfinally.has_side_effects(compressor);\n  });\n  def_has_side_effects(AST_If, function (compressor) {\n    return this.condition.has_side_effects(compressor) || this.body && this.body.has_side_effects(compressor) || this.alternative && this.alternative.has_side_effects(compressor);\n  });\n  def_has_side_effects(AST_ImportMeta, return_false);\n  def_has_side_effects(AST_LabeledStatement, function (compressor) {\n    return this.body.has_side_effects(compressor);\n  });\n  def_has_side_effects(AST_SimpleStatement, function (compressor) {\n    return this.body.has_side_effects(compressor);\n  });\n  def_has_side_effects(AST_Lambda, return_false);\n  def_has_side_effects(AST_Class, function (compressor) {\n    if (this.extends && this.extends.has_side_effects(compressor)) {\n      return true;\n    }\n    return any(this.properties, compressor);\n  });\n  def_has_side_effects(AST_ClassStaticBlock, function (compressor) {\n    return any(this.body, compressor);\n  });\n  def_has_side_effects(AST_Binary, function (compressor) {\n    return this.left.has_side_effects(compressor) || this.right.has_side_effects(compressor);\n  });\n  def_has_side_effects(AST_Assign, return_true);\n  def_has_side_effects(AST_Conditional, function (compressor) {\n    return this.condition.has_side_effects(compressor) || this.consequent.has_side_effects(compressor) || this.alternative.has_side_effects(compressor);\n  });\n  def_has_side_effects(AST_Unary, function (compressor) {\n    return unary_side_effects.has(this.operator) || this.expression.has_side_effects(compressor);\n  });\n  def_has_side_effects(AST_SymbolRef, function (compressor) {\n    return !this.is_declared(compressor) && !pure_prop_access_globals.has(this.name);\n  });\n  def_has_side_effects(AST_SymbolClassProperty, return_false);\n  def_has_side_effects(AST_SymbolDeclaration, return_false);\n  def_has_side_effects(AST_Object, function (compressor) {\n    return any(this.properties, compressor);\n  });\n  def_has_side_effects(AST_ObjectKeyVal, function (compressor) {\n    return this.computed_key() && this.key.has_side_effects(compressor) || this.value && this.value.has_side_effects(compressor);\n  });\n  def_has_side_effects([AST_ClassProperty, AST_ClassPrivateProperty], function (compressor) {\n    return this.computed_key() && this.key.has_side_effects(compressor) || this.static && this.value && this.value.has_side_effects(compressor);\n  });\n  def_has_side_effects([AST_PrivateMethod, AST_PrivateGetter, AST_PrivateSetter, AST_ConciseMethod, AST_ObjectGetter, AST_ObjectSetter], function (compressor) {\n    return this.computed_key() && this.key.has_side_effects(compressor);\n  });\n  def_has_side_effects(AST_Array, function (compressor) {\n    return any(this.elements, compressor);\n  });\n  def_has_side_effects(AST_Dot, function (compressor) {\n    if (is_nullish(this, compressor)) {\n      return this.expression.has_side_effects(compressor);\n    }\n    if (!this.optional && this.expression.may_throw_on_access(compressor)) {\n      return true;\n    }\n    return this.expression.has_side_effects(compressor);\n  });\n  def_has_side_effects(AST_Sub, function (compressor) {\n    if (is_nullish(this, compressor)) {\n      return this.expression.has_side_effects(compressor);\n    }\n    if (!this.optional && this.expression.may_throw_on_access(compressor)) {\n      return true;\n    }\n    var property = this.property.has_side_effects(compressor);\n    if (property && this.optional) return true; // \"?.\" is a condition\n\n    return property || this.expression.has_side_effects(compressor);\n  });\n  def_has_side_effects(AST_Chain, function (compressor) {\n    return this.expression.has_side_effects(compressor);\n  });\n  def_has_side_effects(AST_Sequence, function (compressor) {\n    return any(this.expressions, compressor);\n  });\n  def_has_side_effects(AST_Definitions, function (compressor) {\n    return any(this.definitions, compressor);\n  });\n  def_has_side_effects(AST_VarDef, function () {\n    return this.value != null;\n  });\n  def_has_side_effects(AST_TemplateSegment, return_false);\n  def_has_side_effects(AST_TemplateString, function (compressor) {\n    return any(this.segments, compressor);\n  });\n})(function (node_or_nodes, func) {\n  for (const node of [].concat(node_or_nodes)) {\n    node.DEFMETHOD(\"has_side_effects\", func);\n  }\n});\n\n// determine if expression may throw\n(function (def_may_throw) {\n  def_may_throw(AST_Node, return_true);\n  def_may_throw(AST_Constant, return_false);\n  def_may_throw(AST_EmptyStatement, return_false);\n  def_may_throw(AST_Lambda, return_false);\n  def_may_throw(AST_SymbolDeclaration, return_false);\n  def_may_throw(AST_This, return_false);\n  def_may_throw(AST_ImportMeta, return_false);\n  function any(list, compressor) {\n    for (var i = list.length; --i >= 0;) if (list[i].may_throw(compressor)) return true;\n    return false;\n  }\n  def_may_throw(AST_Class, function (compressor) {\n    if (this.extends && this.extends.may_throw(compressor)) return true;\n    return any(this.properties, compressor);\n  });\n  def_may_throw(AST_ClassStaticBlock, function (compressor) {\n    return any(this.body, compressor);\n  });\n  def_may_throw(AST_Array, function (compressor) {\n    return any(this.elements, compressor);\n  });\n  def_may_throw(AST_Assign, function (compressor) {\n    if (this.right.may_throw(compressor)) return true;\n    if (!compressor.has_directive(\"use strict\") && this.operator == \"=\" && this.left instanceof AST_SymbolRef) {\n      return false;\n    }\n    return this.left.may_throw(compressor);\n  });\n  def_may_throw(AST_Binary, function (compressor) {\n    return this.left.may_throw(compressor) || this.right.may_throw(compressor);\n  });\n  def_may_throw(AST_Block, function (compressor) {\n    return any(this.body, compressor);\n  });\n  def_may_throw(AST_Call, function (compressor) {\n    if (is_nullish(this, compressor)) return false;\n    if (any(this.args, compressor)) return true;\n    if (this.is_callee_pure(compressor)) return false;\n    if (this.expression.may_throw(compressor)) return true;\n    return !(this.expression instanceof AST_Lambda) || any(this.expression.body, compressor);\n  });\n  def_may_throw(AST_Case, function (compressor) {\n    return this.expression.may_throw(compressor) || any(this.body, compressor);\n  });\n  def_may_throw(AST_Conditional, function (compressor) {\n    return this.condition.may_throw(compressor) || this.consequent.may_throw(compressor) || this.alternative.may_throw(compressor);\n  });\n  def_may_throw(AST_Definitions, function (compressor) {\n    return any(this.definitions, compressor);\n  });\n  def_may_throw(AST_If, function (compressor) {\n    return this.condition.may_throw(compressor) || this.body && this.body.may_throw(compressor) || this.alternative && this.alternative.may_throw(compressor);\n  });\n  def_may_throw(AST_LabeledStatement, function (compressor) {\n    return this.body.may_throw(compressor);\n  });\n  def_may_throw(AST_Object, function (compressor) {\n    return any(this.properties, compressor);\n  });\n  def_may_throw(AST_ObjectKeyVal, function (compressor) {\n    return this.computed_key() && this.key.may_throw(compressor) || this.value ? this.value.may_throw(compressor) : false;\n  });\n  def_may_throw([AST_ClassProperty, AST_ClassPrivateProperty], function (compressor) {\n    return this.computed_key() && this.key.may_throw(compressor) || this.static && this.value && this.value.may_throw(compressor);\n  });\n  def_may_throw([AST_ConciseMethod, AST_ObjectGetter, AST_ObjectSetter], function (compressor) {\n    return this.computed_key() && this.key.may_throw(compressor);\n  });\n  def_may_throw([AST_PrivateMethod, AST_PrivateGetter, AST_PrivateSetter], return_false);\n  def_may_throw(AST_Return, function (compressor) {\n    return this.value && this.value.may_throw(compressor);\n  });\n  def_may_throw(AST_Sequence, function (compressor) {\n    return any(this.expressions, compressor);\n  });\n  def_may_throw(AST_SimpleStatement, function (compressor) {\n    return this.body.may_throw(compressor);\n  });\n  def_may_throw(AST_Dot, function (compressor) {\n    if (is_nullish(this, compressor)) return false;\n    return !this.optional && this.expression.may_throw_on_access(compressor) || this.expression.may_throw(compressor);\n  });\n  def_may_throw(AST_Sub, function (compressor) {\n    if (is_nullish(this, compressor)) return false;\n    return !this.optional && this.expression.may_throw_on_access(compressor) || this.expression.may_throw(compressor) || this.property.may_throw(compressor);\n  });\n  def_may_throw(AST_Chain, function (compressor) {\n    return this.expression.may_throw(compressor);\n  });\n  def_may_throw(AST_Switch, function (compressor) {\n    return this.expression.may_throw(compressor) || any(this.body, compressor);\n  });\n  def_may_throw(AST_SymbolRef, function (compressor) {\n    return !this.is_declared(compressor) && !pure_prop_access_globals.has(this.name);\n  });\n  def_may_throw(AST_SymbolClassProperty, return_false);\n  def_may_throw(AST_Try, function (compressor) {\n    return this.bcatch ? this.bcatch.may_throw(compressor) : this.body.may_throw(compressor) || this.bfinally && this.bfinally.may_throw(compressor);\n  });\n  def_may_throw(AST_Unary, function (compressor) {\n    if (this.operator == \"typeof\" && this.expression instanceof AST_SymbolRef) return false;\n    return this.expression.may_throw(compressor);\n  });\n  def_may_throw(AST_VarDef, function (compressor) {\n    if (!this.value) return false;\n    return this.value.may_throw(compressor);\n  });\n})(function (node_or_nodes, func) {\n  for (const node of [].concat(node_or_nodes)) {\n    node.DEFMETHOD(\"may_throw\", func);\n  }\n});\n\n// determine if expression is constant\n(function (def_is_constant_expression) {\n  function all_refs_local(scope) {\n    let result = true;\n    walk(this, node => {\n      if (node instanceof AST_SymbolRef) {\n        if (has_flag(this, INLINED)) {\n          result = false;\n          return walk_abort;\n        }\n        var def = node.definition();\n        if (member(def, this.enclosed) && !this.variables.has(def.name)) {\n          if (scope) {\n            var scope_def = scope.find_variable(node);\n            if (def.undeclared ? !scope_def : scope_def === def) {\n              result = \"f\";\n              return true;\n            }\n          }\n          result = false;\n          return walk_abort;\n        }\n        return true;\n      }\n      if (node instanceof AST_This && this instanceof AST_Arrow) {\n        result = false;\n        return walk_abort;\n      }\n    });\n    return result;\n  }\n  def_is_constant_expression(AST_Node, return_false);\n  def_is_constant_expression(AST_Constant, return_true);\n  def_is_constant_expression(AST_Class, function (scope) {\n    if (this.extends && !this.extends.is_constant_expression(scope)) {\n      return false;\n    }\n    for (const prop of this.properties) {\n      if (prop.computed_key() && !prop.key.is_constant_expression(scope)) {\n        return false;\n      }\n      if (prop.static && prop.value && !prop.value.is_constant_expression(scope)) {\n        return false;\n      }\n      if (prop instanceof AST_ClassStaticBlock) {\n        return false;\n      }\n    }\n    return all_refs_local.call(this, scope);\n  });\n  def_is_constant_expression(AST_Lambda, all_refs_local);\n  def_is_constant_expression(AST_Unary, function () {\n    return this.expression.is_constant_expression();\n  });\n  def_is_constant_expression(AST_Binary, function () {\n    return this.left.is_constant_expression() && this.right.is_constant_expression();\n  });\n  def_is_constant_expression(AST_Array, function () {\n    return this.elements.every(l => l.is_constant_expression());\n  });\n  def_is_constant_expression(AST_Object, function () {\n    return this.properties.every(l => l.is_constant_expression());\n  });\n  def_is_constant_expression(AST_ObjectProperty, function () {\n    return !!(!(this.key instanceof AST_Node) && this.value && this.value.is_constant_expression());\n  });\n})(function (node, func) {\n  node.DEFMETHOD(\"is_constant_expression\", func);\n});\n\n// may_throw_on_access()\n// returns true if this node may be null, undefined or contain `AST_Accessor`\n(function (def_may_throw_on_access) {\n  AST_Node.DEFMETHOD(\"may_throw_on_access\", function (compressor) {\n    return !compressor.option(\"pure_getters\") || this._dot_throw(compressor);\n  });\n  function is_strict(compressor) {\n    return /strict/.test(compressor.option(\"pure_getters\"));\n  }\n  def_may_throw_on_access(AST_Node, is_strict);\n  def_may_throw_on_access(AST_Null, return_true);\n  def_may_throw_on_access(AST_Undefined, return_true);\n  def_may_throw_on_access(AST_Constant, return_false);\n  def_may_throw_on_access(AST_Array, return_false);\n  def_may_throw_on_access(AST_Object, function (compressor) {\n    if (!is_strict(compressor)) return false;\n    for (var i = this.properties.length; --i >= 0;) if (this.properties[i]._dot_throw(compressor)) return true;\n    return false;\n  });\n  // Do not be as strict with classes as we are with objects.\n  // Hopefully the community is not going to abuse static getters and setters.\n  // https://github.com/terser/terser/issues/724#issuecomment-643655656\n  def_may_throw_on_access(AST_Class, return_false);\n  def_may_throw_on_access(AST_ObjectProperty, return_false);\n  def_may_throw_on_access(AST_ObjectGetter, return_true);\n  def_may_throw_on_access(AST_Expansion, function (compressor) {\n    return this.expression._dot_throw(compressor);\n  });\n  def_may_throw_on_access(AST_Function, return_false);\n  def_may_throw_on_access(AST_Arrow, return_false);\n  def_may_throw_on_access(AST_UnaryPostfix, return_false);\n  def_may_throw_on_access(AST_UnaryPrefix, function () {\n    return this.operator == \"void\";\n  });\n  def_may_throw_on_access(AST_Binary, function (compressor) {\n    return (this.operator == \"&&\" || this.operator == \"||\" || this.operator == \"??\") && (this.left._dot_throw(compressor) || this.right._dot_throw(compressor));\n  });\n  def_may_throw_on_access(AST_Assign, function (compressor) {\n    if (this.logical) return true;\n    return this.operator == \"=\" && this.right._dot_throw(compressor);\n  });\n  def_may_throw_on_access(AST_Conditional, function (compressor) {\n    return this.consequent._dot_throw(compressor) || this.alternative._dot_throw(compressor);\n  });\n  def_may_throw_on_access(AST_Dot, function (compressor) {\n    if (!is_strict(compressor)) return false;\n    if (this.property == \"prototype\") {\n      return !(this.expression instanceof AST_Function || this.expression instanceof AST_Class);\n    }\n    return true;\n  });\n  def_may_throw_on_access(AST_Chain, function (compressor) {\n    return this.expression._dot_throw(compressor);\n  });\n  def_may_throw_on_access(AST_Sequence, function (compressor) {\n    return this.tail_node()._dot_throw(compressor);\n  });\n  def_may_throw_on_access(AST_SymbolRef, function (compressor) {\n    if (this.name === \"arguments\" && this.scope instanceof AST_Lambda) return false;\n    if (has_flag(this, UNDEFINED)) return true;\n    if (!is_strict(compressor)) return false;\n    if (is_undeclared_ref(this) && this.is_declared(compressor)) return false;\n    if (this.is_immutable()) return false;\n    var fixed = this.fixed_value();\n    return !fixed || fixed._dot_throw(compressor);\n  });\n})(function (node, func) {\n  node.DEFMETHOD(\"_dot_throw\", func);\n});\nexport function is_lhs(node, parent) {\n  if (parent instanceof AST_Unary && unary_side_effects.has(parent.operator)) return parent.expression;\n  if (parent instanceof AST_Assign && parent.left === node) return node;\n  if (parent instanceof AST_ForIn && parent.init === node) return node;\n}\n\n// method to negate an expression\n(function (def_negate) {\n  function basic_negation(exp) {\n    return make_node(AST_UnaryPrefix, exp, {\n      operator: \"!\",\n      expression: exp\n    });\n  }\n  function best(orig, alt, first_in_statement) {\n    var negated = basic_negation(orig);\n    if (first_in_statement) {\n      var stat = make_node(AST_SimpleStatement, alt, {\n        body: alt\n      });\n      return best_of_expression(negated, stat) === stat ? alt : negated;\n    }\n    return best_of_expression(negated, alt);\n  }\n  def_negate(AST_Node, function () {\n    return basic_negation(this);\n  });\n  def_negate(AST_Statement, function () {\n    throw new Error(\"Cannot negate a statement\");\n  });\n  def_negate(AST_Function, function () {\n    return basic_negation(this);\n  });\n  def_negate(AST_Class, function () {\n    return basic_negation(this);\n  });\n  def_negate(AST_Arrow, function () {\n    return basic_negation(this);\n  });\n  def_negate(AST_UnaryPrefix, function () {\n    if (this.operator == \"!\") return this.expression;\n    return basic_negation(this);\n  });\n  def_negate(AST_Sequence, function (compressor) {\n    var expressions = this.expressions.slice();\n    expressions.push(expressions.pop().negate(compressor));\n    return make_sequence(this, expressions);\n  });\n  def_negate(AST_Conditional, function (compressor, first_in_statement) {\n    var self = this.clone();\n    self.consequent = self.consequent.negate(compressor);\n    self.alternative = self.alternative.negate(compressor);\n    return best(this, self, first_in_statement);\n  });\n  def_negate(AST_Binary, function (compressor, first_in_statement) {\n    var self = this.clone(),\n      op = this.operator;\n    if (compressor.option(\"unsafe_comps\")) {\n      switch (op) {\n        case \"<=\":\n          self.operator = \">\";\n          return self;\n        case \"<\":\n          self.operator = \">=\";\n          return self;\n        case \">=\":\n          self.operator = \"<\";\n          return self;\n        case \">\":\n          self.operator = \"<=\";\n          return self;\n      }\n    }\n    switch (op) {\n      case \"==\":\n        self.operator = \"!=\";\n        return self;\n      case \"!=\":\n        self.operator = \"==\";\n        return self;\n      case \"===\":\n        self.operator = \"!==\";\n        return self;\n      case \"!==\":\n        self.operator = \"===\";\n        return self;\n      case \"&&\":\n        self.operator = \"||\";\n        self.left = self.left.negate(compressor, first_in_statement);\n        self.right = self.right.negate(compressor);\n        return best(this, self, first_in_statement);\n      case \"||\":\n        self.operator = \"&&\";\n        self.left = self.left.negate(compressor, first_in_statement);\n        self.right = self.right.negate(compressor);\n        return best(this, self, first_in_statement);\n    }\n    return basic_negation(this);\n  });\n})(function (node, func) {\n  node.DEFMETHOD(\"negate\", function (compressor, first_in_statement) {\n    return func.call(this, compressor, first_in_statement);\n  });\n});\n(function (def_bitwise_negate) {\n  function basic_bitwise_negation(exp) {\n    return make_node(AST_UnaryPrefix, exp, {\n      operator: \"~\",\n      expression: exp\n    });\n  }\n  def_bitwise_negate(AST_Node, function (_compressor) {\n    return basic_bitwise_negation(this);\n  });\n  def_bitwise_negate(AST_Number, function (_compressor) {\n    const neg = ~this.value;\n    if (neg.toString().length > this.value.toString().length) {\n      return basic_bitwise_negation(this);\n    }\n    return make_node(AST_Number, this, {\n      value: neg\n    });\n  });\n  def_bitwise_negate(AST_UnaryPrefix, function (compressor, in_32_bit_context) {\n    if (this.operator == \"~\" && (this.expression.is_32_bit_integer(compressor) || (in_32_bit_context != null ? in_32_bit_context : compressor.in_32_bit_context()))) {\n      return this.expression;\n    } else {\n      return basic_bitwise_negation(this);\n    }\n  });\n})(function (node, func) {\n  node.DEFMETHOD(\"bitwise_negate\", func);\n});\n\n// Is the callee of this function pure?\nvar global_pure_fns = makePredicate(\"Boolean decodeURI decodeURIComponent Date encodeURI encodeURIComponent Error escape EvalError isFinite isNaN Number Object parseFloat parseInt RangeError ReferenceError String SyntaxError TypeError unescape URIError\");\nAST_Call.DEFMETHOD(\"is_callee_pure\", function (compressor) {\n  if (compressor.option(\"unsafe\")) {\n    var expr = this.expression;\n    var first_arg = this.args && this.args[0] && this.args[0].evaluate(compressor);\n    if (expr.expression && expr.expression.name === \"hasOwnProperty\" && (first_arg == null || first_arg.thedef && first_arg.thedef.undeclared)) {\n      return false;\n    }\n    if (is_undeclared_ref(expr) && global_pure_fns.has(expr.name)) return true;\n    if (expr instanceof AST_Dot && is_undeclared_ref(expr.expression) && is_pure_native_fn(expr.expression.name, expr.property)) {\n      return true;\n    }\n  }\n  if (this instanceof AST_New && compressor.option(\"pure_new\")) {\n    return true;\n  }\n  if (compressor.option(\"side_effects\") && has_annotation(this, _PURE)) {\n    return true;\n  }\n  return !compressor.pure_funcs(this);\n});\n\n// If I call this, is it a pure function?\nAST_Node.DEFMETHOD(\"is_call_pure\", return_false);\nAST_Dot.DEFMETHOD(\"is_call_pure\", function (compressor) {\n  if (!compressor.option(\"unsafe\")) return;\n  const expr = this.expression;\n  let native_obj;\n  if (expr instanceof AST_Array) {\n    native_obj = \"Array\";\n  } else if (expr.is_boolean()) {\n    native_obj = \"Boolean\";\n  } else if (expr.is_number(compressor)) {\n    native_obj = \"Number\";\n  } else if (expr instanceof AST_RegExp) {\n    native_obj = \"RegExp\";\n  } else if (expr.is_string(compressor)) {\n    native_obj = \"String\";\n  } else if (!this.may_throw_on_access(compressor)) {\n    native_obj = \"Object\";\n  }\n  return native_obj != null && is_pure_native_method(native_obj, this.property);\n});\n\n// tell me if a statement aborts\nexport const aborts = thing => thing && thing.aborts();\n(function (def_aborts) {\n  def_aborts(AST_Statement, return_null);\n  def_aborts(AST_Jump, return_this);\n  function block_aborts() {\n    for (var i = 0; i < this.body.length; i++) {\n      if (aborts(this.body[i])) {\n        return this.body[i];\n      }\n    }\n    return null;\n  }\n  def_aborts(AST_Import, return_null);\n  def_aborts(AST_BlockStatement, block_aborts);\n  def_aborts(AST_SwitchBranch, block_aborts);\n  def_aborts(AST_DefClass, function () {\n    for (const prop of this.properties) {\n      if (prop instanceof AST_ClassStaticBlock) {\n        if (prop.aborts()) return prop;\n      }\n    }\n    return null;\n  });\n  def_aborts(AST_ClassStaticBlock, block_aborts);\n  def_aborts(AST_If, function () {\n    return this.alternative && aborts(this.body) && aborts(this.alternative) && this;\n  });\n})(function (node, func) {\n  node.DEFMETHOD(\"aborts\", func);\n});\nAST_Node.DEFMETHOD(\"contains_this\", function () {\n  return walk(this, node => {\n    if (node instanceof AST_This) return walk_abort;\n    if (node !== this && node instanceof AST_Scope && !(node instanceof AST_Arrow)) {\n      return true;\n    }\n  });\n});\nexport function is_modified(compressor, tw, node, value, level, immutable) {\n  var parent = tw.parent(level);\n  var lhs = is_lhs(node, parent);\n  if (lhs) return lhs;\n  if (!immutable && parent instanceof AST_Call && parent.expression === node && !(value instanceof AST_Arrow) && !(value instanceof AST_Class) && !parent.is_callee_pure(compressor) && (!(value instanceof AST_Function) || !(parent instanceof AST_New) && value.contains_this())) {\n    return true;\n  }\n  if (parent instanceof AST_Array) {\n    return is_modified(compressor, tw, parent, parent, level + 1);\n  }\n  if (parent instanceof AST_ObjectKeyVal && node === parent.value) {\n    var obj = tw.parent(level + 1);\n    return is_modified(compressor, tw, obj, obj, level + 2);\n  }\n  if (parent instanceof AST_PropAccess && parent.expression === node) {\n    var prop = read_property(value, parent.property);\n    return !immutable && is_modified(compressor, tw, parent, prop, level + 1);\n  }\n}\n\n/**\n * Check if a node may be used by the expression it's in\n * void (0, 1, {node}, 2) -> false\n * console.log(0, {node}) -> true\n */\nexport function is_used_in_expression(tw) {\n  for (let p = -1, node, parent; node = tw.parent(p), parent = tw.parent(p + 1); p++) {\n    if (parent instanceof AST_Sequence) {\n      const nth_expression = parent.expressions.indexOf(node);\n      if (nth_expression !== parent.expressions.length - 1) {\n        // Detect (0, x.noThis)() constructs\n        const grandparent = tw.parent(p + 2);\n        if (parent.expressions.length > 2 || parent.expressions.length === 1 || !requires_sequence_to_maintain_binding(grandparent, parent, parent.expressions[1])) {\n          return false;\n        }\n        return true;\n      } else {\n        continue;\n      }\n    }\n    if (parent instanceof AST_Unary) {\n      const op = parent.operator;\n      if (op === \"void\") {\n        return false;\n      }\n      if (op === \"typeof\" || op === \"+\" || op === \"-\" || op === \"!\" || op === \"~\") {\n        continue;\n      }\n    }\n    if (parent instanceof AST_SimpleStatement || parent instanceof AST_LabeledStatement) {\n      return false;\n    }\n    if (parent instanceof AST_Scope) {\n      return false;\n    }\n    return true;\n  }\n  return true;\n}","map":{"version":3,"names":["AST_Array","AST_Arrow","AST_Assign","AST_BigInt","AST_Binary","AST_Block","AST_BlockStatement","AST_Call","AST_Case","AST_Chain","AST_Class","AST_DefClass","AST_ClassStaticBlock","AST_ClassPrivateProperty","AST_ClassProperty","AST_ConciseMethod","AST_Conditional","AST_Constant","AST_Definitions","AST_Dot","AST_EmptyStatement","AST_Expansion","AST_False","AST_ForIn","AST_Function","AST_If","AST_Import","AST_ImportMeta","AST_Jump","AST_LabeledStatement","AST_Lambda","AST_New","AST_Node","AST_Null","AST_Number","AST_Object","AST_ObjectGetter","AST_ObjectKeyVal","AST_ObjectProperty","AST_ObjectSetter","AST_PrivateGetter","AST_PrivateMethod","AST_PrivateSetter","AST_PropAccess","AST_RegExp","AST_Return","AST_Scope","AST_Sequence","AST_SimpleStatement","AST_Statement","AST_String","AST_Sub","AST_Switch","AST_SwitchBranch","AST_SymbolClassProperty","AST_SymbolDeclaration","AST_SymbolRef","AST_TemplateSegment","AST_TemplateString","AST_This","AST_True","AST_Try","AST_Unary","AST_UnaryPostfix","AST_UnaryPrefix","AST_Undefined","AST_VarDef","walk","walk_abort","_PURE","makePredicate","return_true","return_false","return_null","return_this","make_node","member","has_annotation","make_sequence","best_of_expression","read_property","requires_sequence_to_maintain_binding","INLINED","UNDEFINED","has_flag","pure_prop_access_globals","is_pure_native_fn","is_pure_native_method","is_undeclared_ref","node","definition","undeclared","bitwise_binop","lazy_op","unary_side_effects","def_is_boolean","unary_bool","binary_bool","has","operator","left","is_boolean","right","consequent","alternative","tail_node","func","DEFMETHOD","def_is_number","unary","compressor","expression","is_number","numeric_ops","is_number_or_bigint","slice","def_is_bigint","is_bigint","def_is_number_or_bigint","numeric_unary_ops","_compressor","def_is_32_bit_integer","value","is_32_bit_integer","def_is_string","is_string","is_undefined","has_side_effects","is_null_or_undefined","fixed","is_nullish","is_nullish_shortcircuited","optional","def_has_side_effects","any","list","i","length","body","is_callee_pure","is_call_pure","args","bcatch","bfinally","condition","extends","properties","is_declared","name","computed_key","key","static","elements","may_throw_on_access","property","expressions","definitions","segments","node_or_nodes","concat","def_may_throw","may_throw","has_directive","def_is_constant_expression","all_refs_local","scope","result","def","enclosed","variables","scope_def","find_variable","is_constant_expression","prop","call","every","l","def_may_throw_on_access","option","_dot_throw","is_strict","test","logical","is_immutable","fixed_value","is_lhs","parent","init","def_negate","basic_negation","exp","best","orig","alt","first_in_statement","negated","stat","Error","push","pop","negate","self","clone","op","def_bitwise_negate","basic_bitwise_negation","neg","toString","in_32_bit_context","global_pure_fns","expr","first_arg","evaluate","thedef","pure_funcs","native_obj","aborts","thing","def_aborts","block_aborts","is_modified","tw","level","immutable","lhs","contains_this","obj","is_used_in_expression","p","nth_expression","indexOf","grandparent"],"sources":["F:/landinghub-iconic/node_modules/.pnpm/terser@5.44.0/node_modules/terser/lib/compress/inference.js"],"sourcesContent":["/***********************************************************************\n\n  A JavaScript tokenizer / parser / beautifier / compressor.\n  https://github.com/mishoo/UglifyJS2\n\n  -------------------------------- (C) ---------------------------------\n\n                           Author: Mihai Bazon\n                         <mihai.bazon@gmail.com>\n                       http://mihai.bazon.net/blog\n\n  Distributed under the BSD license:\n\n    Copyright 2012 (c) Mihai Bazon <mihai.bazon@gmail.com>\n\n    Redistribution and use in source and binary forms, with or without\n    modification, are permitted provided that the following conditions\n    are met:\n\n        * Redistributions of source code must retain the above\n          copyright notice, this list of conditions and the following\n          disclaimer.\n\n        * Redistributions in binary form must reproduce the above\n          copyright notice, this list of conditions and the following\n          disclaimer in the documentation and/or other materials\n          provided with the distribution.\n\n    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER “AS IS” AND ANY\n    EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n    IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n    PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER BE\n    LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,\n    OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n    PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n    PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR\n    TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF\n    THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n    SUCH DAMAGE.\n\n ***********************************************************************/\n\nimport {\n  AST_Array,\n  AST_Arrow,\n  AST_Assign,\n  AST_BigInt,\n  AST_Binary,\n  AST_Block,\n  AST_BlockStatement,\n  AST_Call,\n  AST_Case,\n  AST_Chain,\n  AST_Class,\n  AST_DefClass,\n  AST_ClassStaticBlock,\n  AST_ClassPrivateProperty,\n  AST_ClassProperty,\n  AST_ConciseMethod,\n  AST_Conditional,\n  AST_Constant,\n  AST_Definitions,\n  AST_Dot,\n  AST_EmptyStatement,\n  AST_Expansion,\n  AST_False,\n  AST_ForIn,\n  AST_Function,\n  AST_If,\n  AST_Import,\n  AST_ImportMeta,\n  AST_Jump,\n  AST_LabeledStatement,\n  AST_Lambda,\n  AST_New,\n  AST_Node,\n  AST_Null,\n  AST_Number,\n  AST_Object,\n  AST_ObjectGetter,\n  AST_ObjectKeyVal,\n  AST_ObjectProperty,\n  AST_ObjectSetter,\n  AST_PrivateGetter,\n  AST_PrivateMethod,\n  AST_PrivateSetter,\n  AST_PropAccess,\n  AST_RegExp,\n  AST_Return,\n  AST_Scope,\n  AST_Sequence,\n  AST_SimpleStatement,\n  AST_Statement,\n  AST_String,\n  AST_Sub,\n  AST_Switch,\n  AST_SwitchBranch,\n  AST_SymbolClassProperty,\n  AST_SymbolDeclaration,\n  AST_SymbolRef,\n  AST_TemplateSegment,\n  AST_TemplateString,\n  AST_This,\n  AST_True,\n  AST_Try,\n  AST_Unary,\n  AST_UnaryPostfix,\n  AST_UnaryPrefix,\n  AST_Undefined,\n  AST_VarDef,\n\n  walk,\n  walk_abort,\n\n  _PURE\n} from \"../ast.js\";\nimport {\n    makePredicate,\n    return_true,\n    return_false,\n    return_null,\n    return_this,\n    make_node,\n    member,\n    has_annotation,\n} from \"../utils/index.js\";\nimport { make_sequence, best_of_expression, read_property, requires_sequence_to_maintain_binding } from \"./common.js\";\n\nimport { INLINED, UNDEFINED, has_flag } from \"./compressor-flags.js\";\nimport { pure_prop_access_globals, is_pure_native_fn, is_pure_native_method } from \"./native-objects.js\";\n\n// Functions and methods to infer certain facts about expressions\n// It's not always possible to be 100% sure about something just by static analysis,\n// so `true` means yes, and `false` means maybe\n\nexport const is_undeclared_ref = (node) =>\n    node instanceof AST_SymbolRef && node.definition().undeclared;\n\nexport const bitwise_binop = makePredicate(\"<<< >> << & | ^ ~\");\nexport const lazy_op = makePredicate(\"&& || ??\");\nexport const unary_side_effects = makePredicate(\"delete ++ --\");\n\n// methods to determine whether an expression has a boolean result type\n(function(def_is_boolean) {\n    const unary_bool = makePredicate(\"! delete\");\n    const binary_bool = makePredicate(\"in instanceof == != === !== < <= >= >\");\n    def_is_boolean(AST_Node, return_false);\n    def_is_boolean(AST_UnaryPrefix, function() {\n        return unary_bool.has(this.operator);\n    });\n    def_is_boolean(AST_Binary, function() {\n        return binary_bool.has(this.operator)\n            || lazy_op.has(this.operator)\n                && this.left.is_boolean()\n                && this.right.is_boolean();\n    });\n    def_is_boolean(AST_Conditional, function() {\n        return this.consequent.is_boolean() && this.alternative.is_boolean();\n    });\n    def_is_boolean(AST_Assign, function() {\n        return this.operator == \"=\" && this.right.is_boolean();\n    });\n    def_is_boolean(AST_Sequence, function() {\n        return this.tail_node().is_boolean();\n    });\n    def_is_boolean(AST_True, return_true);\n    def_is_boolean(AST_False, return_true);\n})(function(node, func) {\n    node.DEFMETHOD(\"is_boolean\", func);\n});\n\n// methods to determine if an expression has a numeric result type\n(function(def_is_number) {\n    def_is_number(AST_Node, return_false);\n    def_is_number(AST_Number, return_true);\n    const unary = makePredicate(\"+ - ~ ++ --\");\n    def_is_number(AST_Unary, function(compressor) {\n        return unary.has(this.operator) && this.expression.is_number(compressor);\n    });\n    const numeric_ops = makePredicate(\"- * / % & | ^ << >> >>>\");\n    def_is_number(AST_Binary, function(compressor) {\n        if (this.operator === \"+\") {\n            // Both sides need to be `number`. Or one is a `number` and the other is number-ish.\n            return this.left.is_number(compressor) && this.right.is_number_or_bigint(compressor)\n                || this.right.is_number(compressor) && this.left.is_number_or_bigint(compressor);\n        } else if (numeric_ops.has(this.operator)) {\n            return this.left.is_number(compressor) || this.right.is_number(compressor);\n        } else {\n            return false;\n        }\n    });\n    def_is_number(AST_Assign, function(compressor) {\n        return (this.operator === \"=\" || numeric_ops.has(this.operator.slice(0, -1)))\n            && this.right.is_number(compressor);\n    });\n    def_is_number(AST_Sequence, function(compressor) {\n        return this.tail_node().is_number(compressor);\n    });\n    def_is_number(AST_Conditional, function(compressor) {\n        return this.consequent.is_number(compressor) && this.alternative.is_number(compressor);\n    });\n})(function(node, func) {\n    node.DEFMETHOD(\"is_number\", func);\n});\n\n// methods to determine if an expression returns a BigInt\n(function(def_is_bigint) {\n    def_is_bigint(AST_Node, return_false);\n    def_is_bigint(AST_BigInt, return_true);\n    const unary = makePredicate(\"+ - ~ ++ --\");\n    def_is_bigint(AST_Unary, function(compressor) {\n        return unary.has(this.operator) && this.expression.is_bigint(compressor);\n    });\n    const numeric_ops = makePredicate(\"- * / % & | ^ << >>\");\n    def_is_bigint(AST_Binary, function(compressor) {\n        if (this.operator === \"+\") {\n            return this.left.is_bigint(compressor) && this.right.is_number_or_bigint(compressor)\n                || this.right.is_bigint(compressor) && this.left.is_number_or_bigint(compressor);\n        } else if (numeric_ops.has(this.operator)) {\n            return this.left.is_bigint(compressor) || this.right.is_bigint(compressor);\n        } else {\n            return false;\n        }\n    });\n    def_is_bigint(AST_Assign, function(compressor) {\n        return (numeric_ops.has(this.operator.slice(0, -1)) || this.operator == \"=\")\n            && this.right.is_bigint(compressor);\n    });\n    def_is_bigint(AST_Sequence, function(compressor) {\n        return this.tail_node().is_bigint(compressor);\n    });\n    def_is_bigint(AST_Conditional, function(compressor) {\n        return this.consequent.is_bigint(compressor) && this.alternative.is_bigint(compressor);\n    });\n})(function(node, func) {\n    node.DEFMETHOD(\"is_bigint\", func);\n});\n\n// methods to determine if an expression is a number or a bigint\n(function(def_is_number_or_bigint) {\n    def_is_number_or_bigint(AST_Node, return_false);\n    def_is_number_or_bigint(AST_Number, return_true);\n    def_is_number_or_bigint(AST_BigInt, return_true);\n    const numeric_unary_ops = makePredicate(\"+ - ~ ++ --\");\n    def_is_number_or_bigint(AST_Unary, function(_compressor) {\n        return numeric_unary_ops.has(this.operator);\n    });\n    const numeric_ops = makePredicate(\"- * / % & | ^ << >>\");\n    def_is_number_or_bigint(AST_Binary, function(compressor) {\n        return this.operator === \"+\"\n            ? this.left.is_number_or_bigint(compressor) && this.right.is_number_or_bigint(compressor)\n            : numeric_ops.has(this.operator);\n    });\n    def_is_number_or_bigint(AST_Assign, function(compressor) {\n        return numeric_ops.has(this.operator.slice(0, -1))\n            || this.operator == \"=\" && this.right.is_number_or_bigint(compressor);\n    });\n    def_is_number_or_bigint(AST_Sequence, function(compressor) {\n        return this.tail_node().is_number_or_bigint(compressor);\n    });\n    def_is_number_or_bigint(AST_Conditional, function(compressor) {\n        return this.consequent.is_number_or_bigint(compressor) && this.alternative.is_number_or_bigint(compressor);\n    });\n}(function (node, func) {\n    node.DEFMETHOD(\"is_number_or_bigint\", func);\n}));\n\n\n// methods to determine if an expression is a 32 bit integer (IE results from bitwise ops, or is an integer constant fitting in that size\n(function(def_is_32_bit_integer) {\n    def_is_32_bit_integer(AST_Node, return_false);\n    def_is_32_bit_integer(AST_Number, function(_compressor) {\n        return this.value === (this.value | 0);\n    });\n    def_is_32_bit_integer(AST_UnaryPrefix, function(compressor) {\n        return this.operator == \"~\" ? this.expression.is_number(compressor)\n            : this.operator === \"+\" ? this.expression.is_32_bit_integer(compressor)\n            : false;\n    });\n    def_is_32_bit_integer(AST_Binary, function(compressor) {\n        return bitwise_binop.has(this.operator)\n            && (this.left.is_number(compressor) || this.right.is_number(compressor));\n    });\n}(function (node, func) {\n    node.DEFMETHOD(\"is_32_bit_integer\", func);\n}));\n\n// methods to determine if an expression has a string result type\n(function(def_is_string) {\n    def_is_string(AST_Node, return_false);\n    def_is_string(AST_String, return_true);\n    def_is_string(AST_TemplateString, return_true);\n    def_is_string(AST_UnaryPrefix, function() {\n        return this.operator == \"typeof\";\n    });\n    def_is_string(AST_Binary, function(compressor) {\n        return this.operator == \"+\" &&\n            (this.left.is_string(compressor) || this.right.is_string(compressor));\n    });\n    def_is_string(AST_Assign, function(compressor) {\n        return (this.operator == \"=\" || this.operator == \"+=\") && this.right.is_string(compressor);\n    });\n    def_is_string(AST_Sequence, function(compressor) {\n        return this.tail_node().is_string(compressor);\n    });\n    def_is_string(AST_Conditional, function(compressor) {\n        return this.consequent.is_string(compressor) && this.alternative.is_string(compressor);\n    });\n})(function(node, func) {\n    node.DEFMETHOD(\"is_string\", func);\n});\n\nexport function is_undefined(node, compressor) {\n    return (\n        has_flag(node, UNDEFINED)\n        || node instanceof AST_Undefined\n        || node instanceof AST_UnaryPrefix\n            && node.operator == \"void\"\n            && !node.expression.has_side_effects(compressor)\n    );\n}\n\n// Is the node explicitly null or undefined.\nfunction is_null_or_undefined(node, compressor) {\n    let fixed;\n    return (\n        node instanceof AST_Null\n        || is_undefined(node, compressor)\n        || (\n            node instanceof AST_SymbolRef\n            && (fixed = node.definition().fixed) instanceof AST_Node\n            && is_nullish(fixed, compressor)\n        )\n    );\n}\n\n// Find out if this expression is optionally chained from a base-point that we\n// can statically analyze as null or undefined.\nexport function is_nullish_shortcircuited(node, compressor) {\n    if (node instanceof AST_PropAccess || node instanceof AST_Call) {\n        return (\n            (node.optional && is_null_or_undefined(node.expression, compressor))\n            || is_nullish_shortcircuited(node.expression, compressor)\n        );\n    }\n    if (node instanceof AST_Chain) return is_nullish_shortcircuited(node.expression, compressor);\n    return false;\n}\n\n// Find out if something is == null, or can short circuit into nullish.\n// Used to optimize ?. and ??\nexport function is_nullish(node, compressor) {\n    if (is_null_or_undefined(node, compressor)) return true;\n    return is_nullish_shortcircuited(node, compressor);\n}\n\n// Determine if expression might cause side effects\n// If there's a possibility that a node may change something when it's executed, this returns true\n(function(def_has_side_effects) {\n    def_has_side_effects(AST_Node, return_true);\n\n    def_has_side_effects(AST_EmptyStatement, return_false);\n    def_has_side_effects(AST_Constant, return_false);\n    def_has_side_effects(AST_This, return_false);\n\n    function any(list, compressor) {\n        for (var i = list.length; --i >= 0;)\n            if (list[i].has_side_effects(compressor))\n                return true;\n        return false;\n    }\n\n    def_has_side_effects(AST_Block, function(compressor) {\n        return any(this.body, compressor);\n    });\n    def_has_side_effects(AST_Call, function(compressor) {\n        if (\n            !this.is_callee_pure(compressor)\n            && (!this.expression.is_call_pure(compressor)\n                || this.expression.has_side_effects(compressor))\n        ) {\n            return true;\n        }\n        return any(this.args, compressor);\n    });\n    def_has_side_effects(AST_Switch, function(compressor) {\n        return this.expression.has_side_effects(compressor)\n            || any(this.body, compressor);\n    });\n    def_has_side_effects(AST_Case, function(compressor) {\n        return this.expression.has_side_effects(compressor)\n            || any(this.body, compressor);\n    });\n    def_has_side_effects(AST_Try, function(compressor) {\n        return this.body.has_side_effects(compressor)\n            || this.bcatch && this.bcatch.has_side_effects(compressor)\n            || this.bfinally && this.bfinally.has_side_effects(compressor);\n    });\n    def_has_side_effects(AST_If, function(compressor) {\n        return this.condition.has_side_effects(compressor)\n            || this.body && this.body.has_side_effects(compressor)\n            || this.alternative && this.alternative.has_side_effects(compressor);\n    });\n    def_has_side_effects(AST_ImportMeta, return_false);\n    def_has_side_effects(AST_LabeledStatement, function(compressor) {\n        return this.body.has_side_effects(compressor);\n    });\n    def_has_side_effects(AST_SimpleStatement, function(compressor) {\n        return this.body.has_side_effects(compressor);\n    });\n    def_has_side_effects(AST_Lambda, return_false);\n    def_has_side_effects(AST_Class, function (compressor) {\n        if (this.extends && this.extends.has_side_effects(compressor)) {\n            return true;\n        }\n        return any(this.properties, compressor);\n    });\n    def_has_side_effects(AST_ClassStaticBlock, function(compressor) {\n        return any(this.body, compressor);\n    });\n    def_has_side_effects(AST_Binary, function(compressor) {\n        return this.left.has_side_effects(compressor)\n            || this.right.has_side_effects(compressor);\n    });\n    def_has_side_effects(AST_Assign, return_true);\n    def_has_side_effects(AST_Conditional, function(compressor) {\n        return this.condition.has_side_effects(compressor)\n            || this.consequent.has_side_effects(compressor)\n            || this.alternative.has_side_effects(compressor);\n    });\n    def_has_side_effects(AST_Unary, function(compressor) {\n        return unary_side_effects.has(this.operator)\n            || this.expression.has_side_effects(compressor);\n    });\n    def_has_side_effects(AST_SymbolRef, function(compressor) {\n        return !this.is_declared(compressor) && !pure_prop_access_globals.has(this.name);\n    });\n    def_has_side_effects(AST_SymbolClassProperty, return_false);\n    def_has_side_effects(AST_SymbolDeclaration, return_false);\n    def_has_side_effects(AST_Object, function(compressor) {\n        return any(this.properties, compressor);\n    });\n    def_has_side_effects(AST_ObjectKeyVal, function(compressor) {\n        return (\n            this.computed_key() && this.key.has_side_effects(compressor)\n            || this.value && this.value.has_side_effects(compressor)\n        );\n    });\n    def_has_side_effects([\n        AST_ClassProperty,\n        AST_ClassPrivateProperty,\n    ], function(compressor) {\n        return (\n            this.computed_key() && this.key.has_side_effects(compressor)\n            || this.static && this.value && this.value.has_side_effects(compressor)\n        );\n    });\n    def_has_side_effects([\n        AST_PrivateMethod,\n        AST_PrivateGetter,\n        AST_PrivateSetter,\n        AST_ConciseMethod,\n        AST_ObjectGetter,\n        AST_ObjectSetter,\n    ], function(compressor) {\n        return this.computed_key() && this.key.has_side_effects(compressor);\n    });\n    def_has_side_effects(AST_Array, function(compressor) {\n        return any(this.elements, compressor);\n    });\n    def_has_side_effects(AST_Dot, function(compressor) {\n        if (is_nullish(this, compressor)) {\n            return this.expression.has_side_effects(compressor);\n        }\n        if (!this.optional && this.expression.may_throw_on_access(compressor)) {\n            return true;\n        }\n\n        return this.expression.has_side_effects(compressor);\n    });\n    def_has_side_effects(AST_Sub, function(compressor) {\n        if (is_nullish(this, compressor)) {\n            return this.expression.has_side_effects(compressor);\n        }\n        if (!this.optional && this.expression.may_throw_on_access(compressor)) {\n            return true;\n        }\n\n        var property = this.property.has_side_effects(compressor);\n        if (property && this.optional) return true; // \"?.\" is a condition\n\n        return property || this.expression.has_side_effects(compressor);\n    });\n    def_has_side_effects(AST_Chain, function (compressor) {\n        return this.expression.has_side_effects(compressor);\n    });\n    def_has_side_effects(AST_Sequence, function(compressor) {\n        return any(this.expressions, compressor);\n    });\n    def_has_side_effects(AST_Definitions, function(compressor) {\n        return any(this.definitions, compressor);\n    });\n    def_has_side_effects(AST_VarDef, function() {\n        return this.value != null;\n    });\n    def_has_side_effects(AST_TemplateSegment, return_false);\n    def_has_side_effects(AST_TemplateString, function(compressor) {\n        return any(this.segments, compressor);\n    });\n})(function(node_or_nodes, func) {\n    for (const node of [].concat(node_or_nodes)) {\n        node.DEFMETHOD(\"has_side_effects\", func);\n    }\n});\n\n// determine if expression may throw\n(function(def_may_throw) {\n    def_may_throw(AST_Node, return_true);\n\n    def_may_throw(AST_Constant, return_false);\n    def_may_throw(AST_EmptyStatement, return_false);\n    def_may_throw(AST_Lambda, return_false);\n    def_may_throw(AST_SymbolDeclaration, return_false);\n    def_may_throw(AST_This, return_false);\n    def_may_throw(AST_ImportMeta, return_false);\n\n    function any(list, compressor) {\n        for (var i = list.length; --i >= 0;)\n            if (list[i].may_throw(compressor))\n                return true;\n        return false;\n    }\n\n    def_may_throw(AST_Class, function(compressor) {\n        if (this.extends && this.extends.may_throw(compressor)) return true;\n        return any(this.properties, compressor);\n    });\n    def_may_throw(AST_ClassStaticBlock, function (compressor) {\n        return any(this.body, compressor);\n    });\n\n    def_may_throw(AST_Array, function(compressor) {\n        return any(this.elements, compressor);\n    });\n    def_may_throw(AST_Assign, function(compressor) {\n        if (this.right.may_throw(compressor)) return true;\n        if (!compressor.has_directive(\"use strict\")\n            && this.operator == \"=\"\n            && this.left instanceof AST_SymbolRef) {\n            return false;\n        }\n        return this.left.may_throw(compressor);\n    });\n    def_may_throw(AST_Binary, function(compressor) {\n        return this.left.may_throw(compressor)\n            || this.right.may_throw(compressor);\n    });\n    def_may_throw(AST_Block, function(compressor) {\n        return any(this.body, compressor);\n    });\n    def_may_throw(AST_Call, function(compressor) {\n        if (is_nullish(this, compressor)) return false;\n        if (any(this.args, compressor)) return true;\n        if (this.is_callee_pure(compressor)) return false;\n        if (this.expression.may_throw(compressor)) return true;\n        return !(this.expression instanceof AST_Lambda)\n            || any(this.expression.body, compressor);\n    });\n    def_may_throw(AST_Case, function(compressor) {\n        return this.expression.may_throw(compressor)\n            || any(this.body, compressor);\n    });\n    def_may_throw(AST_Conditional, function(compressor) {\n        return this.condition.may_throw(compressor)\n            || this.consequent.may_throw(compressor)\n            || this.alternative.may_throw(compressor);\n    });\n    def_may_throw(AST_Definitions, function(compressor) {\n        return any(this.definitions, compressor);\n    });\n    def_may_throw(AST_If, function(compressor) {\n        return this.condition.may_throw(compressor)\n            || this.body && this.body.may_throw(compressor)\n            || this.alternative && this.alternative.may_throw(compressor);\n    });\n    def_may_throw(AST_LabeledStatement, function(compressor) {\n        return this.body.may_throw(compressor);\n    });\n    def_may_throw(AST_Object, function(compressor) {\n        return any(this.properties, compressor);\n    });\n    def_may_throw(AST_ObjectKeyVal, function(compressor) {\n        return (\n            this.computed_key() && this.key.may_throw(compressor)\n            || this.value ? this.value.may_throw(compressor) : false\n        );\n    });\n    def_may_throw([\n        AST_ClassProperty,\n        AST_ClassPrivateProperty,\n    ], function(compressor) {\n        return (\n            this.computed_key() && this.key.may_throw(compressor)\n            || this.static && this.value && this.value.may_throw(compressor)\n        );\n    });\n    def_may_throw([\n        AST_ConciseMethod,\n        AST_ObjectGetter,\n        AST_ObjectSetter,\n    ], function(compressor) {\n        return this.computed_key() && this.key.may_throw(compressor);\n    });\n    def_may_throw([\n        AST_PrivateMethod,\n        AST_PrivateGetter,\n        AST_PrivateSetter,\n    ], return_false);\n    def_may_throw(AST_Return, function(compressor) {\n        return this.value && this.value.may_throw(compressor);\n    });\n    def_may_throw(AST_Sequence, function(compressor) {\n        return any(this.expressions, compressor);\n    });\n    def_may_throw(AST_SimpleStatement, function(compressor) {\n        return this.body.may_throw(compressor);\n    });\n    def_may_throw(AST_Dot, function(compressor) {\n        if (is_nullish(this, compressor)) return false;\n        return !this.optional && this.expression.may_throw_on_access(compressor)\n            || this.expression.may_throw(compressor);\n    });\n    def_may_throw(AST_Sub, function(compressor) {\n        if (is_nullish(this, compressor)) return false;\n        return !this.optional && this.expression.may_throw_on_access(compressor)\n            || this.expression.may_throw(compressor)\n            || this.property.may_throw(compressor);\n    });\n    def_may_throw(AST_Chain, function(compressor) {\n        return this.expression.may_throw(compressor);\n    });\n    def_may_throw(AST_Switch, function(compressor) {\n        return this.expression.may_throw(compressor)\n            || any(this.body, compressor);\n    });\n    def_may_throw(AST_SymbolRef, function(compressor) {\n        return !this.is_declared(compressor) && !pure_prop_access_globals.has(this.name);\n    });\n    def_may_throw(AST_SymbolClassProperty, return_false);\n    def_may_throw(AST_Try, function(compressor) {\n        return this.bcatch ? this.bcatch.may_throw(compressor) : this.body.may_throw(compressor)\n            || this.bfinally && this.bfinally.may_throw(compressor);\n    });\n    def_may_throw(AST_Unary, function(compressor) {\n        if (this.operator == \"typeof\" && this.expression instanceof AST_SymbolRef)\n            return false;\n        return this.expression.may_throw(compressor);\n    });\n    def_may_throw(AST_VarDef, function(compressor) {\n        if (!this.value) return false;\n        return this.value.may_throw(compressor);\n    });\n})(function(node_or_nodes, func) {\n    for (const node of [].concat(node_or_nodes)) {\n        node.DEFMETHOD(\"may_throw\", func);\n    }\n});\n\n// determine if expression is constant\n(function(def_is_constant_expression) {\n    function all_refs_local(scope) {\n        let result = true;\n        walk(this, node => {\n            if (node instanceof AST_SymbolRef) {\n                if (has_flag(this, INLINED)) {\n                    result = false;\n                    return walk_abort;\n                }\n                var def = node.definition();\n                if (\n                    member(def, this.enclosed)\n                    && !this.variables.has(def.name)\n                ) {\n                    if (scope) {\n                        var scope_def = scope.find_variable(node);\n                        if (def.undeclared ? !scope_def : scope_def === def) {\n                            result = \"f\";\n                            return true;\n                        }\n                    }\n                    result = false;\n                    return walk_abort;\n                }\n                return true;\n            }\n            if (node instanceof AST_This && this instanceof AST_Arrow) {\n                result = false;\n                return walk_abort;\n            }\n        });\n        return result;\n    }\n\n    def_is_constant_expression(AST_Node, return_false);\n    def_is_constant_expression(AST_Constant, return_true);\n    def_is_constant_expression(AST_Class, function(scope) {\n        if (this.extends && !this.extends.is_constant_expression(scope)) {\n            return false;\n        }\n\n        for (const prop of this.properties) {\n            if (prop.computed_key() && !prop.key.is_constant_expression(scope)) {\n                return false;\n            }\n            if (prop.static && prop.value && !prop.value.is_constant_expression(scope)) {\n                return false;\n            }\n            if (prop instanceof AST_ClassStaticBlock) {\n                return false;\n            }\n        }\n\n        return all_refs_local.call(this, scope);\n    });\n    def_is_constant_expression(AST_Lambda, all_refs_local);\n    def_is_constant_expression(AST_Unary, function() {\n        return this.expression.is_constant_expression();\n    });\n    def_is_constant_expression(AST_Binary, function() {\n        return this.left.is_constant_expression()\n            && this.right.is_constant_expression();\n    });\n    def_is_constant_expression(AST_Array, function() {\n        return this.elements.every((l) => l.is_constant_expression());\n    });\n    def_is_constant_expression(AST_Object, function() {\n        return this.properties.every((l) => l.is_constant_expression());\n    });\n    def_is_constant_expression(AST_ObjectProperty, function() {\n        return !!(!(this.key instanceof AST_Node) && this.value && this.value.is_constant_expression());\n    });\n})(function(node, func) {\n    node.DEFMETHOD(\"is_constant_expression\", func);\n});\n\n\n// may_throw_on_access()\n// returns true if this node may be null, undefined or contain `AST_Accessor`\n(function(def_may_throw_on_access) {\n    AST_Node.DEFMETHOD(\"may_throw_on_access\", function(compressor) {\n        return !compressor.option(\"pure_getters\")\n            || this._dot_throw(compressor);\n    });\n\n    function is_strict(compressor) {\n        return /strict/.test(compressor.option(\"pure_getters\"));\n    }\n\n    def_may_throw_on_access(AST_Node, is_strict);\n    def_may_throw_on_access(AST_Null, return_true);\n    def_may_throw_on_access(AST_Undefined, return_true);\n    def_may_throw_on_access(AST_Constant, return_false);\n    def_may_throw_on_access(AST_Array, return_false);\n    def_may_throw_on_access(AST_Object, function(compressor) {\n        if (!is_strict(compressor)) return false;\n        for (var i = this.properties.length; --i >=0;)\n            if (this.properties[i]._dot_throw(compressor)) return true;\n        return false;\n    });\n    // Do not be as strict with classes as we are with objects.\n    // Hopefully the community is not going to abuse static getters and setters.\n    // https://github.com/terser/terser/issues/724#issuecomment-643655656\n    def_may_throw_on_access(AST_Class, return_false);\n    def_may_throw_on_access(AST_ObjectProperty, return_false);\n    def_may_throw_on_access(AST_ObjectGetter, return_true);\n    def_may_throw_on_access(AST_Expansion, function(compressor) {\n        return this.expression._dot_throw(compressor);\n    });\n    def_may_throw_on_access(AST_Function, return_false);\n    def_may_throw_on_access(AST_Arrow, return_false);\n    def_may_throw_on_access(AST_UnaryPostfix, return_false);\n    def_may_throw_on_access(AST_UnaryPrefix, function() {\n        return this.operator == \"void\";\n    });\n    def_may_throw_on_access(AST_Binary, function(compressor) {\n        return (this.operator == \"&&\" || this.operator == \"||\" || this.operator == \"??\")\n            && (this.left._dot_throw(compressor) || this.right._dot_throw(compressor));\n    });\n    def_may_throw_on_access(AST_Assign, function(compressor) {\n        if (this.logical) return true;\n\n        return this.operator == \"=\"\n            && this.right._dot_throw(compressor);\n    });\n    def_may_throw_on_access(AST_Conditional, function(compressor) {\n        return this.consequent._dot_throw(compressor)\n            || this.alternative._dot_throw(compressor);\n    });\n    def_may_throw_on_access(AST_Dot, function(compressor) {\n        if (!is_strict(compressor)) return false;\n\n        if (this.property == \"prototype\") {\n            return !(\n                this.expression instanceof AST_Function\n                || this.expression instanceof AST_Class\n            );\n        }\n        return true;\n    });\n    def_may_throw_on_access(AST_Chain, function(compressor) {\n        return this.expression._dot_throw(compressor);\n    });\n    def_may_throw_on_access(AST_Sequence, function(compressor) {\n        return this.tail_node()._dot_throw(compressor);\n    });\n    def_may_throw_on_access(AST_SymbolRef, function(compressor) {\n        if (this.name === \"arguments\" && this.scope instanceof AST_Lambda) return false;\n        if (has_flag(this, UNDEFINED)) return true;\n        if (!is_strict(compressor)) return false;\n        if (is_undeclared_ref(this) && this.is_declared(compressor)) return false;\n        if (this.is_immutable()) return false;\n        var fixed = this.fixed_value();\n        return !fixed || fixed._dot_throw(compressor);\n    });\n})(function(node, func) {\n    node.DEFMETHOD(\"_dot_throw\", func);\n});\n\nexport function is_lhs(node, parent) {\n    if (parent instanceof AST_Unary && unary_side_effects.has(parent.operator)) return parent.expression;\n    if (parent instanceof AST_Assign && parent.left === node) return node;\n    if (parent instanceof AST_ForIn && parent.init === node) return node;\n}\n\n// method to negate an expression\n(function(def_negate) {\n    function basic_negation(exp) {\n        return make_node(AST_UnaryPrefix, exp, {\n            operator: \"!\",\n            expression: exp\n        });\n    }\n    function best(orig, alt, first_in_statement) {\n        var negated = basic_negation(orig);\n        if (first_in_statement) {\n            var stat = make_node(AST_SimpleStatement, alt, {\n                body: alt\n            });\n            return best_of_expression(negated, stat) === stat ? alt : negated;\n        }\n        return best_of_expression(negated, alt);\n    }\n    def_negate(AST_Node, function() {\n        return basic_negation(this);\n    });\n    def_negate(AST_Statement, function() {\n        throw new Error(\"Cannot negate a statement\");\n    });\n    def_negate(AST_Function, function() {\n        return basic_negation(this);\n    });\n    def_negate(AST_Class, function() {\n        return basic_negation(this);\n    });\n    def_negate(AST_Arrow, function() {\n        return basic_negation(this);\n    });\n    def_negate(AST_UnaryPrefix, function() {\n        if (this.operator == \"!\")\n            return this.expression;\n        return basic_negation(this);\n    });\n    def_negate(AST_Sequence, function(compressor) {\n        var expressions = this.expressions.slice();\n        expressions.push(expressions.pop().negate(compressor));\n        return make_sequence(this, expressions);\n    });\n    def_negate(AST_Conditional, function(compressor, first_in_statement) {\n        var self = this.clone();\n        self.consequent = self.consequent.negate(compressor);\n        self.alternative = self.alternative.negate(compressor);\n        return best(this, self, first_in_statement);\n    });\n    def_negate(AST_Binary, function(compressor, first_in_statement) {\n        var self = this.clone(), op = this.operator;\n        if (compressor.option(\"unsafe_comps\")) {\n            switch (op) {\n              case \"<=\" : self.operator = \">\"  ; return self;\n              case \"<\"  : self.operator = \">=\" ; return self;\n              case \">=\" : self.operator = \"<\"  ; return self;\n              case \">\"  : self.operator = \"<=\" ; return self;\n            }\n        }\n        switch (op) {\n          case \"==\" : self.operator = \"!=\"; return self;\n          case \"!=\" : self.operator = \"==\"; return self;\n          case \"===\": self.operator = \"!==\"; return self;\n          case \"!==\": self.operator = \"===\"; return self;\n          case \"&&\":\n            self.operator = \"||\";\n            self.left = self.left.negate(compressor, first_in_statement);\n            self.right = self.right.negate(compressor);\n            return best(this, self, first_in_statement);\n          case \"||\":\n            self.operator = \"&&\";\n            self.left = self.left.negate(compressor, first_in_statement);\n            self.right = self.right.negate(compressor);\n            return best(this, self, first_in_statement);\n        }\n        return basic_negation(this);\n    });\n})(function(node, func) {\n    node.DEFMETHOD(\"negate\", function(compressor, first_in_statement) {\n        return func.call(this, compressor, first_in_statement);\n    });\n});\n\n(function (def_bitwise_negate) {\n    function basic_bitwise_negation(exp) {\n        return make_node(AST_UnaryPrefix, exp, {\n            operator: \"~\",\n            expression: exp\n        });\n    }\n\n    def_bitwise_negate(AST_Node, function(_compressor) {\n        return basic_bitwise_negation(this);\n    });\n\n    def_bitwise_negate(AST_Number, function(_compressor) {\n        const neg = ~this.value;\n        if (neg.toString().length > this.value.toString().length) {\n            return basic_bitwise_negation(this);\n        }\n        return make_node(AST_Number, this, { value: neg });\n    });\n\n    def_bitwise_negate(AST_UnaryPrefix, function(compressor, in_32_bit_context) {\n        if (\n            this.operator == \"~\"\n            && (\n                this.expression.is_32_bit_integer(compressor) ||\n                (in_32_bit_context != null ? in_32_bit_context : compressor.in_32_bit_context())\n            )\n        ) {\n            return this.expression;\n        } else {\n            return basic_bitwise_negation(this);\n        }\n    });\n})(function (node, func) {\n    node.DEFMETHOD(\"bitwise_negate\", func);\n});\n\n// Is the callee of this function pure?\nvar global_pure_fns = makePredicate(\"Boolean decodeURI decodeURIComponent Date encodeURI encodeURIComponent Error escape EvalError isFinite isNaN Number Object parseFloat parseInt RangeError ReferenceError String SyntaxError TypeError unescape URIError\");\nAST_Call.DEFMETHOD(\"is_callee_pure\", function(compressor) {\n    if (compressor.option(\"unsafe\")) {\n        var expr = this.expression;\n        var first_arg = (this.args && this.args[0] && this.args[0].evaluate(compressor));\n        if (\n            expr.expression && expr.expression.name === \"hasOwnProperty\" &&\n            (first_arg == null || first_arg.thedef && first_arg.thedef.undeclared)\n        ) {\n            return false;\n        }\n        if (is_undeclared_ref(expr) && global_pure_fns.has(expr.name)) return true;\n        if (\n            expr instanceof AST_Dot\n            && is_undeclared_ref(expr.expression)\n            && is_pure_native_fn(expr.expression.name, expr.property)\n        ) {\n            return true;\n        }\n    }\n    if ((this instanceof AST_New) && compressor.option(\"pure_new\")) {\n        return true;\n    }\n    if (compressor.option(\"side_effects\") && has_annotation(this, _PURE)) {\n        return true;\n    }\n    return !compressor.pure_funcs(this);\n});\n\n// If I call this, is it a pure function?\nAST_Node.DEFMETHOD(\"is_call_pure\", return_false);\nAST_Dot.DEFMETHOD(\"is_call_pure\", function(compressor) {\n    if (!compressor.option(\"unsafe\")) return;\n    const expr = this.expression;\n\n    let native_obj;\n    if (expr instanceof AST_Array) {\n        native_obj = \"Array\";\n    } else if (expr.is_boolean()) {\n        native_obj = \"Boolean\";\n    } else if (expr.is_number(compressor)) {\n        native_obj = \"Number\";\n    } else if (expr instanceof AST_RegExp) {\n        native_obj = \"RegExp\";\n    } else if (expr.is_string(compressor)) {\n        native_obj = \"String\";\n    } else if (!this.may_throw_on_access(compressor)) {\n        native_obj = \"Object\";\n    }\n    return native_obj != null && is_pure_native_method(native_obj, this.property);\n});\n\n// tell me if a statement aborts\nexport const aborts = (thing) => thing && thing.aborts();\n\n(function(def_aborts) {\n    def_aborts(AST_Statement, return_null);\n    def_aborts(AST_Jump, return_this);\n    function block_aborts() {\n        for (var i = 0; i < this.body.length; i++) {\n            if (aborts(this.body[i])) {\n                return this.body[i];\n            }\n        }\n        return null;\n    }\n    def_aborts(AST_Import, return_null);\n    def_aborts(AST_BlockStatement, block_aborts);\n    def_aborts(AST_SwitchBranch, block_aborts);\n    def_aborts(AST_DefClass, function () {\n        for (const prop of this.properties) {\n            if (prop instanceof AST_ClassStaticBlock) {\n                if (prop.aborts()) return prop;\n            }\n        }\n        return null;\n    });\n    def_aborts(AST_ClassStaticBlock, block_aborts);\n    def_aborts(AST_If, function() {\n        return this.alternative && aborts(this.body) && aborts(this.alternative) && this;\n    });\n})(function(node, func) {\n    node.DEFMETHOD(\"aborts\", func);\n});\n\nAST_Node.DEFMETHOD(\"contains_this\", function() {\n    return walk(this, node => {\n        if (node instanceof AST_This) return walk_abort;\n        if (\n            node !== this\n            && node instanceof AST_Scope\n            && !(node instanceof AST_Arrow)\n        ) {\n            return true;\n        }\n    });\n});\n\nexport function is_modified(compressor, tw, node, value, level, immutable) {\n    var parent = tw.parent(level);\n    var lhs = is_lhs(node, parent);\n    if (lhs) return lhs;\n    if (!immutable\n        && parent instanceof AST_Call\n        && parent.expression === node\n        && !(value instanceof AST_Arrow)\n        && !(value instanceof AST_Class)\n        && !parent.is_callee_pure(compressor)\n        && (!(value instanceof AST_Function)\n            || !(parent instanceof AST_New) && value.contains_this())) {\n        return true;\n    }\n    if (parent instanceof AST_Array) {\n        return is_modified(compressor, tw, parent, parent, level + 1);\n    }\n    if (parent instanceof AST_ObjectKeyVal && node === parent.value) {\n        var obj = tw.parent(level + 1);\n        return is_modified(compressor, tw, obj, obj, level + 2);\n    }\n    if (parent instanceof AST_PropAccess && parent.expression === node) {\n        var prop = read_property(value, parent.property);\n        return !immutable && is_modified(compressor, tw, parent, prop, level + 1);\n    }\n}\n\n/**\n * Check if a node may be used by the expression it's in\n * void (0, 1, {node}, 2) -> false\n * console.log(0, {node}) -> true\n */\nexport function is_used_in_expression(tw) {\n    for (let p = -1, node, parent; node = tw.parent(p), parent = tw.parent(p + 1); p++) {\n        if (parent instanceof AST_Sequence) {\n            const nth_expression = parent.expressions.indexOf(node);\n            if (nth_expression !== parent.expressions.length - 1) {\n                // Detect (0, x.noThis)() constructs\n                const grandparent = tw.parent(p + 2);\n                if (\n                    parent.expressions.length > 2\n                    || parent.expressions.length === 1\n                    || !requires_sequence_to_maintain_binding(grandparent, parent, parent.expressions[1])\n                ) {\n                    return false;\n                }\n                return true;\n            } else {\n                continue;\n            }\n        }\n        if (parent instanceof AST_Unary) {\n            const op = parent.operator;\n            if (op === \"void\") {\n                return false;\n            }\n            if (op === \"typeof\" || op === \"+\" || op === \"-\" || op === \"!\" || op === \"~\") {\n                continue;\n            }\n        }\n        if (\n            parent instanceof AST_SimpleStatement\n            || parent instanceof AST_LabeledStatement\n        ) {\n            return false;\n        }\n        if (parent instanceof AST_Scope) {\n            return false;\n        }\n        return true;\n    }\n\n    return true;\n}\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,SACEA,SAAS,EACTC,SAAS,EACTC,UAAU,EACVC,UAAU,EACVC,UAAU,EACVC,SAAS,EACTC,kBAAkB,EAClBC,QAAQ,EACRC,QAAQ,EACRC,SAAS,EACTC,SAAS,EACTC,YAAY,EACZC,oBAAoB,EACpBC,wBAAwB,EACxBC,iBAAiB,EACjBC,iBAAiB,EACjBC,eAAe,EACfC,YAAY,EACZC,eAAe,EACfC,OAAO,EACPC,kBAAkB,EAClBC,aAAa,EACbC,SAAS,EACTC,SAAS,EACTC,YAAY,EACZC,MAAM,EACNC,UAAU,EACVC,cAAc,EACdC,QAAQ,EACRC,oBAAoB,EACpBC,UAAU,EACVC,OAAO,EACPC,QAAQ,EACRC,QAAQ,EACRC,UAAU,EACVC,UAAU,EACVC,gBAAgB,EAChBC,gBAAgB,EAChBC,kBAAkB,EAClBC,gBAAgB,EAChBC,iBAAiB,EACjBC,iBAAiB,EACjBC,iBAAiB,EACjBC,cAAc,EACdC,UAAU,EACVC,UAAU,EACVC,SAAS,EACTC,YAAY,EACZC,mBAAmB,EACnBC,aAAa,EACbC,UAAU,EACVC,OAAO,EACPC,UAAU,EACVC,gBAAgB,EAChBC,uBAAuB,EACvBC,qBAAqB,EACrBC,aAAa,EACbC,mBAAmB,EACnBC,kBAAkB,EAClBC,QAAQ,EACRC,QAAQ,EACRC,OAAO,EACPC,SAAS,EACTC,gBAAgB,EAChBC,eAAe,EACfC,aAAa,EACbC,UAAU,EAEVC,IAAI,EACJC,UAAU,EAEVC,KAAK,QACA,WAAW;AAClB,SACIC,aAAa,EACbC,WAAW,EACXC,YAAY,EACZC,WAAW,EACXC,WAAW,EACXC,SAAS,EACTC,MAAM,EACNC,cAAc,QACX,mBAAmB;AAC1B,SAASC,aAAa,EAAEC,kBAAkB,EAAEC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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}