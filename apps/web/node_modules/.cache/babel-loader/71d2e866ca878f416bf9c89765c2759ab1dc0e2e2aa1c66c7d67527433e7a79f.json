{"ast":null,"code":"/***********************************************************************\n\n  A JavaScript tokenizer / parser / beautifier / compressor.\n  https://github.com/mishoo/UglifyJS2\n\n  -------------------------------- (C) ---------------------------------\n\n                           Author: Mihai Bazon\n                         <mihai.bazon@gmail.com>\n                       http://mihai.bazon.net/blog\n\n  Distributed under the BSD license:\n\n    Copyright 2012 (c) Mihai Bazon <mihai.bazon@gmail.com>\n\n    Redistribution and use in source and binary forms, with or without\n    modification, are permitted provided that the following conditions\n    are met:\n\n        * Redistributions of source code must retain the above\n          copyright notice, this list of conditions and the following\n          disclaimer.\n\n        * Redistributions in binary form must reproduce the above\n          copyright notice, this list of conditions and the following\n          disclaimer in the documentation and/or other materials\n          provided with the distribution.\n\n    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER “AS IS” AND ANY\n    EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n    IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n    PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER BE\n    LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,\n    OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n    PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n    PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR\n    TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF\n    THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n    SUCH DAMAGE.\n\n ***********************************************************************/\n\nimport { make_node } from \"./utils/index.js\";\nimport { AST_Accessor, AST_Array, AST_Arrow, AST_Assign, AST_Atom, AST_Await, AST_BigInt, AST_Binary, AST_Block, AST_BlockStatement, AST_Boolean, AST_Break, AST_Call, AST_Case, AST_Catch, AST_Chain, AST_Class, AST_ClassStaticBlock, AST_ClassExpression, AST_ClassProperty, AST_ClassPrivateProperty, AST_ConciseMethod, AST_Conditional, AST_Const, AST_Constant, AST_Continue, AST_Debugger, AST_Default, AST_DefaultAssign, AST_DefClass, AST_DefinitionsLike, AST_Defun, AST_Destructuring, AST_Directive, AST_Do, AST_Dot, AST_DotHash, AST_EmptyStatement, AST_Expansion, AST_Export, AST_False, AST_Finally, AST_For, AST_ForIn, AST_ForOf, AST_Function, AST_Hole, AST_If, AST_Import, AST_ImportMeta, AST_Label, AST_LabeledStatement, AST_LabelRef, AST_Lambda, AST_Let, AST_NameMapping, AST_New, AST_NewTarget, AST_Node, AST_Null, AST_Number, AST_Object, AST_ObjectGetter, AST_ObjectKeyVal, AST_ObjectProperty, AST_ObjectSetter, AST_PrefixedTemplateString, AST_PrivateGetter, AST_PrivateMethod, AST_PrivateSetter, AST_PrivateIn, AST_PropAccess, AST_RegExp, AST_Return, AST_Sequence, AST_SimpleStatement, AST_Statement, AST_String, AST_Sub, AST_Super, AST_Switch, AST_SwitchBranch, AST_Symbol, AST_SymbolCatch, AST_SymbolClass, AST_SymbolClassProperty, AST_SymbolPrivateProperty, AST_SymbolConst, AST_SymbolDefClass, AST_SymbolDefun, AST_SymbolExport, AST_SymbolExportForeign, AST_SymbolFunarg, AST_SymbolImport, AST_SymbolImportForeign, AST_SymbolLambda, AST_SymbolLet, AST_SymbolMethod, AST_SymbolRef, AST_SymbolVar, AST_SymbolUsing, AST_TemplateSegment, AST_TemplateString, AST_This, AST_Throw, AST_Token, AST_Toplevel, AST_True, AST_Try, AST_TryBlock, AST_Unary, AST_UnaryPostfix, AST_UnaryPrefix, AST_Using, AST_UsingDef, AST_Var, AST_VarDef, AST_VarDefLike, AST_While, AST_With, AST_Yield } from \"./ast.js\";\nimport { is_basic_identifier_string } from \"./parse.js\";\n(function () {\n  var normalize_directives = function (body) {\n    for (var i = 0; i < body.length; i++) {\n      if (body[i] instanceof AST_Statement && body[i].body instanceof AST_String) {\n        body[i] = new AST_Directive({\n          start: body[i].start,\n          end: body[i].end,\n          quote: '\"',\n          value: body[i].body.value\n        });\n      } else {\n        return body;\n      }\n    }\n    return body;\n  };\n  function import_attributes_from_moz(attributes) {\n    if (attributes && attributes.length > 0) {\n      return new AST_Object({\n        start: my_start_token(attributes),\n        end: my_end_token(attributes),\n        properties: attributes.map(attr => new AST_ObjectKeyVal({\n          start: my_start_token(attr),\n          end: my_end_token(attr),\n          key: attr.key.name || attr.key.value,\n          value: from_moz(attr.value)\n        }))\n      });\n    }\n    return null;\n  }\n  var MOZ_TO_ME = {\n    Program: function (M) {\n      return new AST_Toplevel({\n        start: my_start_token(M),\n        end: my_end_token(M),\n        body: normalize_directives(M.body.map(from_moz))\n      });\n    },\n    ArrayPattern: function (M) {\n      return new AST_Destructuring({\n        start: my_start_token(M),\n        end: my_end_token(M),\n        names: M.elements.map(function (elm) {\n          if (elm === null) {\n            return new AST_Hole();\n          }\n          return from_moz(elm);\n        }),\n        is_array: true\n      });\n    },\n    ObjectPattern: function (M) {\n      return new AST_Destructuring({\n        start: my_start_token(M),\n        end: my_end_token(M),\n        names: M.properties.map(from_moz),\n        is_array: false\n      });\n    },\n    AssignmentPattern: function (M) {\n      return new AST_DefaultAssign({\n        start: my_start_token(M),\n        end: my_end_token(M),\n        left: from_moz(M.left),\n        operator: \"=\",\n        right: from_moz(M.right)\n      });\n    },\n    SpreadElement: function (M) {\n      return new AST_Expansion({\n        start: my_start_token(M),\n        end: my_end_token(M),\n        expression: from_moz(M.argument)\n      });\n    },\n    RestElement: function (M) {\n      return new AST_Expansion({\n        start: my_start_token(M),\n        end: my_end_token(M),\n        expression: from_moz(M.argument)\n      });\n    },\n    TemplateElement: function (M) {\n      return new AST_TemplateSegment({\n        start: my_start_token(M),\n        end: my_end_token(M),\n        value: M.value.cooked,\n        raw: M.value.raw\n      });\n    },\n    TemplateLiteral: function (M) {\n      var segments = [];\n      for (var i = 0; i < M.quasis.length; i++) {\n        segments.push(from_moz(M.quasis[i]));\n        if (M.expressions[i]) {\n          segments.push(from_moz(M.expressions[i]));\n        }\n      }\n      return new AST_TemplateString({\n        start: my_start_token(M),\n        end: my_end_token(M),\n        segments: segments\n      });\n    },\n    TaggedTemplateExpression: function (M) {\n      return new AST_PrefixedTemplateString({\n        start: my_start_token(M),\n        end: my_end_token(M),\n        template_string: from_moz(M.quasi),\n        prefix: from_moz(M.tag)\n      });\n    },\n    FunctionDeclaration: function (M) {\n      return new AST_Defun({\n        start: my_start_token(M),\n        end: my_end_token(M),\n        name: M.id && from_moz_symbol(AST_SymbolDefun, M.id),\n        argnames: M.params.map(M => from_moz_pattern(M, AST_SymbolFunarg)),\n        is_generator: M.generator,\n        async: M.async,\n        body: normalize_directives(from_moz(M.body).body)\n      });\n    },\n    FunctionExpression: function (M) {\n      return from_moz_lambda(M, /*is_method=*/false);\n    },\n    ArrowFunctionExpression: function (M) {\n      const body = M.body.type === \"BlockStatement\" ? from_moz(M.body).body : [make_node(AST_Return, {}, {\n        value: from_moz(M.body)\n      })];\n      return new AST_Arrow({\n        start: my_start_token(M),\n        end: my_end_token(M),\n        argnames: M.params.map(p => from_moz_pattern(p, AST_SymbolFunarg)),\n        body,\n        async: M.async\n      });\n    },\n    ExpressionStatement: function (M) {\n      return new AST_SimpleStatement({\n        start: my_start_token(M),\n        end: my_end_token(M),\n        body: from_moz(M.expression)\n      });\n    },\n    TryStatement: function (M) {\n      var handlers = M.handlers || [M.handler];\n      if (handlers.length > 1 || M.guardedHandlers && M.guardedHandlers.length) {\n        throw new Error(\"Multiple catch clauses are not supported.\");\n      }\n      return new AST_Try({\n        start: my_start_token(M),\n        end: my_end_token(M),\n        body: new AST_TryBlock(from_moz(M.block)),\n        bcatch: from_moz(handlers[0]),\n        bfinally: M.finalizer ? new AST_Finally(from_moz(M.finalizer)) : null\n      });\n    },\n    Property: function (M) {\n      if (M.kind == \"init\" && !M.method) {\n        var args = {\n          start: my_start_token(M.key || M.value),\n          end: my_end_token(M.value),\n          key: M.computed ? from_moz(M.key) : M.key.name || String(M.key.value),\n          quote: from_moz_quote(M.key, M.computed),\n          static: false,\n          // always an object\n          value: from_moz(M.value)\n        };\n        return new AST_ObjectKeyVal(args);\n      } else {\n        var value = from_moz_lambda(M.value, /*is_method=*/true);\n        var args = {\n          start: my_start_token(M.key || M.value),\n          end: my_end_token(M.value),\n          key: M.computed ? from_moz(M.key) : from_moz_symbol(AST_SymbolMethod, M.key),\n          quote: from_moz_quote(M.key, M.computed),\n          static: false,\n          // always an object\n          value\n        };\n        if (M.kind == \"get\") return new AST_ObjectGetter(args);\n        if (M.kind == \"set\") return new AST_ObjectSetter(args);\n        if (M.method) return new AST_ConciseMethod(args);\n      }\n    },\n    MethodDefinition: function (M) {\n      const is_private = M.key.type === \"PrivateIdentifier\";\n      const key = M.computed ? from_moz(M.key) : new AST_SymbolMethod({\n        name: M.key.name || String(M.key.value)\n      });\n      var args = {\n        start: my_start_token(M),\n        end: my_end_token(M),\n        key,\n        quote: from_moz_quote(M.key, M.computed),\n        value: from_moz_lambda(M.value, /*is_method=*/true),\n        static: M.static\n      };\n      if (M.kind == \"get\") {\n        return new (is_private ? AST_PrivateGetter : AST_ObjectGetter)(args);\n      }\n      if (M.kind == \"set\") {\n        return new (is_private ? AST_PrivateSetter : AST_ObjectSetter)(args);\n      }\n      return new (is_private ? AST_PrivateMethod : AST_ConciseMethod)(args);\n    },\n    FieldDefinition: function (M) {\n      let key;\n      if (M.computed) {\n        key = from_moz(M.key);\n      } else {\n        if (M.key.type !== \"Identifier\") throw new Error(\"Non-Identifier key in FieldDefinition\");\n        key = from_moz(M.key);\n      }\n      return new AST_ClassProperty({\n        start: my_start_token(M),\n        end: my_end_token(M),\n        quote: from_moz_quote(M.key, M.computed),\n        key,\n        value: from_moz(M.value),\n        static: M.static\n      });\n    },\n    PropertyDefinition: function (M) {\n      let key;\n      if (M.computed) {\n        key = from_moz(M.key);\n      } else if (M.key.type === \"PrivateIdentifier\") {\n        return new AST_ClassPrivateProperty({\n          start: my_start_token(M),\n          end: my_end_token(M),\n          key: from_moz(M.key),\n          value: from_moz(M.value),\n          static: M.static\n        });\n      } else {\n        key = from_moz_symbol(AST_SymbolClassProperty, M.key);\n      }\n      return new AST_ClassProperty({\n        start: my_start_token(M),\n        end: my_end_token(M),\n        quote: from_moz_quote(M.key, M.computed),\n        key,\n        value: from_moz(M.value),\n        static: M.static\n      });\n    },\n    PrivateIdentifier: function (M) {\n      return new AST_SymbolPrivateProperty({\n        start: my_start_token(M),\n        end: my_end_token(M),\n        name: M.name\n      });\n    },\n    StaticBlock: function (M) {\n      return new AST_ClassStaticBlock({\n        start: my_start_token(M),\n        end: my_end_token(M),\n        body: M.body.map(from_moz)\n      });\n    },\n    ArrayExpression: function (M) {\n      return new AST_Array({\n        start: my_start_token(M),\n        end: my_end_token(M),\n        elements: M.elements.map(function (elem) {\n          return elem === null ? new AST_Hole() : from_moz(elem);\n        })\n      });\n    },\n    ObjectExpression: function (M) {\n      return new AST_Object({\n        start: my_start_token(M),\n        end: my_end_token(M),\n        properties: M.properties.map(function (prop) {\n          if (prop.type === \"SpreadElement\") {\n            return from_moz(prop);\n          }\n          prop.type = \"Property\";\n          return from_moz(prop);\n        })\n      });\n    },\n    SequenceExpression: function (M) {\n      return new AST_Sequence({\n        start: my_start_token(M),\n        end: my_end_token(M),\n        expressions: M.expressions.map(from_moz)\n      });\n    },\n    MemberExpression: function (M) {\n      if (M.property.type === \"PrivateIdentifier\") {\n        return new AST_DotHash({\n          start: my_start_token(M),\n          end: my_end_token(M),\n          property: M.property.name,\n          expression: from_moz(M.object),\n          optional: M.optional || false\n        });\n      }\n      return new (M.computed ? AST_Sub : AST_Dot)({\n        start: my_start_token(M),\n        end: my_end_token(M),\n        property: M.computed ? from_moz(M.property) : M.property.name,\n        expression: from_moz(M.object),\n        optional: M.optional || false\n      });\n    },\n    ChainExpression: function (M) {\n      return new AST_Chain({\n        start: my_start_token(M),\n        end: my_end_token(M),\n        expression: from_moz(M.expression)\n      });\n    },\n    SwitchCase: function (M) {\n      return new (M.test ? AST_Case : AST_Default)({\n        start: my_start_token(M),\n        end: my_end_token(M),\n        expression: from_moz(M.test),\n        body: M.consequent.map(from_moz)\n      });\n    },\n    VariableDeclaration: function (M) {\n      let decl_type;\n      let defs_type = AST_VarDef;\n      let sym_type;\n      let await_using = false;\n      if (M.kind === \"const\") {\n        decl_type = AST_Const;\n        sym_type = AST_SymbolConst;\n      } else if (M.kind === \"let\") {\n        decl_type = AST_Let;\n        sym_type = AST_SymbolLet;\n      } else if (M.kind === \"using\") {\n        decl_type = AST_Using;\n        defs_type = AST_UsingDef;\n        sym_type = AST_SymbolUsing;\n      } else if (M.kind === \"await using\") {\n        decl_type = AST_Using;\n        defs_type = AST_UsingDef;\n        sym_type = AST_SymbolUsing;\n        await_using = true;\n      } else {\n        decl_type = AST_Var;\n        sym_type = AST_SymbolVar;\n      }\n      const definitions = M.declarations.map(M => {\n        return new defs_type({\n          start: my_start_token(M),\n          end: my_end_token(M),\n          name: from_moz_pattern(M.id, sym_type),\n          value: from_moz(M.init)\n        });\n      });\n      return new decl_type({\n        start: my_start_token(M),\n        end: my_end_token(M),\n        definitions: definitions,\n        await: await_using\n      });\n    },\n    ImportDeclaration: function (M) {\n      var imported_name = null;\n      var imported_names = null;\n      M.specifiers.forEach(function (specifier) {\n        if (specifier.type === \"ImportSpecifier\" || specifier.type === \"ImportNamespaceSpecifier\") {\n          if (!imported_names) {\n            imported_names = [];\n          }\n          imported_names.push(from_moz(specifier));\n        } else if (specifier.type === \"ImportDefaultSpecifier\") {\n          imported_name = from_moz(specifier);\n        }\n      });\n      return new AST_Import({\n        start: my_start_token(M),\n        end: my_end_token(M),\n        imported_name: imported_name,\n        imported_names: imported_names,\n        module_name: from_moz(M.source),\n        attributes: import_attributes_from_moz(M.attributes || M.assertions)\n      });\n    },\n    ImportSpecifier: function (M) {\n      return new AST_NameMapping({\n        start: my_start_token(M),\n        end: my_end_token(M),\n        foreign_name: from_moz_symbol(AST_SymbolImportForeign, M.imported, M.imported.type === \"Literal\"),\n        name: from_moz_symbol(AST_SymbolImport, M.local)\n      });\n    },\n    ImportDefaultSpecifier: function (M) {\n      return from_moz_symbol(AST_SymbolImport, M.local);\n    },\n    ImportNamespaceSpecifier: function (M) {\n      return new AST_NameMapping({\n        start: my_start_token(M),\n        end: my_end_token(M),\n        foreign_name: new AST_SymbolImportForeign({\n          name: \"*\"\n        }),\n        name: from_moz_symbol(AST_SymbolImport, M.local)\n      });\n    },\n    ImportExpression: function (M) {\n      const args = [from_moz(M.source)];\n      if (M.options) {\n        args.push(from_moz(M.options));\n      }\n      return new AST_Call({\n        start: my_start_token(M),\n        end: my_end_token(M),\n        expression: from_moz({\n          type: \"Identifier\",\n          name: \"import\"\n        }),\n        optional: false,\n        args\n      });\n    },\n    ExportAllDeclaration: function (M) {\n      var foreign_name = M.exported == null ? new AST_SymbolExportForeign({\n        name: \"*\"\n      }) : from_moz_symbol(AST_SymbolExportForeign, M.exported, M.exported.type === \"Literal\");\n      return new AST_Export({\n        start: my_start_token(M),\n        end: my_end_token(M),\n        exported_names: [new AST_NameMapping({\n          start: my_start_token(M),\n          end: my_end_token(M),\n          name: new AST_SymbolExport({\n            name: \"*\"\n          }),\n          foreign_name: foreign_name\n        })],\n        module_name: from_moz(M.source),\n        attributes: import_attributes_from_moz(M.attributes || M.assertions)\n      });\n    },\n    ExportNamedDeclaration: function (M) {\n      if (M.declaration) {\n        // export const, export function, ...\n        return new AST_Export({\n          start: my_start_token(M),\n          end: my_end_token(M),\n          exported_definition: from_moz(M.declaration),\n          exported_names: null,\n          module_name: null,\n          attributes: null\n        });\n      } else {\n        return new AST_Export({\n          start: my_start_token(M),\n          end: my_end_token(M),\n          exported_definition: null,\n          exported_names: M.specifiers && M.specifiers.length ? M.specifiers.map(from_moz) : [],\n          module_name: from_moz(M.source),\n          attributes: import_attributes_from_moz(M.attributes || M.assertions)\n        });\n      }\n    },\n    ExportDefaultDeclaration: function (M) {\n      return new AST_Export({\n        start: my_start_token(M),\n        end: my_end_token(M),\n        exported_value: from_moz(M.declaration),\n        is_default: true\n      });\n    },\n    ExportSpecifier: function (M) {\n      return new AST_NameMapping({\n        start: my_start_token(M),\n        end: my_end_token(M),\n        foreign_name: from_moz_symbol(AST_SymbolExportForeign, M.exported, M.exported.type === \"Literal\"),\n        name: from_moz_symbol(AST_SymbolExport, M.local, M.local.type === \"Literal\")\n      });\n    },\n    Literal: function (M) {\n      var val = M.value,\n        args = {\n          start: my_start_token(M),\n          end: my_end_token(M)\n        };\n      var rx = M.regex;\n      if (rx && rx.pattern) {\n        // RegExpLiteral as per ESTree AST spec\n        args.value = {\n          source: rx.pattern,\n          flags: rx.flags\n        };\n        return new AST_RegExp(args);\n      } else if (rx) {\n        // support legacy RegExp\n        const rx_source = M.raw || val;\n        const match = rx_source.match(/^\\/(.*)\\/(\\w*)$/);\n        if (!match) throw new Error(\"Invalid regex source \" + rx_source);\n        const [_, source, flags] = match;\n        args.value = {\n          source,\n          flags\n        };\n        return new AST_RegExp(args);\n      }\n      const bi = typeof M.value === \"bigint\" ? M.value.toString() : M.bigint;\n      if (typeof bi === \"string\") {\n        args.value = bi;\n        args.raw = M.raw;\n        return new AST_BigInt(args);\n      }\n      if (val === null) return new AST_Null(args);\n      switch (typeof val) {\n        case \"string\":\n          args.quote = \"\\\"\";\n          args.value = val;\n          return new AST_String(args);\n        case \"number\":\n          args.value = val;\n          args.raw = M.raw || val.toString();\n          return new AST_Number(args);\n        case \"boolean\":\n          return new (val ? AST_True : AST_False)(args);\n      }\n    },\n    MetaProperty: function (M) {\n      if (M.meta.name === \"new\" && M.property.name === \"target\") {\n        return new AST_NewTarget({\n          start: my_start_token(M),\n          end: my_end_token(M)\n        });\n      } else if (M.meta.name === \"import\" && M.property.name === \"meta\") {\n        return new AST_ImportMeta({\n          start: my_start_token(M),\n          end: my_end_token(M)\n        });\n      }\n    },\n    Identifier: function (M) {\n      return new AST_SymbolRef({\n        start: my_start_token(M),\n        end: my_end_token(M),\n        name: M.name\n      });\n    },\n    EmptyStatement: function (M) {\n      return new AST_EmptyStatement({\n        start: my_start_token(M),\n        end: my_end_token(M)\n      });\n    },\n    BlockStatement: function (M) {\n      return new AST_BlockStatement({\n        start: my_start_token(M),\n        end: my_end_token(M),\n        body: M.body.map(from_moz)\n      });\n    },\n    IfStatement: function (M) {\n      return new AST_If({\n        start: my_start_token(M),\n        end: my_end_token(M),\n        condition: from_moz(M.test),\n        body: from_moz(M.consequent),\n        alternative: from_moz(M.alternate)\n      });\n    },\n    LabeledStatement: function (M) {\n      try {\n        const label = from_moz_symbol(AST_Label, M.label);\n        FROM_MOZ_LABELS.push(label);\n        const stat = new AST_LabeledStatement({\n          start: my_start_token(M),\n          end: my_end_token(M),\n          label,\n          body: from_moz(M.body)\n        });\n        return stat;\n      } finally {\n        FROM_MOZ_LABELS.pop();\n      }\n    },\n    BreakStatement: function (M) {\n      return new AST_Break({\n        start: my_start_token(M),\n        end: my_end_token(M),\n        label: from_moz_label_ref(M.label)\n      });\n    },\n    ContinueStatement: function (M) {\n      return new AST_Continue({\n        start: my_start_token(M),\n        end: my_end_token(M),\n        label: from_moz_label_ref(M.label)\n      });\n    },\n    WithStatement: function (M) {\n      return new AST_With({\n        start: my_start_token(M),\n        end: my_end_token(M),\n        expression: from_moz(M.object),\n        body: from_moz(M.body)\n      });\n    },\n    SwitchStatement: function (M) {\n      return new AST_Switch({\n        start: my_start_token(M),\n        end: my_end_token(M),\n        expression: from_moz(M.discriminant),\n        body: M.cases.map(from_moz)\n      });\n    },\n    ReturnStatement: function (M) {\n      return new AST_Return({\n        start: my_start_token(M),\n        end: my_end_token(M),\n        value: from_moz(M.argument)\n      });\n    },\n    ThrowStatement: function (M) {\n      return new AST_Throw({\n        start: my_start_token(M),\n        end: my_end_token(M),\n        value: from_moz(M.argument)\n      });\n    },\n    WhileStatement: function (M) {\n      return new AST_While({\n        start: my_start_token(M),\n        end: my_end_token(M),\n        condition: from_moz(M.test),\n        body: from_moz(M.body)\n      });\n    },\n    DoWhileStatement: function (M) {\n      return new AST_Do({\n        start: my_start_token(M),\n        end: my_end_token(M),\n        condition: from_moz(M.test),\n        body: from_moz(M.body)\n      });\n    },\n    ForStatement: function (M) {\n      return new AST_For({\n        start: my_start_token(M),\n        end: my_end_token(M),\n        init: from_moz(M.init),\n        condition: from_moz(M.test),\n        step: from_moz(M.update),\n        body: from_moz(M.body)\n      });\n    },\n    ForInStatement: function (M) {\n      return new AST_ForIn({\n        start: my_start_token(M),\n        end: my_end_token(M),\n        init: from_moz(M.left),\n        object: from_moz(M.right),\n        body: from_moz(M.body)\n      });\n    },\n    ForOfStatement: function (M) {\n      return new AST_ForOf({\n        start: my_start_token(M),\n        end: my_end_token(M),\n        init: from_moz(M.left),\n        object: from_moz(M.right),\n        body: from_moz(M.body),\n        await: M.await\n      });\n    },\n    AwaitExpression: function (M) {\n      return new AST_Await({\n        start: my_start_token(M),\n        end: my_end_token(M),\n        expression: from_moz(M.argument)\n      });\n    },\n    YieldExpression: function (M) {\n      return new AST_Yield({\n        start: my_start_token(M),\n        end: my_end_token(M),\n        expression: from_moz(M.argument),\n        is_star: M.delegate\n      });\n    },\n    DebuggerStatement: function (M) {\n      return new AST_Debugger({\n        start: my_start_token(M),\n        end: my_end_token(M)\n      });\n    },\n    CatchClause: function (M) {\n      return new AST_Catch({\n        start: my_start_token(M),\n        end: my_end_token(M),\n        argname: M.param ? from_moz_pattern(M.param, AST_SymbolCatch) : null,\n        body: from_moz(M.body).body\n      });\n    },\n    ThisExpression: function (M) {\n      return new AST_This({\n        start: my_start_token(M),\n        name: \"this\",\n        end: my_end_token(M)\n      });\n    },\n    Super: function (M) {\n      return new AST_Super({\n        start: my_start_token(M),\n        end: my_end_token(M),\n        name: \"super\"\n      });\n    },\n    BinaryExpression: function (M) {\n      if (M.left.type === \"PrivateIdentifier\") {\n        return new AST_PrivateIn({\n          start: my_start_token(M),\n          end: my_end_token(M),\n          key: new AST_SymbolPrivateProperty({\n            start: my_start_token(M.left),\n            end: my_end_token(M.left),\n            name: M.left.name\n          }),\n          value: from_moz(M.right)\n        });\n      }\n      return new AST_Binary({\n        start: my_start_token(M),\n        end: my_end_token(M),\n        operator: M.operator,\n        left: from_moz(M.left),\n        right: from_moz(M.right)\n      });\n    },\n    LogicalExpression: function (M) {\n      return new AST_Binary({\n        start: my_start_token(M),\n        end: my_end_token(M),\n        operator: M.operator,\n        left: from_moz(M.left),\n        right: from_moz(M.right)\n      });\n    },\n    AssignmentExpression: function (M) {\n      return new AST_Assign({\n        start: my_start_token(M),\n        end: my_end_token(M),\n        operator: M.operator,\n        logical: M.operator === \"??=\" || M.operator === \"&&=\" || M.operator === \"||=\",\n        left: from_moz(M.left),\n        right: from_moz(M.right)\n      });\n    },\n    ConditionalExpression: function (M) {\n      return new AST_Conditional({\n        start: my_start_token(M),\n        end: my_end_token(M),\n        condition: from_moz(M.test),\n        consequent: from_moz(M.consequent),\n        alternative: from_moz(M.alternate)\n      });\n    },\n    NewExpression: function (M) {\n      return new AST_New({\n        start: my_start_token(M),\n        end: my_end_token(M),\n        expression: from_moz(M.callee),\n        args: M.arguments.map(from_moz)\n      });\n    },\n    CallExpression: function (M) {\n      return new AST_Call({\n        start: my_start_token(M),\n        end: my_end_token(M),\n        expression: from_moz(M.callee),\n        optional: M.optional,\n        args: M.arguments.map(from_moz)\n      });\n    }\n  };\n  MOZ_TO_ME.UpdateExpression = MOZ_TO_ME.UnaryExpression = function To_Moz_Unary(M) {\n    var prefix = \"prefix\" in M ? M.prefix : M.type == \"UnaryExpression\" ? true : false;\n    return new (prefix ? AST_UnaryPrefix : AST_UnaryPostfix)({\n      start: my_start_token(M),\n      end: my_end_token(M),\n      operator: M.operator,\n      expression: from_moz(M.argument)\n    });\n  };\n  MOZ_TO_ME.ClassDeclaration = MOZ_TO_ME.ClassExpression = function From_Moz_Class(M) {\n    return new (M.type === \"ClassDeclaration\" ? AST_DefClass : AST_ClassExpression)({\n      start: my_start_token(M),\n      end: my_end_token(M),\n      name: M.id && from_moz_symbol(M.type === \"ClassDeclaration\" ? AST_SymbolDefClass : AST_SymbolClass, M.id),\n      extends: from_moz(M.superClass),\n      properties: M.body.body.map(from_moz)\n    });\n  };\n  def_to_moz(AST_EmptyStatement, function To_Moz_EmptyStatement() {\n    return {\n      type: \"EmptyStatement\"\n    };\n  });\n  def_to_moz(AST_BlockStatement, function To_Moz_BlockStatement(M) {\n    return {\n      type: \"BlockStatement\",\n      body: M.body.map(to_moz)\n    };\n  });\n  def_to_moz(AST_If, function To_Moz_IfStatement(M) {\n    return {\n      type: \"IfStatement\",\n      test: to_moz(M.condition),\n      consequent: to_moz(M.body),\n      alternate: to_moz(M.alternative)\n    };\n  });\n  def_to_moz(AST_LabeledStatement, function To_Moz_LabeledStatement(M) {\n    return {\n      type: \"LabeledStatement\",\n      label: to_moz(M.label),\n      body: to_moz(M.body)\n    };\n  });\n  def_to_moz(AST_Break, function To_Moz_BreakStatement(M) {\n    return {\n      type: \"BreakStatement\",\n      label: to_moz(M.label)\n    };\n  });\n  def_to_moz(AST_Continue, function To_Moz_ContinueStatement(M) {\n    return {\n      type: \"ContinueStatement\",\n      label: to_moz(M.label)\n    };\n  });\n  def_to_moz(AST_With, function To_Moz_WithStatement(M) {\n    return {\n      type: \"WithStatement\",\n      object: to_moz(M.expression),\n      body: to_moz(M.body)\n    };\n  });\n  def_to_moz(AST_Switch, function To_Moz_SwitchStatement(M) {\n    return {\n      type: \"SwitchStatement\",\n      discriminant: to_moz(M.expression),\n      cases: M.body.map(to_moz)\n    };\n  });\n  def_to_moz(AST_Return, function To_Moz_ReturnStatement(M) {\n    return {\n      type: \"ReturnStatement\",\n      argument: to_moz(M.value)\n    };\n  });\n  def_to_moz(AST_Throw, function To_Moz_ThrowStatement(M) {\n    return {\n      type: \"ThrowStatement\",\n      argument: to_moz(M.value)\n    };\n  });\n  def_to_moz(AST_While, function To_Moz_WhileStatement(M) {\n    return {\n      type: \"WhileStatement\",\n      test: to_moz(M.condition),\n      body: to_moz(M.body)\n    };\n  });\n  def_to_moz(AST_Do, function To_Moz_DoWhileStatement(M) {\n    return {\n      type: \"DoWhileStatement\",\n      test: to_moz(M.condition),\n      body: to_moz(M.body)\n    };\n  });\n  def_to_moz(AST_For, function To_Moz_ForStatement(M) {\n    return {\n      type: \"ForStatement\",\n      init: to_moz(M.init),\n      test: to_moz(M.condition),\n      update: to_moz(M.step),\n      body: to_moz(M.body)\n    };\n  });\n  def_to_moz(AST_ForIn, function To_Moz_ForInStatement(M) {\n    return {\n      type: \"ForInStatement\",\n      left: to_moz(M.init),\n      right: to_moz(M.object),\n      body: to_moz(M.body)\n    };\n  });\n  def_to_moz(AST_ForOf, function To_Moz_ForOfStatement(M) {\n    return {\n      type: \"ForOfStatement\",\n      left: to_moz(M.init),\n      right: to_moz(M.object),\n      body: to_moz(M.body),\n      await: M.await\n    };\n  });\n  def_to_moz(AST_Await, function To_Moz_AwaitExpression(M) {\n    return {\n      type: \"AwaitExpression\",\n      argument: to_moz(M.expression)\n    };\n  });\n  def_to_moz(AST_Yield, function To_Moz_YieldExpression(M) {\n    return {\n      type: \"YieldExpression\",\n      argument: to_moz(M.expression),\n      delegate: M.is_star\n    };\n  });\n  def_to_moz(AST_Debugger, function To_Moz_DebuggerStatement() {\n    return {\n      type: \"DebuggerStatement\"\n    };\n  });\n  def_to_moz(AST_VarDefLike, function To_Moz_VariableDeclarator(M) {\n    return {\n      type: \"VariableDeclarator\",\n      id: to_moz(M.name),\n      init: to_moz(M.value)\n    };\n  });\n  def_to_moz(AST_This, function To_Moz_ThisExpression() {\n    return {\n      type: \"ThisExpression\"\n    };\n  });\n  def_to_moz(AST_Super, function To_Moz_Super() {\n    return {\n      type: \"Super\"\n    };\n  });\n  def_to_moz(AST_Conditional, function To_Moz_ConditionalExpression(M) {\n    return {\n      type: \"ConditionalExpression\",\n      test: to_moz(M.condition),\n      consequent: to_moz(M.consequent),\n      alternate: to_moz(M.alternative)\n    };\n  });\n  def_to_moz(AST_New, function To_Moz_NewExpression(M) {\n    return {\n      type: \"NewExpression\",\n      callee: to_moz(M.expression),\n      arguments: M.args.map(to_moz)\n    };\n  });\n  def_to_moz(AST_Call, function To_Moz_CallExpression(M) {\n    if (M.expression instanceof AST_SymbolRef && M.expression.name === \"import\") {\n      const [source, options] = M.args.map(to_moz);\n      return {\n        type: \"ImportExpression\",\n        source,\n        options: options || null\n      };\n    }\n    return {\n      type: \"CallExpression\",\n      callee: to_moz(M.expression),\n      optional: M.optional,\n      arguments: M.args.map(to_moz)\n    };\n  });\n  def_to_moz(AST_Toplevel, function To_Moz_Program(M) {\n    return to_moz_scope(\"Program\", M);\n  });\n  def_to_moz(AST_Expansion, function To_Moz_Spread(M) {\n    return {\n      type: to_moz_in_destructuring() ? \"RestElement\" : \"SpreadElement\",\n      argument: to_moz(M.expression)\n    };\n  });\n  def_to_moz(AST_PrefixedTemplateString, function To_Moz_TaggedTemplateExpression(M) {\n    return {\n      type: \"TaggedTemplateExpression\",\n      tag: to_moz(M.prefix),\n      quasi: to_moz(M.template_string)\n    };\n  });\n  def_to_moz(AST_TemplateString, function To_Moz_TemplateLiteral(M) {\n    var quasis = [];\n    var expressions = [];\n    for (var i = 0; i < M.segments.length; i++) {\n      if (i % 2 !== 0) {\n        expressions.push(to_moz(M.segments[i]));\n      } else {\n        quasis.push({\n          type: \"TemplateElement\",\n          value: {\n            raw: M.segments[i].raw,\n            cooked: M.segments[i].value\n          },\n          tail: i === M.segments.length - 1\n        });\n      }\n    }\n    return {\n      type: \"TemplateLiteral\",\n      quasis: quasis,\n      expressions: expressions\n    };\n  });\n  def_to_moz(AST_Defun, function To_Moz_FunctionDeclaration(M) {\n    return {\n      type: \"FunctionDeclaration\",\n      id: to_moz(M.name),\n      params: M.argnames.map(to_moz_pattern),\n      generator: M.is_generator,\n      async: M.async,\n      body: to_moz_scope(\"BlockStatement\", M)\n    };\n  });\n  def_to_moz(AST_Function, function To_Moz_FunctionExpression(M) {\n    return {\n      type: \"FunctionExpression\",\n      id: to_moz(M.name),\n      params: M.argnames.map(to_moz_pattern),\n      generator: M.is_generator || false,\n      async: M.async || false,\n      body: to_moz_scope(\"BlockStatement\", M)\n    };\n  });\n  def_to_moz(AST_Arrow, function To_Moz_ArrowFunctionExpression(M) {\n    var body = M.body.length === 1 && M.body[0] instanceof AST_Return && M.body[0].value ? to_moz(M.body[0].value) : {\n      type: \"BlockStatement\",\n      body: M.body.map(to_moz)\n    };\n    return {\n      type: \"ArrowFunctionExpression\",\n      params: M.argnames.map(to_moz_pattern),\n      async: M.async,\n      body: body\n    };\n  });\n  def_to_moz(AST_Destructuring, function To_Moz_ObjectPattern(M) {\n    if (M.is_array) {\n      return {\n        type: \"ArrayPattern\",\n        elements: M.names.map(M => M instanceof AST_Hole ? null : to_moz_pattern(M))\n      };\n    }\n    return {\n      type: \"ObjectPattern\",\n      properties: M.names.map(M => {\n        if (M instanceof AST_ObjectKeyVal) {\n          var computed = M.computed_key();\n          const [shorthand, key] = to_moz_property_key(M.key, computed, M.quote, M.value);\n          return {\n            type: \"Property\",\n            computed,\n            kind: \"init\",\n            key: key,\n            method: false,\n            shorthand,\n            value: to_moz_pattern(M.value)\n          };\n        } else {\n          return to_moz_pattern(M);\n        }\n      })\n    };\n  });\n  def_to_moz(AST_DefaultAssign, function To_Moz_AssignmentExpression(M) {\n    return {\n      type: \"AssignmentPattern\",\n      left: to_moz_pattern(M.left),\n      right: to_moz(M.right)\n    };\n  });\n  def_to_moz(AST_Directive, function To_Moz_Directive(M) {\n    return {\n      type: \"ExpressionStatement\",\n      expression: {\n        type: \"Literal\",\n        value: M.value,\n        raw: M.print_to_string()\n      },\n      directive: M.value\n    };\n  });\n  def_to_moz(AST_SimpleStatement, function To_Moz_ExpressionStatement(M) {\n    return {\n      type: \"ExpressionStatement\",\n      expression: to_moz(M.body)\n    };\n  });\n  def_to_moz(AST_SwitchBranch, function To_Moz_SwitchCase(M) {\n    return {\n      type: \"SwitchCase\",\n      test: to_moz(M.expression),\n      consequent: M.body.map(to_moz)\n    };\n  });\n  def_to_moz(AST_Try, function To_Moz_TryStatement(M) {\n    return {\n      type: \"TryStatement\",\n      block: to_moz_block(M.body),\n      handler: to_moz(M.bcatch),\n      guardedHandlers: [],\n      finalizer: to_moz(M.bfinally)\n    };\n  });\n  def_to_moz(AST_Catch, function To_Moz_CatchClause(M) {\n    return {\n      type: \"CatchClause\",\n      param: M.argname != null ? to_moz_pattern(M.argname) : null,\n      body: to_moz_block(M)\n    };\n  });\n  def_to_moz(AST_DefinitionsLike, function To_Moz_VariableDeclaration(M) {\n    return {\n      type: \"VariableDeclaration\",\n      kind: M instanceof AST_Const ? \"const\" : M instanceof AST_Let ? \"let\" : M instanceof AST_Using ? M.await ? \"await using\" : \"using\" : \"var\",\n      declarations: M.definitions.map(to_moz)\n    };\n  });\n  function import_attributes_to_moz(attribute) {\n    const import_attributes = [];\n    if (attribute) {\n      for (const {\n        key,\n        value\n      } of attribute.properties) {\n        const key_moz = is_basic_identifier_string(key) ? {\n          type: \"Identifier\",\n          name: key\n        } : {\n          type: \"Literal\",\n          value: key,\n          raw: JSON.stringify(key)\n        };\n        import_attributes.push({\n          type: \"ImportAttribute\",\n          key: key_moz,\n          value: to_moz(value)\n        });\n      }\n    }\n    return import_attributes;\n  }\n  def_to_moz(AST_Export, function To_Moz_ExportDeclaration(M) {\n    if (M.exported_names) {\n      var first_exported = M.exported_names[0];\n      if (first_exported && first_exported.name.name === \"*\" && !first_exported.name.quote) {\n        var foreign_name = first_exported.foreign_name;\n        var exported = foreign_name.name === \"*\" && !foreign_name.quote ? null : to_moz(foreign_name);\n        return {\n          type: \"ExportAllDeclaration\",\n          source: to_moz(M.module_name),\n          exported: exported,\n          attributes: import_attributes_to_moz(M.attributes)\n        };\n      }\n      return {\n        type: \"ExportNamedDeclaration\",\n        specifiers: M.exported_names.map(function (name_mapping) {\n          return {\n            type: \"ExportSpecifier\",\n            exported: to_moz(name_mapping.foreign_name),\n            local: to_moz(name_mapping.name)\n          };\n        }),\n        declaration: to_moz(M.exported_definition),\n        source: to_moz(M.module_name),\n        attributes: import_attributes_to_moz(M.attributes)\n      };\n    }\n    if (M.is_default) {\n      return {\n        type: \"ExportDefaultDeclaration\",\n        declaration: to_moz(M.exported_value || M.exported_definition)\n      };\n    } else {\n      return {\n        type: \"ExportNamedDeclaration\",\n        declaration: to_moz(M.exported_value || M.exported_definition),\n        specifiers: [],\n        source: null\n      };\n    }\n  });\n  def_to_moz(AST_Import, function To_Moz_ImportDeclaration(M) {\n    var specifiers = [];\n    if (M.imported_name) {\n      specifiers.push({\n        type: \"ImportDefaultSpecifier\",\n        local: to_moz(M.imported_name)\n      });\n    }\n    if (M.imported_names) {\n      var first_imported_foreign_name = M.imported_names[0].foreign_name;\n      if (first_imported_foreign_name.name === \"*\" && !first_imported_foreign_name.quote) {\n        specifiers.push({\n          type: \"ImportNamespaceSpecifier\",\n          local: to_moz(M.imported_names[0].name)\n        });\n      } else {\n        M.imported_names.forEach(function (name_mapping) {\n          specifiers.push({\n            type: \"ImportSpecifier\",\n            local: to_moz(name_mapping.name),\n            imported: to_moz(name_mapping.foreign_name)\n          });\n        });\n      }\n    }\n    return {\n      type: \"ImportDeclaration\",\n      specifiers: specifiers,\n      source: to_moz(M.module_name),\n      attributes: import_attributes_to_moz(M.attributes)\n    };\n  });\n  def_to_moz(AST_ImportMeta, function To_Moz_MetaProperty() {\n    return {\n      type: \"MetaProperty\",\n      meta: {\n        type: \"Identifier\",\n        name: \"import\"\n      },\n      property: {\n        type: \"Identifier\",\n        name: \"meta\"\n      }\n    };\n  });\n  def_to_moz(AST_Sequence, function To_Moz_SequenceExpression(M) {\n    return {\n      type: \"SequenceExpression\",\n      expressions: M.expressions.map(to_moz)\n    };\n  });\n  def_to_moz(AST_DotHash, function To_Moz_PrivateMemberExpression(M) {\n    return {\n      type: \"MemberExpression\",\n      object: to_moz(M.expression),\n      computed: false,\n      property: {\n        type: \"PrivateIdentifier\",\n        name: M.property\n      },\n      optional: M.optional\n    };\n  });\n  def_to_moz(AST_PropAccess, function To_Moz_MemberExpression(M) {\n    var isComputed = M instanceof AST_Sub;\n    return {\n      type: \"MemberExpression\",\n      object: to_moz(M.expression),\n      computed: isComputed,\n      property: isComputed ? to_moz(M.property) : {\n        type: \"Identifier\",\n        name: M.property\n      },\n      optional: M.optional\n    };\n  });\n  def_to_moz(AST_Chain, function To_Moz_ChainExpression(M) {\n    return {\n      type: \"ChainExpression\",\n      expression: to_moz(M.expression)\n    };\n  });\n  def_to_moz(AST_Unary, function To_Moz_Unary(M) {\n    return {\n      type: M.operator == \"++\" || M.operator == \"--\" ? \"UpdateExpression\" : \"UnaryExpression\",\n      operator: M.operator,\n      prefix: M instanceof AST_UnaryPrefix,\n      argument: to_moz(M.expression)\n    };\n  });\n  def_to_moz(AST_Binary, function To_Moz_BinaryExpression(M) {\n    if (M.operator == \"=\" && to_moz_in_destructuring()) {\n      return {\n        type: \"AssignmentPattern\",\n        left: to_moz(M.left),\n        right: to_moz(M.right)\n      };\n    }\n    const type = M.operator == \"&&\" || M.operator == \"||\" || M.operator === \"??\" ? \"LogicalExpression\" : \"BinaryExpression\";\n    return {\n      type,\n      left: to_moz(M.left),\n      operator: M.operator,\n      right: to_moz(M.right)\n    };\n  });\n  def_to_moz(AST_Assign, function To_Moz_AssignmentExpression(M) {\n    return {\n      type: \"AssignmentExpression\",\n      operator: M.operator,\n      left: to_moz(M.left),\n      right: to_moz(M.right)\n    };\n  });\n  def_to_moz(AST_PrivateIn, function To_Moz_BinaryExpression_PrivateIn(M) {\n    return {\n      type: \"BinaryExpression\",\n      left: {\n        type: \"PrivateIdentifier\",\n        name: M.key.name\n      },\n      operator: \"in\",\n      right: to_moz(M.value)\n    };\n  });\n  def_to_moz(AST_Array, function To_Moz_ArrayExpression(M) {\n    return {\n      type: \"ArrayExpression\",\n      elements: M.elements.map(to_moz)\n    };\n  });\n  def_to_moz(AST_Object, function To_Moz_ObjectExpression(M) {\n    return {\n      type: \"ObjectExpression\",\n      properties: M.properties.map(to_moz)\n    };\n  });\n  def_to_moz(AST_ObjectProperty, function To_Moz_Property(M, parent) {\n    var computed = M.computed_key();\n    const [shorthand, key] = to_moz_property_key(M.key, computed, M.quote, M.value);\n    var kind;\n    if (M instanceof AST_ObjectGetter) {\n      kind = \"get\";\n    } else if (M instanceof AST_ObjectSetter) {\n      kind = \"set\";\n    }\n    if (M instanceof AST_PrivateGetter || M instanceof AST_PrivateSetter) {\n      const kind = M instanceof AST_PrivateGetter ? \"get\" : \"set\";\n      return {\n        type: \"MethodDefinition\",\n        computed: false,\n        kind: kind,\n        static: M.static,\n        key: {\n          type: \"PrivateIdentifier\",\n          name: M.key.name\n        },\n        value: to_moz(M.value)\n      };\n    }\n    if (M instanceof AST_ClassPrivateProperty) {\n      return {\n        type: \"PropertyDefinition\",\n        key: {\n          type: \"PrivateIdentifier\",\n          name: M.key.name\n        },\n        value: to_moz(M.value),\n        computed: false,\n        static: M.static\n      };\n    }\n    if (M instanceof AST_ClassProperty) {\n      return {\n        type: \"PropertyDefinition\",\n        key,\n        value: to_moz(M.value),\n        computed,\n        static: M.static\n      };\n    }\n    if (parent instanceof AST_Class) {\n      return {\n        type: \"MethodDefinition\",\n        computed: computed,\n        kind: kind,\n        static: M.static,\n        key: to_moz(M.key),\n        value: to_moz(M.value)\n      };\n    }\n    return {\n      type: \"Property\",\n      computed: computed,\n      method: false,\n      shorthand,\n      kind: kind,\n      key: key,\n      value: to_moz(M.value)\n    };\n  });\n  def_to_moz(AST_ObjectKeyVal, function To_Moz_Property(M) {\n    var computed = M.computed_key();\n    const [shorthand, key] = to_moz_property_key(M.key, computed, M.quote, M.value);\n    return {\n      type: \"Property\",\n      computed: computed,\n      shorthand: shorthand,\n      method: false,\n      kind: \"init\",\n      key: key,\n      value: to_moz(M.value)\n    };\n  });\n  def_to_moz(AST_ConciseMethod, function To_Moz_MethodDefinition(M, parent) {\n    const computed = M.computed_key();\n    const [_always_false, key] = to_moz_property_key(M.key, computed, M.quote, M.value);\n    if (parent instanceof AST_Object) {\n      return {\n        type: \"Property\",\n        kind: \"init\",\n        computed,\n        method: true,\n        shorthand: false,\n        key,\n        value: to_moz(M.value)\n      };\n    }\n    return {\n      type: \"MethodDefinition\",\n      kind: !computed && M.key.name === \"constructor\" ? \"constructor\" : \"method\",\n      computed,\n      key,\n      value: to_moz(M.value),\n      static: M.static\n    };\n  });\n  def_to_moz(AST_PrivateMethod, function To_Moz_MethodDefinition(M) {\n    return {\n      type: \"MethodDefinition\",\n      kind: \"method\",\n      key: {\n        type: \"PrivateIdentifier\",\n        name: M.key.name\n      },\n      value: to_moz(M.value),\n      computed: false,\n      static: M.static\n    };\n  });\n  def_to_moz(AST_Class, function To_Moz_Class(M) {\n    var type = M instanceof AST_ClassExpression ? \"ClassExpression\" : \"ClassDeclaration\";\n    return {\n      type: type,\n      superClass: to_moz(M.extends),\n      id: M.name ? to_moz(M.name) : null,\n      body: {\n        type: \"ClassBody\",\n        body: M.properties.map(to_moz)\n      }\n    };\n  });\n  def_to_moz(AST_ClassStaticBlock, function To_Moz_StaticBlock(M) {\n    return {\n      type: \"StaticBlock\",\n      body: M.body.map(to_moz)\n    };\n  });\n  def_to_moz(AST_NewTarget, function To_Moz_MetaProperty() {\n    return {\n      type: \"MetaProperty\",\n      meta: {\n        type: \"Identifier\",\n        name: \"new\"\n      },\n      property: {\n        type: \"Identifier\",\n        name: \"target\"\n      }\n    };\n  });\n  def_to_moz(AST_Symbol, function To_Moz_Identifier(M, parent) {\n    if (M instanceof AST_SymbolMethod && parent.quote || (M instanceof AST_SymbolImportForeign || M instanceof AST_SymbolExportForeign || M instanceof AST_SymbolExport) && M.quote) {\n      return {\n        type: \"Literal\",\n        value: M.name\n      };\n    }\n    var def = M.definition();\n    return {\n      type: \"Identifier\",\n      name: def ? def.mangled_name || def.name : M.name\n    };\n  });\n  def_to_moz(AST_RegExp, function To_Moz_RegExpLiteral(M) {\n    const pattern = M.value.source;\n    const flags = M.value.flags;\n    return {\n      type: \"Literal\",\n      value: null,\n      raw: M.print_to_string(),\n      regex: {\n        pattern,\n        flags\n      }\n    };\n  });\n  def_to_moz(AST_Constant, function To_Moz_Literal(M) {\n    var value = M.value;\n    return {\n      type: \"Literal\",\n      value: value,\n      raw: M.raw || M.print_to_string()\n    };\n  });\n  def_to_moz(AST_Atom, function To_Moz_Atom(M) {\n    return {\n      type: \"Identifier\",\n      name: String(M.value)\n    };\n  });\n  def_to_moz(AST_BigInt, M => ({\n    type: \"Literal\",\n    // value cannot be represented natively\n    // see: https://github.com/estree/estree/blob/master/es2020.md#bigintliteral\n    value: null,\n    // `M.value` is a string that may be a hex number representation.\n    // but \"bigint\" property should have only decimal digits\n    bigint: typeof BigInt === \"function\" ? BigInt(M.value).toString() : M.value,\n    raw: M.raw\n  }));\n  AST_Boolean.DEFMETHOD(\"to_mozilla_ast\", AST_Constant.prototype.to_mozilla_ast);\n  AST_Null.DEFMETHOD(\"to_mozilla_ast\", AST_Constant.prototype.to_mozilla_ast);\n  AST_Hole.DEFMETHOD(\"to_mozilla_ast\", function To_Moz_ArrayHole() {\n    return null;\n  });\n  AST_Block.DEFMETHOD(\"to_mozilla_ast\", AST_BlockStatement.prototype.to_mozilla_ast);\n  AST_Lambda.DEFMETHOD(\"to_mozilla_ast\", AST_Function.prototype.to_mozilla_ast);\n\n  /* -----[ tools ]----- */\n\n  function my_start_token(moznode) {\n    var loc = moznode.loc,\n      start = loc && loc.start;\n    var range = moznode.range;\n    return new AST_Token(\"\", \"\", start && start.line || 0, start && start.column || 0, range ? range[0] : moznode.start, false, [], [], loc && loc.source);\n  }\n  function my_end_token(moznode) {\n    var loc = moznode.loc,\n      end = loc && loc.end;\n    var range = moznode.range;\n    return new AST_Token(\"\", \"\", end && end.line || 0, end && end.column || 0, range ? range[0] : moznode.end, false, [], [], loc && loc.source);\n  }\n  var FROM_MOZ_LABELS = null;\n  function from_moz(node) {\n    if (node == null) return null;\n    return MOZ_TO_ME[node.type](node);\n  }\n  function from_moz_quote(moz_key, computed) {\n    if (!computed && moz_key.type === \"Literal\" && typeof moz_key.value === \"string\") {\n      return '\"';\n    } else {\n      return \"\";\n    }\n  }\n  function from_moz_symbol(symbol_type, M, has_quote) {\n    return new symbol_type({\n      start: my_start_token(M),\n      quote: has_quote ? '\"' : undefined,\n      name: M.type === \"Identifier\" ? M.name : String(M.value),\n      end: my_end_token(M)\n    });\n  }\n  function from_moz_lambda(M, is_method) {\n    return new (is_method ? AST_Accessor : AST_Function)({\n      start: my_start_token(M),\n      end: my_end_token(M),\n      name: M.id && from_moz_symbol(is_method ? AST_SymbolMethod : AST_SymbolLambda, M.id),\n      argnames: M.params.map(M => from_moz_pattern(M, AST_SymbolFunarg)),\n      is_generator: M.generator,\n      async: M.async,\n      body: normalize_directives(from_moz(M.body).body)\n    });\n  }\n  function from_moz_pattern(M, sym_type) {\n    switch (M.type) {\n      case \"ObjectPattern\":\n        return new AST_Destructuring({\n          start: my_start_token(M),\n          end: my_end_token(M),\n          names: M.properties.map(p => from_moz_pattern(p, sym_type)),\n          is_array: false\n        });\n      case \"Property\":\n        var key = M.key;\n        var args = {\n          start: my_start_token(key || M.value),\n          end: my_end_token(M.value),\n          key: key.type == \"Identifier\" ? key.name : String(key.value),\n          quote: !M.computed && key.type === \"Literal\" && typeof key.value === \"string\" ? '\"' : \"\",\n          value: from_moz_pattern(M.value, sym_type)\n        };\n        if (M.computed) {\n          args.key = from_moz(M.key);\n        }\n        return new AST_ObjectKeyVal(args);\n      case \"ArrayPattern\":\n        return new AST_Destructuring({\n          start: my_start_token(M),\n          end: my_end_token(M),\n          names: M.elements.map(function (elm) {\n            if (elm === null) {\n              return new AST_Hole();\n            }\n            return from_moz_pattern(elm, sym_type);\n          }),\n          is_array: true\n        });\n      case \"SpreadElement\":\n      case \"RestElement\":\n        return new AST_Expansion({\n          start: my_start_token(M),\n          end: my_end_token(M),\n          expression: from_moz_pattern(M.argument, sym_type)\n        });\n      case \"AssignmentPattern\":\n        return new AST_DefaultAssign({\n          start: my_start_token(M),\n          end: my_end_token(M),\n          left: from_moz_pattern(M.left, sym_type),\n          operator: \"=\",\n          right: from_moz(M.right)\n        });\n      case \"Identifier\":\n        return new sym_type({\n          start: my_start_token(M),\n          end: my_end_token(M),\n          name: M.name\n        });\n      default:\n        throw new Error(\"Invalid node type for destructuring: \" + M.type);\n    }\n  }\n  function from_moz_label_ref(m_label) {\n    if (!m_label) return null;\n    const label = from_moz_symbol(AST_LabelRef, m_label);\n    let i = FROM_MOZ_LABELS.length;\n    while (i--) {\n      const label_origin = FROM_MOZ_LABELS[i];\n      if (label.name === label_origin.name) {\n        label.thedef = label_origin;\n        break;\n      }\n    }\n    return label;\n  }\n  AST_Node.from_mozilla_ast = function (node) {\n    var save_labels = FROM_MOZ_LABELS;\n    FROM_MOZ_LABELS = [];\n    var ast = from_moz(node);\n    FROM_MOZ_LABELS = save_labels;\n    return ast;\n  };\n  function set_moz_loc(mynode, moznode) {\n    var start = mynode.start;\n    var end = mynode.end;\n    if (!(start && end)) {\n      return moznode;\n    }\n    if (start.pos != null && end.endpos != null) {\n      moznode.range = [start.pos, end.endpos];\n    }\n    if (start.line) {\n      moznode.loc = {\n        start: {\n          line: start.line,\n          column: start.col\n        },\n        end: end.endline ? {\n          line: end.endline,\n          column: end.endcol\n        } : null\n      };\n      if (start.file) {\n        moznode.loc.source = start.file;\n      }\n    }\n    return moznode;\n  }\n  function def_to_moz(mytype, handler) {\n    mytype.DEFMETHOD(\"to_mozilla_ast\", function (parent) {\n      return set_moz_loc(this, handler(this, parent));\n    });\n  }\n  var TO_MOZ_STACK = null;\n  function to_moz(node) {\n    if (TO_MOZ_STACK === null) {\n      TO_MOZ_STACK = [];\n    }\n    TO_MOZ_STACK.push(node);\n    var ast = node != null ? node.to_mozilla_ast(TO_MOZ_STACK[TO_MOZ_STACK.length - 2]) : null;\n    TO_MOZ_STACK.pop();\n    if (TO_MOZ_STACK.length === 0) {\n      TO_MOZ_STACK = null;\n    }\n    return ast;\n  }\n\n  /** Object property keys can be number literals, string literals, or raw names. Additionally they can be shorthand. We decide that here. */\n  function to_moz_property_key(key, computed = false, quote = false, value = null) {\n    if (computed) {\n      return [false, to_moz(key)];\n    }\n    const key_name = typeof key === \"string\" ? key : key.name;\n    let moz_key;\n    if (quote) {\n      moz_key = {\n        type: \"Literal\",\n        value: key_name,\n        raw: JSON.stringify(key_name)\n      };\n    } else if (\"\" + +key_name === key_name && +key_name >= 0) {\n      // representable as a number\n      moz_key = {\n        type: \"Literal\",\n        value: +key_name,\n        raw: JSON.stringify(+key_name)\n      };\n    } else {\n      moz_key = {\n        type: \"Identifier\",\n        name: key_name\n      };\n    }\n    const shorthand = moz_key.type === \"Identifier\" && moz_key.name === key_name && (value instanceof AST_Symbol && value.name === key_name || value instanceof AST_DefaultAssign && value.left.name === key_name);\n    return [shorthand, moz_key];\n  }\n  function to_moz_pattern(node) {\n    if (node instanceof AST_Expansion) {\n      return {\n        type: \"RestElement\",\n        argument: to_moz_pattern(node.expression)\n      };\n    }\n    if (node instanceof AST_Symbol || node instanceof AST_Destructuring || node instanceof AST_DefaultAssign || node instanceof AST_PropAccess) {\n      // Plain translation\n      return to_moz(node);\n    }\n    throw new Error(node.TYPE);\n  }\n  function to_moz_in_destructuring() {\n    var i = TO_MOZ_STACK.length;\n    while (i--) {\n      if (TO_MOZ_STACK[i] instanceof AST_Destructuring) {\n        return true;\n      }\n    }\n    return false;\n  }\n  function to_moz_block(node) {\n    return {\n      type: \"BlockStatement\",\n      body: node.body.map(to_moz)\n    };\n  }\n  function to_moz_scope(type, node) {\n    var body = node.body.map(to_moz);\n    if (node.body[0] instanceof AST_SimpleStatement && node.body[0].body instanceof AST_String) {\n      body.unshift(to_moz(new AST_EmptyStatement(node.body[0])));\n    }\n    return {\n      type: type,\n      body: body\n    };\n  }\n})();","map":{"version":3,"names":["make_node","AST_Accessor","AST_Array","AST_Arrow","AST_Assign","AST_Atom","AST_Await","AST_BigInt","AST_Binary","AST_Block","AST_BlockStatement","AST_Boolean","AST_Break","AST_Call","AST_Case","AST_Catch","AST_Chain","AST_Class","AST_ClassStaticBlock","AST_ClassExpression","AST_ClassProperty","AST_ClassPrivateProperty","AST_ConciseMethod","AST_Conditional","AST_Const","AST_Constant","AST_Continue","AST_Debugger","AST_Default","AST_DefaultAssign","AST_DefClass","AST_DefinitionsLike","AST_Defun","AST_Destructuring","AST_Directive","AST_Do","AST_Dot","AST_DotHash","AST_EmptyStatement","AST_Expansion","AST_Export","AST_False","AST_Finally","AST_For","AST_ForIn","AST_ForOf","AST_Function","AST_Hole","AST_If","AST_Import","AST_ImportMeta","AST_Label","AST_LabeledStatement","AST_LabelRef","AST_Lambda","AST_Let","AST_NameMapping","AST_New","AST_NewTarget","AST_Node","AST_Null","AST_Number","AST_Object","AST_ObjectGetter","AST_ObjectKeyVal","AST_ObjectProperty","AST_ObjectSetter","AST_PrefixedTemplateString","AST_PrivateGetter","AST_PrivateMethod","AST_PrivateSetter","AST_PrivateIn","AST_PropAccess","AST_RegExp","AST_Return","AST_Sequence","AST_SimpleStatement","AST_Statement","AST_String","AST_Sub","AST_Super","AST_Switch","AST_SwitchBranch","AST_Symbol","AST_SymbolCatch","AST_SymbolClass","AST_SymbolClassProperty","AST_SymbolPrivateProperty","AST_SymbolConst","AST_SymbolDefClass","AST_SymbolDefun","AST_SymbolExport","AST_SymbolExportForeign","AST_SymbolFunarg","AST_SymbolImport","AST_SymbolImportForeign","AST_SymbolLambda","AST_SymbolLet","AST_SymbolMethod","AST_SymbolRef","AST_SymbolVar","AST_SymbolUsing","AST_TemplateSegment","AST_TemplateString","AST_This","AST_Throw","AST_Token","AST_Toplevel","AST_True","AST_Try","AST_TryBlock","AST_Unary","AST_UnaryPostfix","AST_UnaryPrefix","AST_Using","AST_UsingDef","AST_Var","AST_VarDef","AST_VarDefLike","AST_While","AST_With","AST_Yield","is_basic_identifier_string","normalize_directives","body","i","length","start","end","quote","value","import_attributes_from_moz","attributes","my_start_token","my_end_token","properties","map","attr","key","name","from_moz","MOZ_TO_ME","Program","M","ArrayPattern","names","elements","elm","is_array","ObjectPattern","AssignmentPattern","left","operator","right","SpreadElement","expression","argument","RestElement","TemplateElement","cooked","raw","TemplateLiteral","segments","quasis","push","expressions","TaggedTemplateExpression","template_string","quasi","prefix","tag","FunctionDeclaration","id","from_moz_symbol","argnames","params","from_moz_pattern","is_generator","generator","async","FunctionExpression","from_moz_lambda","ArrowFunctionExpression","type","p","ExpressionStatement","TryStatement","handlers","handler","guardedHandlers","Error","block","bcatch","bfinally","finalizer","Property","kind","method","args","computed","String","from_moz_quote","static","MethodDefinition","is_private","FieldDefinition","PropertyDefinition","PrivateIdentifier","StaticBlock","ArrayExpression","elem","ObjectExpression","prop","SequenceExpression","MemberExpression","property","object","optional","ChainExpression","SwitchCase","test","consequent","VariableDeclaration","decl_type","defs_type","sym_type","await_using","definitions","declarations","init","await","ImportDeclaration","imported_name","imported_names","specifiers","forEach","specifier","module_name","source","assertions","ImportSpecifier","foreign_name","imported","local","ImportDefaultSpecifier","ImportNamespaceSpecifier","ImportExpression","options","ExportAllDeclaration","exported","exported_names","ExportNamedDeclaration","declaration","exported_definition","ExportDefaultDeclaration","exported_value","is_default","ExportSpecifier","Literal","val","rx","regex","pattern","flags","rx_source","match","_","bi","toString","bigint","MetaProperty","meta","Identifier","EmptyStatement","BlockStatement","IfStatement","condition","alternative","alternate","LabeledStatement","label","FROM_MOZ_LABELS","stat","pop","BreakStatement","from_moz_label_ref","ContinueStatement","WithStatement","SwitchStatement","discriminant","cases","ReturnStatement","ThrowStatement","WhileStatement","DoWhileStatement","ForStatement","step","update","ForInStatement","ForOfStatement","AwaitExpression","YieldExpression","is_star","delegate","DebuggerStatement","CatchClause","argname","param","ThisExpression","Super","BinaryExpression","LogicalExpression","AssignmentExpression","logical","ConditionalExpression","NewExpression","callee","arguments","CallExpression","UpdateExpression","UnaryExpression","To_Moz_Unary","ClassDeclaration","ClassExpression","From_Moz_Class","extends","superClass","def_to_moz","To_Moz_EmptyStatement","To_Moz_BlockStatement","to_moz","To_Moz_IfStatement","To_Moz_LabeledStatement","To_Moz_BreakStatement","To_Moz_ContinueStatement","To_Moz_WithStatement","To_Moz_SwitchStatement","To_Moz_ReturnStatement","To_Moz_ThrowStatement","To_Moz_WhileStatement","To_Moz_DoWhileStatement","To_Moz_ForStatement","To_Moz_ForInStatement","To_Moz_ForOfStatement","To_Moz_AwaitExpression","To_Moz_YieldExpression","To_Moz_DebuggerStatement","To_Moz_VariableDeclarator","To_Moz_ThisExpression","To_Moz_Super","To_Moz_ConditionalExpression","To_Moz_NewExpression","To_Moz_CallExpression","To_Moz_Program","to_moz_scope","To_Moz_Spread","to_moz_in_destructuring","To_Moz_TaggedTemplateExpression","To_Moz_TemplateLiteral","tail","To_Moz_FunctionDeclaration","to_moz_pattern","To_Moz_FunctionExpression","To_Moz_ArrowFunctionExpression","To_Moz_ObjectPattern","computed_key","shorthand","to_moz_property_key","To_Moz_AssignmentExpression","To_Moz_Directive","print_to_string","directive","To_Moz_ExpressionStatement","To_Moz_SwitchCase","To_Moz_TryStatement","to_moz_block","To_Moz_CatchClause","To_Moz_VariableDeclaration","import_attributes_to_moz","attribute","import_attributes","key_moz","JSON","stringify","To_Moz_ExportDeclaration","first_exported","name_mapping","To_Moz_ImportDeclaration","first_imported_foreign_name","To_Moz_MetaProperty","To_Moz_SequenceExpression","To_Moz_PrivateMemberExpression","To_Moz_MemberExpression","isComputed","To_Moz_ChainExpression","To_Moz_BinaryExpression","To_Moz_BinaryExpression_PrivateIn","To_Moz_ArrayExpression","To_Moz_ObjectExpression","To_Moz_Property","parent","To_Moz_MethodDefinition","_always_false","To_Moz_Class","To_Moz_StaticBlock","To_Moz_Identifier","def","definition","mangled_name","To_Moz_RegExpLiteral","To_Moz_Literal","To_Moz_Atom","BigInt","DEFMETHOD","prototype","to_mozilla_ast","To_Moz_ArrayHole","moznode","loc","range","line","column","node","moz_key","symbol_type","has_quote","undefined","is_method","m_label","label_origin","thedef","from_mozilla_ast","save_labels","ast","set_moz_loc","mynode","pos","endpos","col","endline","endcol","file","mytype","TO_MOZ_STACK","key_name","TYPE","unshift"],"sources":["F:/landinghub-iconic/node_modules/.pnpm/terser@5.44.0/node_modules/terser/lib/mozilla-ast.js"],"sourcesContent":["/***********************************************************************\n\n  A JavaScript tokenizer / parser / beautifier / compressor.\n  https://github.com/mishoo/UglifyJS2\n\n  -------------------------------- (C) ---------------------------------\n\n                           Author: Mihai Bazon\n                         <mihai.bazon@gmail.com>\n                       http://mihai.bazon.net/blog\n\n  Distributed under the BSD license:\n\n    Copyright 2012 (c) Mihai Bazon <mihai.bazon@gmail.com>\n\n    Redistribution and use in source and binary forms, with or without\n    modification, are permitted provided that the following conditions\n    are met:\n\n        * Redistributions of source code must retain the above\n          copyright notice, this list of conditions and the following\n          disclaimer.\n\n        * Redistributions in binary form must reproduce the above\n          copyright notice, this list of conditions and the following\n          disclaimer in the documentation and/or other materials\n          provided with the distribution.\n\n    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER “AS IS” AND ANY\n    EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n    IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n    PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER BE\n    LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,\n    OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n    PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n    PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR\n    TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF\n    THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n    SUCH DAMAGE.\n\n ***********************************************************************/\n\nimport { make_node } from \"./utils/index.js\";\nimport {\n    AST_Accessor,\n    AST_Array,\n    AST_Arrow,\n    AST_Assign,\n    AST_Atom,\n    AST_Await,\n    AST_BigInt,\n    AST_Binary,\n    AST_Block,\n    AST_BlockStatement,\n    AST_Boolean,\n    AST_Break,\n    AST_Call,\n    AST_Case,\n    AST_Catch,\n    AST_Chain,\n    AST_Class,\n    AST_ClassStaticBlock,\n    AST_ClassExpression,\n    AST_ClassProperty,\n    AST_ClassPrivateProperty,\n    AST_ConciseMethod,\n    AST_Conditional,\n    AST_Const,\n    AST_Constant,\n    AST_Continue,\n    AST_Debugger,\n    AST_Default,\n    AST_DefaultAssign,\n    AST_DefClass,\n    AST_DefinitionsLike,\n    AST_Defun,\n    AST_Destructuring,\n    AST_Directive,\n    AST_Do,\n    AST_Dot,\n    AST_DotHash,\n    AST_EmptyStatement,\n    AST_Expansion,\n    AST_Export,\n    AST_False,\n    AST_Finally,\n    AST_For,\n    AST_ForIn,\n    AST_ForOf,\n    AST_Function,\n    AST_Hole,\n    AST_If,\n    AST_Import,\n    AST_ImportMeta,\n    AST_Label,\n    AST_LabeledStatement,\n    AST_LabelRef,\n    AST_Lambda,\n    AST_Let,\n    AST_NameMapping,\n    AST_New,\n    AST_NewTarget,\n    AST_Node,\n    AST_Null,\n    AST_Number,\n    AST_Object,\n    AST_ObjectGetter,\n    AST_ObjectKeyVal,\n    AST_ObjectProperty,\n    AST_ObjectSetter,\n    AST_PrefixedTemplateString,\n    AST_PrivateGetter,\n    AST_PrivateMethod,\n    AST_PrivateSetter,\n    AST_PrivateIn,\n    AST_PropAccess,\n    AST_RegExp,\n    AST_Return,\n    AST_Sequence,\n    AST_SimpleStatement,\n    AST_Statement,\n    AST_String,\n    AST_Sub,\n    AST_Super,\n    AST_Switch,\n    AST_SwitchBranch,\n    AST_Symbol,\n    AST_SymbolCatch,\n    AST_SymbolClass,\n    AST_SymbolClassProperty,\n    AST_SymbolPrivateProperty,\n    AST_SymbolConst,\n    AST_SymbolDefClass,\n    AST_SymbolDefun,\n    AST_SymbolExport,\n    AST_SymbolExportForeign,\n    AST_SymbolFunarg,\n    AST_SymbolImport,\n    AST_SymbolImportForeign,\n    AST_SymbolLambda,\n    AST_SymbolLet,\n    AST_SymbolMethod,\n    AST_SymbolRef,\n    AST_SymbolVar,\n    AST_SymbolUsing,\n    AST_TemplateSegment,\n    AST_TemplateString,\n    AST_This,\n    AST_Throw,\n    AST_Token,\n    AST_Toplevel,\n    AST_True,\n    AST_Try,\n    AST_TryBlock,\n    AST_Unary,\n    AST_UnaryPostfix,\n    AST_UnaryPrefix,\n    AST_Using,\n    AST_UsingDef,\n    AST_Var,\n    AST_VarDef,\n    AST_VarDefLike,\n    AST_While,\n    AST_With,\n    AST_Yield,\n} from \"./ast.js\";\nimport { is_basic_identifier_string } from \"./parse.js\";\n\n(function() {\n\n    var normalize_directives = function(body) {\n        for (var i = 0; i < body.length; i++) {\n            if (body[i] instanceof AST_Statement && body[i].body instanceof AST_String) {\n                body[i] = new AST_Directive({\n                    start: body[i].start,\n                    end: body[i].end,\n                    quote: '\"',\n                    value: body[i].body.value\n                });\n            } else {\n                return body;\n            }\n        }\n\n        return body;\n    };\n\n    function import_attributes_from_moz(attributes) {\n        if (attributes && attributes.length > 0) {\n            return new AST_Object({\n                start: my_start_token(attributes),\n                end: my_end_token(attributes),\n                properties: attributes.map((attr) =>\n                    new AST_ObjectKeyVal({\n                        start: my_start_token(attr),\n                        end: my_end_token(attr),\n                        key: attr.key.name || attr.key.value,\n                        value: from_moz(attr.value)\n                    })\n                )\n            });\n        }\n        return null;\n    }\n\n    var MOZ_TO_ME = {\n        Program: function(M) {\n            return new AST_Toplevel({\n                start: my_start_token(M),\n                end: my_end_token(M),\n                body: normalize_directives(M.body.map(from_moz))\n            });\n        },\n\n        ArrayPattern: function(M) {\n            return new AST_Destructuring({\n                start: my_start_token(M),\n                end: my_end_token(M),\n                names: M.elements.map(function(elm) {\n                    if (elm === null) {\n                        return new AST_Hole();\n                    }\n                    return from_moz(elm);\n                }),\n                is_array: true\n            });\n        },\n\n        ObjectPattern: function(M) {\n            return new AST_Destructuring({\n                start: my_start_token(M),\n                end: my_end_token(M),\n                names: M.properties.map(from_moz),\n                is_array: false\n            });\n        },\n\n        AssignmentPattern: function(M) {\n            return new AST_DefaultAssign({\n                start: my_start_token(M),\n                end: my_end_token(M),\n                left: from_moz(M.left),\n                operator: \"=\",\n                right: from_moz(M.right)\n            });\n        },\n\n        SpreadElement: function(M) {\n            return new AST_Expansion({\n                start: my_start_token(M),\n                end: my_end_token(M),\n                expression: from_moz(M.argument)\n            });\n        },\n\n        RestElement: function(M) {\n            return new AST_Expansion({\n                start: my_start_token(M),\n                end: my_end_token(M),\n                expression: from_moz(M.argument)\n            });\n        },\n\n        TemplateElement: function(M) {\n            return new AST_TemplateSegment({\n                start: my_start_token(M),\n                end: my_end_token(M),\n                value: M.value.cooked,\n                raw: M.value.raw\n            });\n        },\n\n        TemplateLiteral: function(M) {\n            var segments = [];\n            for (var i = 0; i < M.quasis.length; i++) {\n                segments.push(from_moz(M.quasis[i]));\n                if (M.expressions[i]) {\n                    segments.push(from_moz(M.expressions[i]));\n                }\n            }\n            return new AST_TemplateString({\n                start: my_start_token(M),\n                end: my_end_token(M),\n                segments: segments\n            });\n        },\n\n        TaggedTemplateExpression: function(M) {\n            return new AST_PrefixedTemplateString({\n                start: my_start_token(M),\n                end: my_end_token(M),\n                template_string: from_moz(M.quasi),\n                prefix: from_moz(M.tag)\n            });\n        },\n\n        FunctionDeclaration: function(M) {\n            return new AST_Defun({\n                start: my_start_token(M),\n                end: my_end_token(M),\n                name: M.id && from_moz_symbol(AST_SymbolDefun, M.id),\n                argnames: M.params.map(M => from_moz_pattern(M, AST_SymbolFunarg)),\n                is_generator: M.generator,\n                async: M.async,\n                body: normalize_directives(from_moz(M.body).body)\n            });\n        },\n\n        FunctionExpression: function(M) {\n            return from_moz_lambda(M, /*is_method=*/false);\n        },\n\n        ArrowFunctionExpression: function(M) {\n            const body = M.body.type === \"BlockStatement\"\n                ? from_moz(M.body).body\n                : [make_node(AST_Return, {}, { value: from_moz(M.body) })];\n            return new AST_Arrow({\n                start: my_start_token(M),\n                end: my_end_token(M),\n                argnames: M.params.map(p => from_moz_pattern(p, AST_SymbolFunarg)),\n                body,\n                async: M.async,\n            });\n        },\n\n        ExpressionStatement: function(M) {\n            return new AST_SimpleStatement({\n                start: my_start_token(M),\n                end: my_end_token(M),\n                body: from_moz(M.expression)\n            });\n        },\n\n        TryStatement: function(M) {\n            var handlers = M.handlers || [M.handler];\n            if (handlers.length > 1 || M.guardedHandlers && M.guardedHandlers.length) {\n                throw new Error(\"Multiple catch clauses are not supported.\");\n            }\n            return new AST_Try({\n                start    : my_start_token(M),\n                end      : my_end_token(M),\n                body     : new AST_TryBlock(from_moz(M.block)),\n                bcatch   : from_moz(handlers[0]),\n                bfinally : M.finalizer ? new AST_Finally(from_moz(M.finalizer)) : null\n            });\n        },\n\n        Property: function(M) {\n            if (M.kind == \"init\" && !M.method) {\n                var args = {\n                    start    : my_start_token(M.key || M.value),\n                    end      : my_end_token(M.value),\n                    key      : M.computed\n                                ? from_moz(M.key)\n                                : M.key.name || String(M.key.value),\n                    quote    : from_moz_quote(M.key, M.computed),\n                    static   : false, // always an object\n                    value    : from_moz(M.value)\n                };\n\n                return new AST_ObjectKeyVal(args);\n            } else {\n                var value = from_moz_lambda(M.value, /*is_method=*/true);\n                var args = {\n                    start    : my_start_token(M.key || M.value),\n                    end      : my_end_token(M.value),\n                    key      : M.computed\n                                ? from_moz(M.key)\n                                : from_moz_symbol(AST_SymbolMethod, M.key),\n                    quote    : from_moz_quote(M.key, M.computed),\n                    static   : false, // always an object\n                    value,\n                };\n\n                if (M.kind == \"get\") return new AST_ObjectGetter(args);\n                if (M.kind == \"set\") return new AST_ObjectSetter(args);\n                if (M.method) return new AST_ConciseMethod(args);\n            }\n        },\n\n        MethodDefinition: function(M) {\n            const is_private = M.key.type === \"PrivateIdentifier\";\n            const key = M.computed ? from_moz(M.key) : new AST_SymbolMethod({ name: M.key.name || String(M.key.value) });\n\n            var args = {\n                start    : my_start_token(M),\n                end      : my_end_token(M),\n                key,\n                quote    : from_moz_quote(M.key, M.computed),\n                value    : from_moz_lambda(M.value, /*is_method=*/true),\n                static   : M.static,\n            };\n            if (M.kind == \"get\") {\n                return new (is_private ? AST_PrivateGetter : AST_ObjectGetter)(args);\n            }\n            if (M.kind == \"set\") {\n                return new (is_private ? AST_PrivateSetter : AST_ObjectSetter)(args);\n            }\n            return new (is_private ? AST_PrivateMethod : AST_ConciseMethod)(args);\n        },\n\n        FieldDefinition: function(M) {\n            let key;\n            if (M.computed) {\n                key = from_moz(M.key);\n            } else {\n                if (M.key.type !== \"Identifier\") throw new Error(\"Non-Identifier key in FieldDefinition\");\n                key = from_moz(M.key);\n            }\n            return new AST_ClassProperty({\n                start    : my_start_token(M),\n                end      : my_end_token(M),\n                quote    : from_moz_quote(M.key, M.computed),\n                key,\n                value    : from_moz(M.value),\n                static   : M.static,\n            });\n        },\n\n        PropertyDefinition: function(M) {\n            let key;\n            if (M.computed) {\n                key = from_moz(M.key);\n            } else if (M.key.type === \"PrivateIdentifier\") {\n                return new AST_ClassPrivateProperty({\n                    start    : my_start_token(M),\n                    end      : my_end_token(M),\n                    key      : from_moz(M.key),\n                    value    : from_moz(M.value),\n                    static   : M.static,\n                });\n            } else {\n                key = from_moz_symbol(AST_SymbolClassProperty, M.key);\n            }\n\n            return new AST_ClassProperty({\n                start    : my_start_token(M),\n                end      : my_end_token(M),\n                quote    : from_moz_quote(M.key, M.computed),\n                key,\n                value    : from_moz(M.value),\n                static   : M.static,\n            });\n        },\n\n        PrivateIdentifier: function (M) {\n            return new AST_SymbolPrivateProperty({\n                start: my_start_token(M),\n                end: my_end_token(M),\n                name: M.name\n            });\n        },\n\n        StaticBlock: function(M) {\n            return new AST_ClassStaticBlock({\n                start : my_start_token(M),\n                end   : my_end_token(M),\n                body  : M.body.map(from_moz),\n            });\n        },\n\n        ArrayExpression: function(M) {\n            return new AST_Array({\n                start    : my_start_token(M),\n                end      : my_end_token(M),\n                elements : M.elements.map(function(elem) {\n                    return elem === null ? new AST_Hole() : from_moz(elem);\n                })\n            });\n        },\n\n        ObjectExpression: function(M) {\n            return new AST_Object({\n                start      : my_start_token(M),\n                end        : my_end_token(M),\n                properties : M.properties.map(function(prop) {\n                    if (prop.type === \"SpreadElement\") {\n                        return from_moz(prop);\n                    }\n                    prop.type = \"Property\";\n                    return from_moz(prop);\n                })\n            });\n        },\n\n        SequenceExpression: function(M) {\n            return new AST_Sequence({\n                start      : my_start_token(M),\n                end        : my_end_token(M),\n                expressions: M.expressions.map(from_moz)\n            });\n        },\n\n        MemberExpression: function(M) {\n            if (M.property.type === \"PrivateIdentifier\") {\n                return new AST_DotHash({\n                    start      : my_start_token(M),\n                    end        : my_end_token(M),\n                    property   : M.property.name,\n                    expression : from_moz(M.object),\n                    optional   : M.optional || false\n                });\n            }\n            return new (M.computed ? AST_Sub : AST_Dot)({\n                start      : my_start_token(M),\n                end        : my_end_token(M),\n                property   : M.computed ? from_moz(M.property) : M.property.name,\n                expression : from_moz(M.object),\n                optional   : M.optional || false\n            });\n        },\n\n        ChainExpression: function(M) {\n            return new AST_Chain({\n                start      : my_start_token(M),\n                end        : my_end_token(M),\n                expression : from_moz(M.expression)\n            });\n        },\n\n        SwitchCase: function(M) {\n            return new (M.test ? AST_Case : AST_Default)({\n                start      : my_start_token(M),\n                end        : my_end_token(M),\n                expression : from_moz(M.test),\n                body       : M.consequent.map(from_moz)\n            });\n        },\n\n        VariableDeclaration: function(M) {\n            let decl_type;\n            let defs_type = AST_VarDef;\n            let sym_type;\n            let await_using = false;\n            if (M.kind === \"const\") {\n                decl_type = AST_Const;\n                sym_type = AST_SymbolConst;\n            } else if (M.kind === \"let\") {\n                decl_type = AST_Let;\n                sym_type = AST_SymbolLet;\n            } else if (M.kind === \"using\") {\n                decl_type = AST_Using;\n                defs_type = AST_UsingDef;\n                sym_type = AST_SymbolUsing;\n            } else if (M.kind === \"await using\") {\n                decl_type = AST_Using;\n                defs_type = AST_UsingDef;\n                sym_type = AST_SymbolUsing;\n                await_using = true;\n            } else {\n                decl_type = AST_Var;\n                sym_type = AST_SymbolVar;\n            }\n            const definitions = M.declarations.map(M => {\n                return new defs_type({\n                    start: my_start_token(M),\n                    end: my_end_token(M),\n                    name: from_moz_pattern(M.id, sym_type),\n                    value: from_moz(M.init),\n                });\n            });\n            return new decl_type({\n                start       : my_start_token(M),\n                end         : my_end_token(M),\n                definitions : definitions,\n                await       : await_using,\n            });\n        },\n\n        ImportDeclaration: function(M) {\n            var imported_name = null;\n            var imported_names = null;\n            M.specifiers.forEach(function (specifier) {\n                if (specifier.type === \"ImportSpecifier\" || specifier.type === \"ImportNamespaceSpecifier\") {\n                    if (!imported_names) { imported_names = []; }\n                    imported_names.push(from_moz(specifier));\n                } else if (specifier.type === \"ImportDefaultSpecifier\") {\n                    imported_name = from_moz(specifier);\n                }\n            });\n            return new AST_Import({\n                start       : my_start_token(M),\n                end         : my_end_token(M),\n                imported_name: imported_name,\n                imported_names : imported_names,\n                module_name : from_moz(M.source),\n                attributes: import_attributes_from_moz(M.attributes || M.assertions)\n            });\n        },\n\n        ImportSpecifier: function(M) {\n            return new AST_NameMapping({\n                start: my_start_token(M),\n                end: my_end_token(M),\n                foreign_name: from_moz_symbol(AST_SymbolImportForeign, M.imported, M.imported.type === \"Literal\"),\n                name: from_moz_symbol(AST_SymbolImport, M.local)\n            });\n        },\n\n        ImportDefaultSpecifier: function(M) {\n            return from_moz_symbol(AST_SymbolImport, M.local);\n        },\n\n        ImportNamespaceSpecifier: function(M) {\n            return new AST_NameMapping({\n                start: my_start_token(M),\n                end: my_end_token(M),\n                foreign_name: new AST_SymbolImportForeign({ name: \"*\" }),\n                name: from_moz_symbol(AST_SymbolImport, M.local)\n            });\n        },\n\n        ImportExpression: function(M) {\n            const args = [from_moz(M.source)];\n            if (M.options) {\n                args.push(from_moz(M.options));\n            }\n            return new AST_Call({\n                start: my_start_token(M),\n                end: my_end_token(M),\n                expression: from_moz({\n                    type: \"Identifier\",\n                    name: \"import\"\n                }),\n                optional: false,\n                args\n            });\n        },\n\n        ExportAllDeclaration: function(M) {\n            var foreign_name = M.exported == null ?\n                new AST_SymbolExportForeign({ name: \"*\" }) :\n                from_moz_symbol(AST_SymbolExportForeign, M.exported, M.exported.type === \"Literal\");\n            return new AST_Export({\n                start: my_start_token(M),\n                end: my_end_token(M),\n                exported_names: [\n                    new AST_NameMapping({\n                        start: my_start_token(M),\n                        end: my_end_token(M),\n                        name: new AST_SymbolExport({ name: \"*\" }),\n                        foreign_name: foreign_name\n                    })\n                ],\n                module_name: from_moz(M.source),\n                attributes: import_attributes_from_moz(M.attributes || M.assertions)\n            });\n        },\n\n        ExportNamedDeclaration: function(M) {\n            if (M.declaration) {\n                // export const, export function, ...\n                return new AST_Export({\n                    start: my_start_token(M),\n                    end: my_end_token(M),\n                    exported_definition: from_moz(M.declaration),\n                    exported_names: null,\n                    module_name: null,\n                    attributes: null,\n                });\n            } else {\n                return new AST_Export({\n                    start: my_start_token(M),\n                    end: my_end_token(M),\n                    exported_definition: null,\n                    exported_names: M.specifiers && M.specifiers.length ? M.specifiers.map(from_moz) : [],\n                    module_name: from_moz(M.source),\n                    attributes: import_attributes_from_moz(M.attributes || M.assertions),\n                });\n            }\n        },\n\n        ExportDefaultDeclaration: function(M) {\n            return new AST_Export({\n                start: my_start_token(M),\n                end: my_end_token(M),\n                exported_value: from_moz(M.declaration),\n                is_default: true\n            });\n        },\n\n        ExportSpecifier: function(M) {\n            return new AST_NameMapping({\n                start: my_start_token(M),\n                end: my_end_token(M),\n                foreign_name: from_moz_symbol(AST_SymbolExportForeign, M.exported, M.exported.type === \"Literal\"),\n                name: from_moz_symbol(AST_SymbolExport, M.local, M.local.type === \"Literal\"),\n            });\n        },\n\n        Literal: function(M) {\n            var val = M.value, args = {\n                start  : my_start_token(M),\n                end    : my_end_token(M)\n            };\n            var rx = M.regex;\n            if (rx && rx.pattern) {\n                // RegExpLiteral as per ESTree AST spec\n                args.value = {\n                    source: rx.pattern,\n                    flags: rx.flags\n                };\n                return new AST_RegExp(args);\n            } else if (rx) {\n                // support legacy RegExp\n                const rx_source = M.raw || val;\n                const match = rx_source.match(/^\\/(.*)\\/(\\w*)$/);\n                if (!match) throw new Error(\"Invalid regex source \" + rx_source);\n                const [_, source, flags] = match;\n                args.value = { source, flags };\n                return new AST_RegExp(args);\n            }\n            const bi = typeof M.value === \"bigint\" ? M.value.toString() : M.bigint;\n            if (typeof bi === \"string\") {\n                args.value = bi;\n                args.raw = M.raw;\n                return new AST_BigInt(args);\n            }\n            if (val === null) return new AST_Null(args);\n            switch (typeof val) {\n              case \"string\":\n                args.quote = \"\\\"\";\n                args.value = val;\n                return new AST_String(args);\n              case \"number\":\n                args.value = val;\n                args.raw = M.raw || val.toString();\n                return new AST_Number(args);\n              case \"boolean\":\n                return new (val ? AST_True : AST_False)(args);\n            }\n        },\n\n        MetaProperty: function(M) {\n            if (M.meta.name === \"new\" && M.property.name === \"target\") {\n                return new AST_NewTarget({\n                    start: my_start_token(M),\n                    end: my_end_token(M)\n                });\n            } else if (M.meta.name === \"import\" && M.property.name === \"meta\") {\n                return new AST_ImportMeta({\n                    start: my_start_token(M),\n                    end: my_end_token(M)\n                });\n            }\n        },\n\n        Identifier: function(M) {\n            return new AST_SymbolRef({\n                start : my_start_token(M),\n                end   : my_end_token(M),\n                name  : M.name\n            });\n        },\n\n        EmptyStatement: function(M) {\n            return new AST_EmptyStatement({\n                start: my_start_token(M),\n                end: my_end_token(M)\n            });\n        },\n\n        BlockStatement: function(M) {\n            return new AST_BlockStatement({\n                start: my_start_token(M),\n                end: my_end_token(M),\n                body: M.body.map(from_moz)\n            });\n        },\n\n        IfStatement: function(M) {\n            return new AST_If({\n                start: my_start_token(M),\n                end: my_end_token(M),\n                condition: from_moz(M.test),\n                body: from_moz(M.consequent),\n                alternative: from_moz(M.alternate)\n            });\n        },\n\n        LabeledStatement: function(M) {\n            try {\n                const label = from_moz_symbol(AST_Label, M.label);\n                FROM_MOZ_LABELS.push(label);\n\n                const stat = new AST_LabeledStatement({\n                    start: my_start_token(M),\n                    end: my_end_token(M),\n                    label,\n                    body: from_moz(M.body)\n                });\n\n                return stat;\n            } finally {\n                FROM_MOZ_LABELS.pop();\n            }\n        },\n\n        BreakStatement: function(M) {\n            return new AST_Break({\n                start: my_start_token(M),\n                end: my_end_token(M),\n                label: from_moz_label_ref(M.label),\n            });\n        },\n\n        ContinueStatement: function(M) {\n            return new AST_Continue({\n                start: my_start_token(M),\n                end: my_end_token(M),\n                label: from_moz_label_ref(M.label),\n            });\n        },\n\n        WithStatement: function(M) {\n            return new AST_With({\n                start: my_start_token(M),\n                end: my_end_token(M),\n                expression: from_moz(M.object),\n                body: from_moz(M.body)\n            });\n        },\n\n        SwitchStatement: function(M) {\n            return new AST_Switch({\n                start: my_start_token(M),\n                end: my_end_token(M),\n                expression: from_moz(M.discriminant),\n                body: M.cases.map(from_moz)\n            });\n        },\n\n        ReturnStatement: function(M) {\n            return new AST_Return({\n                start: my_start_token(M),\n                end: my_end_token(M),\n                value: from_moz(M.argument)\n            });\n        },\n\n        ThrowStatement: function(M) {\n            return new AST_Throw({\n                start: my_start_token(M),\n                end: my_end_token(M),\n                value: from_moz(M.argument)\n            });\n        },\n\n        WhileStatement: function(M) {\n            return new AST_While({\n                start: my_start_token(M),\n                end: my_end_token(M),\n                condition: from_moz(M.test),\n                body: from_moz(M.body)\n            });\n        },\n\n        DoWhileStatement: function(M) {\n            return new AST_Do({\n                start: my_start_token(M),\n                end: my_end_token(M),\n                condition: from_moz(M.test),\n                body: from_moz(M.body)\n            });\n        },\n\n        ForStatement: function(M) {\n            return new AST_For({\n                start: my_start_token(M),\n                end: my_end_token(M),\n                init: from_moz(M.init),\n                condition: from_moz(M.test),\n                step: from_moz(M.update),\n                body: from_moz(M.body)\n            });\n        },\n\n        ForInStatement: function(M) {\n            return new AST_ForIn({\n                start: my_start_token(M),\n                end: my_end_token(M),\n                init: from_moz(M.left),\n                object: from_moz(M.right),\n                body: from_moz(M.body)\n            });\n        },\n\n        ForOfStatement: function(M) {\n            return new AST_ForOf({\n                start: my_start_token(M),\n                end: my_end_token(M),\n                init: from_moz(M.left),\n                object: from_moz(M.right),\n                body: from_moz(M.body),\n                await: M.await\n            });\n        },\n\n        AwaitExpression: function(M) {\n            return new AST_Await({\n                start: my_start_token(M),\n                end: my_end_token(M),\n                expression: from_moz(M.argument)\n            });\n        },\n\n        YieldExpression: function(M) {\n            return new AST_Yield({\n                start: my_start_token(M),\n                end: my_end_token(M),\n                expression: from_moz(M.argument),\n                is_star: M.delegate\n            });\n        },\n\n        DebuggerStatement: function(M) {\n            return new AST_Debugger({\n                start: my_start_token(M),\n                end: my_end_token(M)\n            });\n        },\n\n        CatchClause: function(M) {\n            return new AST_Catch({\n                start: my_start_token(M),\n                end: my_end_token(M),\n                argname: M.param ? from_moz_pattern(M.param, AST_SymbolCatch) : null,\n                body: from_moz(M.body).body\n            });\n        },\n\n        ThisExpression: function(M) {\n            return new AST_This({\n                start: my_start_token(M),\n                name: \"this\",\n                end: my_end_token(M)\n            });\n        },\n\n        Super: function(M) {\n            return new AST_Super({\n                start: my_start_token(M),\n                end: my_end_token(M),\n                name: \"super\",\n            });\n        },\n\n        BinaryExpression: function(M) {\n            if (M.left.type === \"PrivateIdentifier\") {\n                return new AST_PrivateIn({\n                    start: my_start_token(M),\n                    end: my_end_token(M),\n                    key: new AST_SymbolPrivateProperty({\n                        start: my_start_token(M.left),\n                        end: my_end_token(M.left),\n                        name: M.left.name\n                    }),\n                    value: from_moz(M.right),\n                });\n            }\n            return new AST_Binary({\n                start: my_start_token(M),\n                end: my_end_token(M),\n                operator: M.operator,\n                left: from_moz(M.left),\n                right: from_moz(M.right)\n            });\n        },\n\n        LogicalExpression: function(M) {\n            return new AST_Binary({\n                start: my_start_token(M),\n                end: my_end_token(M),\n                operator: M.operator,\n                left: from_moz(M.left),\n                right: from_moz(M.right)\n            });\n        },\n\n        AssignmentExpression: function(M) {\n            return new AST_Assign({\n                start: my_start_token(M),\n                end: my_end_token(M),\n                operator: M.operator,\n                logical: M.operator === \"??=\" || M.operator === \"&&=\" || M.operator === \"||=\",\n                left: from_moz(M.left),\n                right: from_moz(M.right)\n            });\n        },\n\n        ConditionalExpression: function(M) {\n            return new AST_Conditional({\n                start: my_start_token(M),\n                end: my_end_token(M),\n                condition: from_moz(M.test),\n                consequent: from_moz(M.consequent),\n                alternative: from_moz(M.alternate)\n            });\n        },\n\n        NewExpression: function(M) {\n            return new AST_New({\n                start: my_start_token(M),\n                end: my_end_token(M),\n                expression: from_moz(M.callee),\n                args: M.arguments.map(from_moz)\n            });\n        },\n\n        CallExpression: function(M) {\n            return new AST_Call({\n                start: my_start_token(M),\n                end: my_end_token(M),\n                expression: from_moz(M.callee),\n                optional: M.optional,\n                args: M.arguments.map(from_moz)\n            });\n        }\n    };\n\n    MOZ_TO_ME.UpdateExpression =\n    MOZ_TO_ME.UnaryExpression = function To_Moz_Unary(M) {\n        var prefix = \"prefix\" in M ? M.prefix\n            : M.type == \"UnaryExpression\" ? true : false;\n        return new (prefix ? AST_UnaryPrefix : AST_UnaryPostfix)({\n            start      : my_start_token(M),\n            end        : my_end_token(M),\n            operator   : M.operator,\n            expression : from_moz(M.argument)\n        });\n    };\n\n    MOZ_TO_ME.ClassDeclaration =\n    MOZ_TO_ME.ClassExpression = function From_Moz_Class(M) {\n        return new (M.type === \"ClassDeclaration\" ? AST_DefClass : AST_ClassExpression)({\n            start    : my_start_token(M),\n            end      : my_end_token(M),\n            name     : M.id && from_moz_symbol(M.type === \"ClassDeclaration\" ? AST_SymbolDefClass : AST_SymbolClass, M.id),\n            extends  : from_moz(M.superClass),\n            properties: M.body.body.map(from_moz)\n        });\n    };\n\n    def_to_moz(AST_EmptyStatement, function To_Moz_EmptyStatement() {\n        return {\n            type: \"EmptyStatement\"\n        };\n    });\n    def_to_moz(AST_BlockStatement, function To_Moz_BlockStatement(M) {\n        return {\n            type: \"BlockStatement\",\n            body: M.body.map(to_moz)\n        };\n    });\n    def_to_moz(AST_If, function To_Moz_IfStatement(M) {\n        return {\n            type: \"IfStatement\",\n            test: to_moz(M.condition),\n            consequent: to_moz(M.body),\n            alternate: to_moz(M.alternative)\n        };\n    });\n    def_to_moz(AST_LabeledStatement, function To_Moz_LabeledStatement(M) {\n        return {\n            type: \"LabeledStatement\",\n            label: to_moz(M.label),\n            body: to_moz(M.body)\n        };\n    });\n    def_to_moz(AST_Break, function To_Moz_BreakStatement(M) {\n        return {\n            type: \"BreakStatement\",\n            label: to_moz(M.label)\n        };\n    });\n    def_to_moz(AST_Continue, function To_Moz_ContinueStatement(M) {\n        return {\n            type: \"ContinueStatement\",\n            label: to_moz(M.label)\n        };\n    });\n    def_to_moz(AST_With, function To_Moz_WithStatement(M) {\n        return {\n            type: \"WithStatement\",\n            object: to_moz(M.expression),\n            body: to_moz(M.body)\n        };\n    });\n    def_to_moz(AST_Switch, function To_Moz_SwitchStatement(M) {\n        return {\n            type: \"SwitchStatement\",\n            discriminant: to_moz(M.expression),\n            cases: M.body.map(to_moz)\n        };\n    });\n    def_to_moz(AST_Return, function To_Moz_ReturnStatement(M) {\n        return {\n            type: \"ReturnStatement\",\n            argument: to_moz(M.value)\n        };\n    });\n    def_to_moz(AST_Throw, function To_Moz_ThrowStatement(M) {\n        return {\n            type: \"ThrowStatement\",\n            argument: to_moz(M.value)\n        };\n    });\n    def_to_moz(AST_While, function To_Moz_WhileStatement(M) {\n        return {\n            type: \"WhileStatement\",\n            test: to_moz(M.condition),\n            body: to_moz(M.body)\n        };\n    });\n    def_to_moz(AST_Do, function To_Moz_DoWhileStatement(M) {\n        return {\n            type: \"DoWhileStatement\",\n            test: to_moz(M.condition),\n            body: to_moz(M.body)\n        };\n    });\n    def_to_moz(AST_For, function To_Moz_ForStatement(M) {\n        return {\n            type: \"ForStatement\",\n            init: to_moz(M.init),\n            test: to_moz(M.condition),\n            update: to_moz(M.step),\n            body: to_moz(M.body)\n        };\n    });\n    def_to_moz(AST_ForIn, function To_Moz_ForInStatement(M) {\n        return {\n            type: \"ForInStatement\",\n            left: to_moz(M.init),\n            right: to_moz(M.object),\n            body: to_moz(M.body)\n        };\n    });\n    def_to_moz(AST_ForOf, function To_Moz_ForOfStatement(M) {\n        return {\n            type: \"ForOfStatement\",\n            left: to_moz(M.init),\n            right: to_moz(M.object),\n            body: to_moz(M.body),\n            await: M.await\n        };\n    });\n    def_to_moz(AST_Await, function To_Moz_AwaitExpression(M) {\n        return {\n            type: \"AwaitExpression\",\n            argument: to_moz(M.expression)\n        };\n    });\n    def_to_moz(AST_Yield, function To_Moz_YieldExpression(M) {\n        return {\n            type: \"YieldExpression\",\n            argument: to_moz(M.expression),\n            delegate: M.is_star\n        };\n    });\n    def_to_moz(AST_Debugger, function To_Moz_DebuggerStatement() {\n        return {\n            type: \"DebuggerStatement\"\n        };\n    });\n    def_to_moz(AST_VarDefLike, function To_Moz_VariableDeclarator(M) {\n        return {\n            type: \"VariableDeclarator\",\n            id: to_moz(M.name),\n            init: to_moz(M.value)\n        };\n    });\n\n    def_to_moz(AST_This, function To_Moz_ThisExpression() {\n        return {\n            type: \"ThisExpression\"\n        };\n    });\n    def_to_moz(AST_Super, function To_Moz_Super() {\n        return {\n            type: \"Super\"\n        };\n    });\n    def_to_moz(AST_Conditional, function To_Moz_ConditionalExpression(M) {\n        return {\n            type: \"ConditionalExpression\",\n            test: to_moz(M.condition),\n            consequent: to_moz(M.consequent),\n            alternate: to_moz(M.alternative)\n        };\n    });\n    def_to_moz(AST_New, function To_Moz_NewExpression(M) {\n        return {\n            type: \"NewExpression\",\n            callee: to_moz(M.expression),\n            arguments: M.args.map(to_moz)\n        };\n    });\n    def_to_moz(AST_Call, function To_Moz_CallExpression(M) {\n        if (M.expression instanceof AST_SymbolRef && M.expression.name === \"import\") {\n            const [source, options] = M.args.map(to_moz);\n            return {\n                type: \"ImportExpression\",\n                source,\n                options: options || null\n            };\n        }\n\n        return {\n            type: \"CallExpression\",\n            callee: to_moz(M.expression),\n            optional: M.optional,\n            arguments: M.args.map(to_moz)\n        };\n    });\n\n    def_to_moz(AST_Toplevel, function To_Moz_Program(M) {\n        return to_moz_scope(\"Program\", M);\n    });\n\n    def_to_moz(AST_Expansion, function To_Moz_Spread(M) {\n        return {\n            type: to_moz_in_destructuring() ? \"RestElement\" : \"SpreadElement\",\n            argument: to_moz(M.expression)\n        };\n    });\n\n    def_to_moz(AST_PrefixedTemplateString, function To_Moz_TaggedTemplateExpression(M) {\n        return {\n            type: \"TaggedTemplateExpression\",\n            tag: to_moz(M.prefix),\n            quasi: to_moz(M.template_string)\n        };\n    });\n\n    def_to_moz(AST_TemplateString, function To_Moz_TemplateLiteral(M) {\n        var quasis = [];\n        var expressions = [];\n        for (var i = 0; i < M.segments.length; i++) {\n            if (i % 2 !== 0) {\n                expressions.push(to_moz(M.segments[i]));\n            } else {\n                quasis.push({\n                    type: \"TemplateElement\",\n                    value: {\n                        raw: M.segments[i].raw,\n                        cooked: M.segments[i].value\n                    },\n                    tail: i === M.segments.length - 1\n                });\n            }\n        }\n        return {\n            type: \"TemplateLiteral\",\n            quasis: quasis,\n            expressions: expressions\n        };\n    });\n\n    def_to_moz(AST_Defun, function To_Moz_FunctionDeclaration(M) {\n        return {\n            type: \"FunctionDeclaration\",\n            id: to_moz(M.name),\n            params: M.argnames.map(to_moz_pattern),\n            generator: M.is_generator,\n            async: M.async,\n            body: to_moz_scope(\"BlockStatement\", M)\n        };\n    });\n\n    def_to_moz(AST_Function, function To_Moz_FunctionExpression(M) {\n        return {\n            type: \"FunctionExpression\",\n            id: to_moz(M.name),\n            params: M.argnames.map(to_moz_pattern),\n            generator: M.is_generator || false,\n            async: M.async || false,\n            body: to_moz_scope(\"BlockStatement\", M)\n        };\n    });\n\n    def_to_moz(AST_Arrow, function To_Moz_ArrowFunctionExpression(M) {\n        var body = M.body.length === 1 && M.body[0] instanceof AST_Return && M.body[0].value\n            ? to_moz(M.body[0].value)\n            : {\n                type: \"BlockStatement\",\n                body: M.body.map(to_moz)\n            };\n        return {\n            type: \"ArrowFunctionExpression\",\n            params: M.argnames.map(to_moz_pattern),\n            async: M.async,\n            body: body,\n        };\n    });\n\n    def_to_moz(AST_Destructuring, function To_Moz_ObjectPattern(M) {\n        if (M.is_array) {\n            return {\n                type: \"ArrayPattern\",\n                elements: M.names.map(\n                    M => M instanceof AST_Hole ? null : to_moz_pattern(M)\n                ),\n            };\n        }\n        return {\n            type: \"ObjectPattern\",\n            properties: M.names.map(M => {\n                if (M instanceof AST_ObjectKeyVal) {\n                    var computed = M.computed_key();\n                    const [shorthand, key] = to_moz_property_key(M.key, computed, M.quote, M.value);\n\n                    return {\n                        type: \"Property\",\n                        computed,\n                        kind: \"init\",\n                        key: key,\n                        method: false,\n                        shorthand,\n                        value: to_moz_pattern(M.value)\n                    };\n                } else {\n                    return to_moz_pattern(M);\n                }\n            }),\n        };\n    });\n\n    def_to_moz(AST_DefaultAssign, function To_Moz_AssignmentExpression(M) {\n        return {\n            type: \"AssignmentPattern\",\n            left: to_moz_pattern(M.left),\n            right: to_moz(M.right),\n        };\n    });\n\n    def_to_moz(AST_Directive, function To_Moz_Directive(M) {\n        return {\n            type: \"ExpressionStatement\",\n            expression: {\n                type: \"Literal\",\n                value: M.value,\n                raw: M.print_to_string()\n            },\n            directive: M.value\n        };\n    });\n\n    def_to_moz(AST_SimpleStatement, function To_Moz_ExpressionStatement(M) {\n        return {\n            type: \"ExpressionStatement\",\n            expression: to_moz(M.body)\n        };\n    });\n\n    def_to_moz(AST_SwitchBranch, function To_Moz_SwitchCase(M) {\n        return {\n            type: \"SwitchCase\",\n            test: to_moz(M.expression),\n            consequent: M.body.map(to_moz)\n        };\n    });\n\n    def_to_moz(AST_Try, function To_Moz_TryStatement(M) {\n        return {\n            type: \"TryStatement\",\n            block: to_moz_block(M.body),\n            handler: to_moz(M.bcatch),\n            guardedHandlers: [],\n            finalizer: to_moz(M.bfinally)\n        };\n    });\n\n    def_to_moz(AST_Catch, function To_Moz_CatchClause(M) {\n        return {\n            type: \"CatchClause\",\n            param: M.argname != null ? to_moz_pattern(M.argname) : null,\n            body: to_moz_block(M)\n        };\n    });\n\n    def_to_moz(AST_DefinitionsLike, function To_Moz_VariableDeclaration(M) {\n        return {\n            type: \"VariableDeclaration\",\n            kind:\n                M instanceof AST_Const ? \"const\" :\n                M instanceof AST_Let ? \"let\" :\n                M instanceof AST_Using ? (M.await ? \"await using\" : \"using\") :\n                \"var\",\n            declarations: M.definitions.map(to_moz)\n        };\n    });\n\n    function import_attributes_to_moz(attribute) {\n        const import_attributes = [];\n        if (attribute) {\n            for (const { key, value } of attribute.properties) {\n                const key_moz = is_basic_identifier_string(key)\n                    ? { type: \"Identifier\", name: key }\n                    : { type: \"Literal\", value: key, raw: JSON.stringify(key) };\n                import_attributes.push({\n                    type: \"ImportAttribute\",\n                    key: key_moz,\n                    value: to_moz(value)\n                });\n            }\n        }\n        return import_attributes;\n    }\n\n    def_to_moz(AST_Export, function To_Moz_ExportDeclaration(M) {\n        if (M.exported_names) {\n            var first_exported = M.exported_names[0];\n            if (first_exported && first_exported.name.name === \"*\" && !first_exported.name.quote) {\n                var foreign_name = first_exported.foreign_name;\n                var exported = foreign_name.name === \"*\" && !foreign_name.quote\n                    ? null\n                    : to_moz(foreign_name);\n                return {\n                    type: \"ExportAllDeclaration\",\n                    source: to_moz(M.module_name),\n                    exported: exported,\n                    attributes: import_attributes_to_moz(M.attributes)\n                };\n            }\n            return {\n                type: \"ExportNamedDeclaration\",\n                specifiers: M.exported_names.map(function (name_mapping) {\n                    return {\n                        type: \"ExportSpecifier\",\n                        exported: to_moz(name_mapping.foreign_name),\n                        local: to_moz(name_mapping.name)\n                    };\n                }),\n                declaration: to_moz(M.exported_definition),\n                source: to_moz(M.module_name),\n                attributes: import_attributes_to_moz(M.attributes)\n            };\n        }\n\n        if (M.is_default) {\n            return {\n                type: \"ExportDefaultDeclaration\",\n                declaration: to_moz(M.exported_value || M.exported_definition),\n            };\n        } else {\n            return {\n                type: \"ExportNamedDeclaration\",\n                declaration: to_moz(M.exported_value || M.exported_definition),\n                specifiers: [],\n                source: null,\n            };\n        }\n    });\n\n    def_to_moz(AST_Import, function To_Moz_ImportDeclaration(M) {\n        var specifiers = [];\n        if (M.imported_name) {\n            specifiers.push({\n                type: \"ImportDefaultSpecifier\",\n                local: to_moz(M.imported_name)\n            });\n        }\n        if (M.imported_names) {\n            var first_imported_foreign_name = M.imported_names[0].foreign_name;\n            if (first_imported_foreign_name.name === \"*\" && !first_imported_foreign_name.quote) {\n                specifiers.push({\n                    type: \"ImportNamespaceSpecifier\",\n                    local: to_moz(M.imported_names[0].name)\n                });\n            } else {\n                M.imported_names.forEach(function(name_mapping) {\n                    specifiers.push({\n                        type: \"ImportSpecifier\",\n                        local: to_moz(name_mapping.name),\n                        imported: to_moz(name_mapping.foreign_name)\n                    });\n                });\n            }\n        }\n        return {\n            type: \"ImportDeclaration\",\n            specifiers: specifiers,\n            source: to_moz(M.module_name),\n            attributes: import_attributes_to_moz(M.attributes)\n        };\n    });\n\n    def_to_moz(AST_ImportMeta, function To_Moz_MetaProperty() {\n        return {\n            type: \"MetaProperty\",\n            meta: {\n                type: \"Identifier\",\n                name: \"import\"\n            },\n            property: {\n                type: \"Identifier\",\n                name: \"meta\"\n            }\n        };\n    });\n\n    def_to_moz(AST_Sequence, function To_Moz_SequenceExpression(M) {\n        return {\n            type: \"SequenceExpression\",\n            expressions: M.expressions.map(to_moz)\n        };\n    });\n\n    def_to_moz(AST_DotHash, function To_Moz_PrivateMemberExpression(M) {\n        return {\n            type: \"MemberExpression\",\n            object: to_moz(M.expression),\n            computed: false,\n            property: {\n                type: \"PrivateIdentifier\",\n                name: M.property\n            },\n            optional: M.optional\n        };\n    });\n\n    def_to_moz(AST_PropAccess, function To_Moz_MemberExpression(M) {\n        var isComputed = M instanceof AST_Sub;\n        return {\n            type: \"MemberExpression\",\n            object: to_moz(M.expression),\n            computed: isComputed,\n            property: isComputed ? to_moz(M.property) : {type: \"Identifier\", name: M.property},\n            optional: M.optional\n        };\n    });\n\n    def_to_moz(AST_Chain, function To_Moz_ChainExpression(M) {\n        return {\n            type: \"ChainExpression\",\n            expression: to_moz(M.expression)\n        };\n    });\n\n    def_to_moz(AST_Unary, function To_Moz_Unary(M) {\n        return {\n            type: M.operator == \"++\" || M.operator == \"--\" ? \"UpdateExpression\" : \"UnaryExpression\",\n            operator: M.operator,\n            prefix: M instanceof AST_UnaryPrefix,\n            argument: to_moz(M.expression)\n        };\n    });\n\n    def_to_moz(AST_Binary, function To_Moz_BinaryExpression(M) {\n        if (M.operator == \"=\" && to_moz_in_destructuring()) {\n            return {\n                type: \"AssignmentPattern\",\n                left: to_moz(M.left),\n                right: to_moz(M.right)\n            };\n        }\n\n        const type = M.operator == \"&&\" || M.operator == \"||\" || M.operator === \"??\"\n            ? \"LogicalExpression\"\n            : \"BinaryExpression\";\n\n        return {\n            type,\n            left: to_moz(M.left),\n            operator: M.operator,\n            right: to_moz(M.right)\n        };\n    });\n\n    def_to_moz(AST_Assign, function To_Moz_AssignmentExpression(M) {\n        return {\n            type: \"AssignmentExpression\",\n            operator: M.operator,\n            left: to_moz(M.left),\n            right: to_moz(M.right)\n        };\n    });\n\n    def_to_moz(AST_PrivateIn, function To_Moz_BinaryExpression_PrivateIn(M) {\n        return {\n            type: \"BinaryExpression\",\n            left: { type: \"PrivateIdentifier\", name: M.key.name },\n            operator: \"in\",\n            right: to_moz(M.value),\n        };\n    });\n\n    def_to_moz(AST_Array, function To_Moz_ArrayExpression(M) {\n        return {\n            type: \"ArrayExpression\",\n            elements: M.elements.map(to_moz)\n        };\n    });\n\n    def_to_moz(AST_Object, function To_Moz_ObjectExpression(M) {\n        return {\n            type: \"ObjectExpression\",\n            properties: M.properties.map(to_moz)\n        };\n    });\n\n    def_to_moz(AST_ObjectProperty, function To_Moz_Property(M, parent) {\n        var computed = M.computed_key();\n        const [shorthand, key] = to_moz_property_key(M.key, computed, M.quote, M.value);\n\n        var kind;\n        if (M instanceof AST_ObjectGetter) {\n            kind = \"get\";\n        } else\n        if (M instanceof AST_ObjectSetter) {\n            kind = \"set\";\n        }\n        if (M instanceof AST_PrivateGetter || M instanceof AST_PrivateSetter) {\n            const kind = M instanceof AST_PrivateGetter ? \"get\" : \"set\";\n            return {\n                type: \"MethodDefinition\",\n                computed: false,\n                kind: kind,\n                static: M.static,\n                key: {\n                    type: \"PrivateIdentifier\",\n                    name: M.key.name\n                },\n                value: to_moz(M.value)\n            };\n        }\n        if (M instanceof AST_ClassPrivateProperty) {\n            return {\n                type: \"PropertyDefinition\",\n                key: {\n                    type: \"PrivateIdentifier\",\n                    name: M.key.name\n                },\n                value: to_moz(M.value),\n                computed: false,\n                static: M.static\n            };\n        }\n        if (M instanceof AST_ClassProperty) {\n            return {\n                type: \"PropertyDefinition\",\n                key,\n                value: to_moz(M.value),\n                computed,\n                static: M.static\n            };\n        }\n        if (parent instanceof AST_Class) {\n            return {\n                type: \"MethodDefinition\",\n                computed: computed,\n                kind: kind,\n                static: M.static,\n                key: to_moz(M.key),\n                value: to_moz(M.value)\n            };\n        }\n        return {\n            type: \"Property\",\n            computed: computed,\n            method: false,\n            shorthand,\n            kind: kind,\n            key: key,\n            value: to_moz(M.value)\n        };\n    });\n\n    def_to_moz(AST_ObjectKeyVal, function To_Moz_Property(M) {\n        var computed = M.computed_key();\n        const [shorthand, key] = to_moz_property_key(M.key, computed, M.quote, M.value);\n\n        return {\n            type: \"Property\",\n            computed: computed,\n            shorthand: shorthand,\n            method: false,\n            kind: \"init\",\n            key: key,\n            value: to_moz(M.value)\n        };\n    });\n\n    def_to_moz(AST_ConciseMethod, function To_Moz_MethodDefinition(M, parent) {\n        const computed = M.computed_key();\n        const [_always_false, key] = to_moz_property_key(M.key, computed, M.quote, M.value);\n\n        if (parent instanceof AST_Object) {\n            return {\n                type: \"Property\",\n                kind: \"init\",\n                computed,\n                method: true,\n                shorthand: false,\n                key,\n                value: to_moz(M.value),\n            };\n        }\n\n        return {\n            type: \"MethodDefinition\",\n            kind: !computed && M.key.name === \"constructor\" ? \"constructor\" : \"method\",\n            computed,\n            key,\n            value: to_moz(M.value),\n            static: M.static,\n        };\n    });\n\n    def_to_moz(AST_PrivateMethod, function To_Moz_MethodDefinition(M) {\n        return {\n            type: \"MethodDefinition\",\n            kind: \"method\",\n            key: { type: \"PrivateIdentifier\", name: M.key.name },\n            value: to_moz(M.value),\n            computed: false,\n            static: M.static,\n        };\n    });\n\n    def_to_moz(AST_Class, function To_Moz_Class(M) {\n        var type = M instanceof AST_ClassExpression ? \"ClassExpression\" : \"ClassDeclaration\";\n        return {\n            type: type,\n            superClass: to_moz(M.extends),\n            id: M.name ? to_moz(M.name) : null,\n            body: {\n                type: \"ClassBody\",\n                body: M.properties.map(to_moz)\n            }\n        };\n    });\n\n    def_to_moz(AST_ClassStaticBlock, function To_Moz_StaticBlock(M) {\n        return {\n            type: \"StaticBlock\",\n            body: M.body.map(to_moz),\n        };\n    });\n\n    def_to_moz(AST_NewTarget, function To_Moz_MetaProperty() {\n        return {\n            type: \"MetaProperty\",\n            meta: {\n                type: \"Identifier\",\n                name: \"new\"\n            },\n            property: {\n                type: \"Identifier\",\n                name: \"target\"\n            }\n        };\n    });\n\n    def_to_moz(AST_Symbol, function To_Moz_Identifier(M, parent) {\n        if (\n            (M instanceof AST_SymbolMethod && parent.quote) ||\n            ((\n                M instanceof AST_SymbolImportForeign ||\n                M instanceof AST_SymbolExportForeign ||\n                M instanceof AST_SymbolExport\n                ) && M.quote)\n         ) {\n            return {\n                type: \"Literal\",\n                value: M.name\n            };\n        }\n        var def = M.definition();\n        return {\n            type: \"Identifier\",\n            name: def ? def.mangled_name || def.name : M.name\n        };\n    });\n\n    def_to_moz(AST_RegExp, function To_Moz_RegExpLiteral(M) {\n        const pattern = M.value.source;\n        const flags = M.value.flags;\n        return {\n            type: \"Literal\",\n            value: null,\n            raw: M.print_to_string(),\n            regex: { pattern, flags }\n        };\n    });\n\n    def_to_moz(AST_Constant, function To_Moz_Literal(M) {\n        var value = M.value;\n        return {\n            type: \"Literal\",\n            value: value,\n            raw: M.raw || M.print_to_string()\n        };\n    });\n\n    def_to_moz(AST_Atom, function To_Moz_Atom(M) {\n        return {\n            type: \"Identifier\",\n            name: String(M.value)\n        };\n    });\n\n    def_to_moz(AST_BigInt, M => ({\n        type: \"Literal\",\n        // value cannot be represented natively\n        // see: https://github.com/estree/estree/blob/master/es2020.md#bigintliteral\n        value: null,\n        // `M.value` is a string that may be a hex number representation.\n        // but \"bigint\" property should have only decimal digits\n        bigint: typeof BigInt === \"function\" ? BigInt(M.value).toString() : M.value,\n        raw: M.raw,\n    }));\n\n    AST_Boolean.DEFMETHOD(\"to_mozilla_ast\", AST_Constant.prototype.to_mozilla_ast);\n    AST_Null.DEFMETHOD(\"to_mozilla_ast\", AST_Constant.prototype.to_mozilla_ast);\n    AST_Hole.DEFMETHOD(\"to_mozilla_ast\", function To_Moz_ArrayHole() { return null; });\n\n    AST_Block.DEFMETHOD(\"to_mozilla_ast\", AST_BlockStatement.prototype.to_mozilla_ast);\n    AST_Lambda.DEFMETHOD(\"to_mozilla_ast\", AST_Function.prototype.to_mozilla_ast);\n\n    /* -----[ tools ]----- */\n\n    function my_start_token(moznode) {\n        var loc = moznode.loc, start = loc && loc.start;\n        var range = moznode.range;\n        return new AST_Token(\n            \"\",\n            \"\",\n            start && start.line || 0,\n            start && start.column || 0,\n            range ? range [0] : moznode.start,\n            false,\n            [],\n            [],\n            loc && loc.source,\n        );\n    }\n\n    function my_end_token(moznode) {\n        var loc = moznode.loc, end = loc && loc.end;\n        var range = moznode.range;\n        return new AST_Token(\n            \"\",\n            \"\",\n            end && end.line || 0,\n            end && end.column || 0,\n            range ? range [0] : moznode.end,\n            false,\n            [],\n            [],\n            loc && loc.source,\n        );\n    }\n\n    var FROM_MOZ_LABELS = null;\n\n    function from_moz(node) {\n        if (node == null) return null;\n        return MOZ_TO_ME[node.type](node);\n    }\n\n    function from_moz_quote(moz_key, computed) {\n        if (!computed && moz_key.type === \"Literal\" && typeof moz_key.value === \"string\") {\n            return '\"';\n        } else {\n            return \"\";\n        }\n    }\n\n    function from_moz_symbol(symbol_type, M, has_quote) {\n        return new symbol_type({\n            start: my_start_token(M),\n            quote: has_quote ? '\"' : undefined,\n            name: M.type === \"Identifier\" ? M.name : String(M.value),\n            end: my_end_token(M),\n        });\n    }\n\n    function from_moz_lambda(M, is_method) {\n        return new (is_method ? AST_Accessor : AST_Function)({\n            start: my_start_token(M),\n            end: my_end_token(M),\n            name: M.id && from_moz_symbol(is_method ? AST_SymbolMethod : AST_SymbolLambda, M.id),\n            argnames: M.params.map(M => from_moz_pattern(M, AST_SymbolFunarg)),\n            is_generator: M.generator,\n            async: M.async,\n            body: normalize_directives(from_moz(M.body).body)\n        });\n    }\n\n    function from_moz_pattern(M, sym_type) {\n        switch (M.type) {\n            case \"ObjectPattern\":\n                return new AST_Destructuring({\n                    start: my_start_token(M),\n                    end: my_end_token(M),\n                    names: M.properties.map(p => from_moz_pattern(p, sym_type)),\n                    is_array: false\n                });\n\n            case \"Property\":\n                var key = M.key;\n                var args = {\n                    start    : my_start_token(key || M.value),\n                    end      : my_end_token(M.value),\n                    key      : key.type == \"Identifier\" ? key.name : String(key.value),\n                    quote    : !M.computed && key.type === \"Literal\" && typeof key.value === \"string\"\n                                ? '\"'\n                                : \"\",\n                    value    : from_moz_pattern(M.value, sym_type)\n                };\n                if (M.computed) {\n                    args.key = from_moz(M.key);\n                }\n                return new AST_ObjectKeyVal(args);\n\n            case \"ArrayPattern\":\n                return new AST_Destructuring({\n                    start: my_start_token(M),\n                    end: my_end_token(M),\n                    names: M.elements.map(function(elm) {\n                        if (elm === null) {\n                            return new AST_Hole();\n                        }\n                        return from_moz_pattern(elm, sym_type);\n                    }),\n                    is_array: true\n                });\n\n            case \"SpreadElement\":\n            case \"RestElement\":\n                return new AST_Expansion({\n                    start: my_start_token(M),\n                    end: my_end_token(M),\n                    expression: from_moz_pattern(M.argument, sym_type),\n                });\n\n            case \"AssignmentPattern\":\n                return new AST_DefaultAssign({\n                    start : my_start_token(M),\n                    end   : my_end_token(M),\n                    left  : from_moz_pattern(M.left, sym_type),\n                    operator: \"=\",\n                    right : from_moz(M.right),\n                });\n\n            case \"Identifier\":\n                return new sym_type({\n                    start : my_start_token(M),\n                    end   : my_end_token(M),\n                    name  : M.name,\n                });\n\n            default:\n                throw new Error(\"Invalid node type for destructuring: \" + M.type);\n        }\n    }\n\n    function from_moz_label_ref(m_label) {\n        if (!m_label) return null;\n\n        const label = from_moz_symbol(AST_LabelRef, m_label);\n\n        let i = FROM_MOZ_LABELS.length;\n        while (i--) {\n            const label_origin = FROM_MOZ_LABELS[i];\n\n            if (label.name === label_origin.name) {\n                label.thedef = label_origin;\n                break;\n            }\n        }\n\n        return label;\n    }\n\n    AST_Node.from_mozilla_ast = function(node) {\n        var save_labels = FROM_MOZ_LABELS;\n        FROM_MOZ_LABELS = [];\n        var ast = from_moz(node);\n        FROM_MOZ_LABELS = save_labels;\n        return ast;\n    };\n\n    function set_moz_loc(mynode, moznode) {\n        var start = mynode.start;\n        var end = mynode.end;\n        if (!(start && end)) {\n            return moznode;\n        }\n        if (start.pos != null && end.endpos != null) {\n            moznode.range = [start.pos, end.endpos];\n        }\n        if (start.line) {\n            moznode.loc = {\n                start: {line: start.line, column: start.col},\n                end: end.endline ? {line: end.endline, column: end.endcol} : null\n            };\n            if (start.file) {\n                moznode.loc.source = start.file;\n            }\n        }\n        return moznode;\n    }\n\n    function def_to_moz(mytype, handler) {\n        mytype.DEFMETHOD(\"to_mozilla_ast\", function(parent) {\n            return set_moz_loc(this, handler(this, parent));\n        });\n    }\n\n    var TO_MOZ_STACK = null;\n\n    function to_moz(node) {\n        if (TO_MOZ_STACK === null) { TO_MOZ_STACK = []; }\n        TO_MOZ_STACK.push(node);\n        var ast = node != null ? node.to_mozilla_ast(TO_MOZ_STACK[TO_MOZ_STACK.length - 2]) : null;\n        TO_MOZ_STACK.pop();\n        if (TO_MOZ_STACK.length === 0) { TO_MOZ_STACK = null; }\n        return ast;\n    }\n\n    /** Object property keys can be number literals, string literals, or raw names. Additionally they can be shorthand. We decide that here. */\n    function to_moz_property_key(key, computed = false, quote = false, value = null) {\n        if (computed) {\n            return [false, to_moz(key)];\n        }\n\n        const key_name = typeof key === \"string\" ? key : key.name;\n        let moz_key;\n        if (quote) {\n            moz_key = { type: \"Literal\", value: key_name, raw: JSON.stringify(key_name) };\n        } else if (\"\" + +key_name === key_name && +key_name >= 0) {\n            // representable as a number\n            moz_key = { type: \"Literal\", value: +key_name, raw: JSON.stringify(+key_name) };\n        } else {\n            moz_key = { type: \"Identifier\", name: key_name };\n        }\n\n        const shorthand =\n            moz_key.type === \"Identifier\"\n            && moz_key.name === key_name\n            && (value instanceof AST_Symbol && value.name === key_name\n                || value instanceof AST_DefaultAssign && value.left.name === key_name);\n        return [shorthand, moz_key];\n    }\n\n    function to_moz_pattern(node) {\n        if (node instanceof AST_Expansion) {\n            return {\n                type: \"RestElement\",\n                argument: to_moz_pattern(node.expression),\n            };\n        }\n\n        if ((\n            node instanceof AST_Symbol\n            || node instanceof AST_Destructuring\n            || node instanceof AST_DefaultAssign\n            || node instanceof AST_PropAccess\n        )) {\n            // Plain translation\n            return to_moz(node);\n        }\n\n        throw new Error(node.TYPE);\n    }\n\n    function to_moz_in_destructuring() {\n        var i = TO_MOZ_STACK.length;\n        while (i--) {\n            if (TO_MOZ_STACK[i] instanceof AST_Destructuring) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    function to_moz_block(node) {\n        return {\n            type: \"BlockStatement\",\n            body: node.body.map(to_moz)\n        };\n    }\n\n    function to_moz_scope(type, node) {\n        var body = node.body.map(to_moz);\n        if (node.body[0] instanceof AST_SimpleStatement && node.body[0].body instanceof AST_String) {\n            body.unshift(to_moz(new AST_EmptyStatement(node.body[0])));\n        }\n        return {\n            type: type,\n            body: body\n        };\n    }\n})();\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,SAASA,SAAS,QAAQ,kBAAkB;AAC5C,SACIC,YAAY,EACZC,SAAS,EACTC,SAAS,EACTC,UAAU,EACVC,QAAQ,EACRC,SAAS,EACTC,UAAU,EACVC,UAAU,EACVC,SAAS,EACTC,kBAAkB,EAClBC,WAAW,EACXC,SAAS,EACTC,QAAQ,EACRC,QAAQ,EACRC,SAAS,EACTC,SAAS,EACTC,SAAS,EACTC,oBAAoB,EACpBC,mBAAmB,EACnBC,iBAAiB,EACjBC,wBAAwB,EACxBC,iBAAiB,EACjBC,eAAe,EACfC,SAAS,EACTC,YAAY,EACZC,YAAY,EACZC,YAAY,EACZC,WAAW,EACXC,iBAAiB,EACjBC,YAAY,EACZC,mBAAmB,EACnBC,SAAS,EACTC,iBAAiB,EACjBC,aAAa,EACbC,MAAM,EACNC,OAAO,EACPC,WAAW,EACXC,kBAAkB,EAClBC,aAAa,EACbC,UAAU,EACVC,SAAS,EACTC,WAAW,EACXC,OAAO,EACPC,SAAS,EACTC,SAAS,EACTC,YAAY,EACZC,QAAQ,EACRC,MAAM,EACNC,UAAU,EACVC,cAAc,EACdC,SAAS,EACTC,oBAAoB,EACpBC,YAAY,EACZC,UAAU,EACVC,OAAO,EACPC,eAAe,EACfC,OAAO,EACPC,aAAa,EACbC,QAAQ,EACRC,QAAQ,EACRC,UAAU,EACVC,UAAU,EACVC,gBAAgB,EAChBC,gBAAgB,EAChBC,kBAAkB,EAClBC,gBAAgB,EAChBC,0BAA0B,EAC1BC,iBAAiB,EACjBC,iBAAiB,EACjBC,iBAAiB,EACjBC,aAAa,EACbC,cAAc,EACdC,UAAU,EACVC,UAAU,EACVC,YAAY,EACZC,mBAAmB,EACnBC,aAAa,EACbC,UAAU,EACVC,OAAO,EACPC,SAAS,EACTC,UAAU,EACV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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}