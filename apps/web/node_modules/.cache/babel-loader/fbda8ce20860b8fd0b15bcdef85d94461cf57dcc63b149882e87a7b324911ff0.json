{"ast":null,"code":"import CleanCSS from 'clean-css';\nimport { decodeHTMLStrict, decodeHTML } from 'entities';\nimport RelateURL from 'relateurl';\nimport { minify as terser } from 'terser';\nimport { HTMLParser, endTag } from './htmlparser.js';\nimport TokenChain from './tokenchain.js';\nimport { replaceAsync } from './utils.js';\nfunction trimWhitespace(str) {\n  return str && str.replace(/^[ \\n\\r\\t\\f]+/, '').replace(/[ \\n\\r\\t\\f]+$/, '');\n}\nfunction collapseWhitespaceAll(str) {\n  // Non-breaking space is specifically handled inside the replacer function here:\n  return str && str.replace(/[ \\n\\r\\t\\f\\xA0]+/g, function (spaces) {\n    return spaces === '\\t' ? '\\t' : spaces.replace(/(^|\\xA0+)[^\\xA0]+/g, '$1 ');\n  });\n}\nfunction collapseWhitespace(str, options, trimLeft, trimRight, collapseAll) {\n  let lineBreakBefore = '';\n  let lineBreakAfter = '';\n  if (options.preserveLineBreaks) {\n    str = str.replace(/^[ \\n\\r\\t\\f]*?[\\n\\r][ \\n\\r\\t\\f]*/, function () {\n      lineBreakBefore = '\\n';\n      return '';\n    }).replace(/[ \\n\\r\\t\\f]*?[\\n\\r][ \\n\\r\\t\\f]*$/, function () {\n      lineBreakAfter = '\\n';\n      return '';\n    });\n  }\n  if (trimLeft) {\n    // Non-breaking space is specifically handled inside the replacer function here:\n    str = str.replace(/^[ \\n\\r\\t\\f\\xA0]+/, function (spaces) {\n      const conservative = !lineBreakBefore && options.conservativeCollapse;\n      if (conservative && spaces === '\\t') {\n        return '\\t';\n      }\n      return spaces.replace(/^[^\\xA0]+/, '').replace(/(\\xA0+)[^\\xA0]+/g, '$1 ') || (conservative ? ' ' : '');\n    });\n  }\n  if (trimRight) {\n    // Non-breaking space is specifically handled inside the replacer function here:\n    str = str.replace(/[ \\n\\r\\t\\f\\xA0]+$/, function (spaces) {\n      const conservative = !lineBreakAfter && options.conservativeCollapse;\n      if (conservative && spaces === '\\t') {\n        return '\\t';\n      }\n      return spaces.replace(/[^\\xA0]+(\\xA0+)/g, ' $1').replace(/[^\\xA0]+$/, '') || (conservative ? ' ' : '');\n    });\n  }\n  if (collapseAll) {\n    // strip non space whitespace then compress spaces to one\n    str = collapseWhitespaceAll(str);\n  }\n  return lineBreakBefore + str + lineBreakAfter;\n}\n\n// non-empty tags that will maintain whitespace around them\nconst inlineTags = new Set(['a', 'abbr', 'acronym', 'b', 'bdi', 'bdo', 'big', 'button', 'cite', 'code', 'del', 'dfn', 'em', 'font', 'i', 'ins', 'kbd', 'label', 'mark', 'math', 'nobr', 'object', 'q', 'rp', 'rt', 'rtc', 'ruby', 's', 'samp', 'select', 'small', 'span', 'strike', 'strong', 'sub', 'sup', 'svg', 'textarea', 'time', 'tt', 'u', 'var']);\n// non-empty tags that will maintain whitespace within them\nconst inlineTextTags = new Set(['a', 'abbr', 'acronym', 'b', 'big', 'del', 'em', 'font', 'i', 'ins', 'kbd', 'mark', 'nobr', 'rp', 's', 'samp', 'small', 'span', 'strike', 'strong', 'sub', 'sup', 'time', 'tt', 'u', 'var']);\n// self-closing tags that will maintain whitespace around them\nconst selfClosingInlineTags = new Set(['comment', 'img', 'input', 'wbr']);\nfunction collapseWhitespaceSmart(str, prevTag, nextTag, options) {\n  let trimLeft = prevTag && !selfClosingInlineTags.has(prevTag);\n  if (trimLeft && !options.collapseInlineTagWhitespace) {\n    trimLeft = prevTag.charAt(0) === '/' ? !inlineTags.has(prevTag.slice(1)) : !inlineTextTags.has(prevTag);\n  }\n  let trimRight = nextTag && !selfClosingInlineTags.has(nextTag);\n  if (trimRight && !options.collapseInlineTagWhitespace) {\n    trimRight = nextTag.charAt(0) === '/' ? !inlineTextTags.has(nextTag.slice(1)) : !inlineTags.has(nextTag);\n  }\n  return collapseWhitespace(str, options, trimLeft, trimRight, prevTag && nextTag);\n}\nfunction isConditionalComment(text) {\n  return /^\\[if\\s[^\\]]+]|\\[endif]$/.test(text);\n}\nfunction isIgnoredComment(text, options) {\n  for (let i = 0, len = options.ignoreCustomComments.length; i < len; i++) {\n    if (options.ignoreCustomComments[i].test(text)) {\n      return true;\n    }\n  }\n  return false;\n}\nfunction isEventAttribute(attrName, options) {\n  const patterns = options.customEventAttributes;\n  if (patterns) {\n    for (let i = patterns.length; i--;) {\n      if (patterns[i].test(attrName)) {\n        return true;\n      }\n    }\n    return false;\n  }\n  return /^on[a-z]{3,}$/.test(attrName);\n}\nfunction canRemoveAttributeQuotes(value) {\n  // https://mathiasbynens.be/notes/unquoted-attribute-values\n  return /^[^ \\t\\n\\f\\r\"'`=<>]+$/.test(value);\n}\nfunction attributesInclude(attributes, attribute) {\n  for (let i = attributes.length; i--;) {\n    if (attributes[i].name.toLowerCase() === attribute) {\n      return true;\n    }\n  }\n  return false;\n}\nfunction isAttributeRedundant(tag, attrName, attrValue, attrs) {\n  attrValue = attrValue ? trimWhitespace(attrValue.toLowerCase()) : '';\n  return tag === 'script' && attrName === 'language' && attrValue === 'javascript' || tag === 'form' && attrName === 'method' && attrValue === 'get' || tag === 'input' && attrName === 'type' && attrValue === 'text' || tag === 'script' && attrName === 'charset' && !attributesInclude(attrs, 'src') || tag === 'a' && attrName === 'name' && attributesInclude(attrs, 'id') || tag === 'area' && attrName === 'shape' && attrValue === 'rect';\n}\n\n// https://mathiasbynens.be/demo/javascript-mime-type\n// https://developer.mozilla.org/en/docs/Web/HTML/Element/script#attr-type\nconst executableScriptsMimetypes = new Set(['text/javascript', 'text/ecmascript', 'text/jscript', 'application/javascript', 'application/x-javascript', 'application/ecmascript', 'module']);\nconst keepScriptsMimetypes = new Set(['module']);\nfunction isScriptTypeAttribute(attrValue = '') {\n  attrValue = trimWhitespace(attrValue.split(/;/, 2)[0]).toLowerCase();\n  return attrValue === '' || executableScriptsMimetypes.has(attrValue);\n}\nfunction keepScriptTypeAttribute(attrValue = '') {\n  attrValue = trimWhitespace(attrValue.split(/;/, 2)[0]).toLowerCase();\n  return keepScriptsMimetypes.has(attrValue);\n}\nfunction isExecutableScript(tag, attrs) {\n  if (tag !== 'script') {\n    return false;\n  }\n  for (let i = 0, len = attrs.length; i < len; i++) {\n    const attrName = attrs[i].name.toLowerCase();\n    if (attrName === 'type') {\n      return isScriptTypeAttribute(attrs[i].value);\n    }\n  }\n  return true;\n}\nfunction isStyleLinkTypeAttribute(attrValue = '') {\n  attrValue = trimWhitespace(attrValue).toLowerCase();\n  return attrValue === '' || attrValue === 'text/css';\n}\nfunction isStyleSheet(tag, attrs) {\n  if (tag !== 'style') {\n    return false;\n  }\n  for (let i = 0, len = attrs.length; i < len; i++) {\n    const attrName = attrs[i].name.toLowerCase();\n    if (attrName === 'type') {\n      return isStyleLinkTypeAttribute(attrs[i].value);\n    }\n  }\n  return true;\n}\nconst isSimpleBoolean = new Set(['allowfullscreen', 'async', 'autofocus', 'autoplay', 'checked', 'compact', 'controls', 'declare', 'default', 'defaultchecked', 'defaultmuted', 'defaultselected', 'defer', 'disabled', 'enabled', 'formnovalidate', 'hidden', 'indeterminate', 'inert', 'ismap', 'itemscope', 'loop', 'multiple', 'muted', 'nohref', 'noresize', 'noshade', 'novalidate', 'nowrap', 'open', 'pauseonexit', 'readonly', 'required', 'reversed', 'scoped', 'seamless', 'selected', 'sortable', 'truespeed', 'typemustmatch', 'visible']);\nconst isBooleanValue = new Set(['true', 'false']);\nfunction isBooleanAttribute(attrName, attrValue) {\n  return isSimpleBoolean.has(attrName) || attrName === 'draggable' && !isBooleanValue.has(attrValue);\n}\nfunction isUriTypeAttribute(attrName, tag) {\n  return /^(?:a|area|link|base)$/.test(tag) && attrName === 'href' || tag === 'img' && /^(?:src|longdesc|usemap)$/.test(attrName) || tag === 'object' && /^(?:classid|codebase|data|usemap)$/.test(attrName) || tag === 'q' && attrName === 'cite' || tag === 'blockquote' && attrName === 'cite' || (tag === 'ins' || tag === 'del') && attrName === 'cite' || tag === 'form' && attrName === 'action' || tag === 'input' && (attrName === 'src' || attrName === 'usemap') || tag === 'head' && attrName === 'profile' || tag === 'script' && (attrName === 'src' || attrName === 'for');\n}\nfunction isNumberTypeAttribute(attrName, tag) {\n  return /^(?:a|area|object|button)$/.test(tag) && attrName === 'tabindex' || tag === 'input' && (attrName === 'maxlength' || attrName === 'tabindex') || tag === 'select' && (attrName === 'size' || attrName === 'tabindex') || tag === 'textarea' && /^(?:rows|cols|tabindex)$/.test(attrName) || tag === 'colgroup' && attrName === 'span' || tag === 'col' && attrName === 'span' || (tag === 'th' || tag === 'td') && (attrName === 'rowspan' || attrName === 'colspan');\n}\nfunction isLinkType(tag, attrs, value) {\n  if (tag !== 'link') {\n    return false;\n  }\n  for (let i = 0, len = attrs.length; i < len; i++) {\n    if (attrs[i].name === 'rel' && attrs[i].value === value) {\n      return true;\n    }\n  }\n}\nfunction isMediaQuery(tag, attrs, attrName) {\n  return attrName === 'media' && (isLinkType(tag, attrs, 'stylesheet') || isStyleSheet(tag, attrs));\n}\nconst srcsetTags = new Set(['img', 'source']);\nfunction isSrcset(attrName, tag) {\n  return attrName === 'srcset' && srcsetTags.has(tag);\n}\nasync function cleanAttributeValue(tag, attrName, attrValue, options, attrs) {\n  if (isEventAttribute(attrName, options)) {\n    attrValue = trimWhitespace(attrValue).replace(/^javascript:\\s*/i, '');\n    return options.minifyJS(attrValue, true);\n  } else if (attrName === 'class') {\n    attrValue = trimWhitespace(attrValue);\n    if (options.sortClassName) {\n      attrValue = options.sortClassName(attrValue);\n    } else {\n      attrValue = collapseWhitespaceAll(attrValue);\n    }\n    return attrValue;\n  } else if (isUriTypeAttribute(attrName, tag)) {\n    attrValue = trimWhitespace(attrValue);\n    return isLinkType(tag, attrs, 'canonical') ? attrValue : options.minifyURLs(attrValue);\n  } else if (isNumberTypeAttribute(attrName, tag)) {\n    return trimWhitespace(attrValue);\n  } else if (attrName === 'style') {\n    attrValue = trimWhitespace(attrValue);\n    if (attrValue) {\n      if (/;$/.test(attrValue) && !/&#?[0-9a-zA-Z]+;$/.test(attrValue)) {\n        attrValue = attrValue.replace(/\\s*;$/, ';');\n      }\n      attrValue = await options.minifyCSS(attrValue, 'inline');\n    }\n    return attrValue;\n  } else if (isSrcset(attrName, tag)) {\n    // https://html.spec.whatwg.org/multipage/embedded-content.html#attr-img-srcset\n    attrValue = trimWhitespace(attrValue).split(/\\s+,\\s*|\\s*,\\s+/).map(function (candidate) {\n      let url = candidate;\n      let descriptor = '';\n      const match = candidate.match(/\\s+([1-9][0-9]*w|[0-9]+(?:\\.[0-9]+)?x)$/);\n      if (match) {\n        url = url.slice(0, -match[0].length);\n        const num = +match[1].slice(0, -1);\n        const suffix = match[1].slice(-1);\n        if (num !== 1 || suffix !== 'x') {\n          descriptor = ' ' + num + suffix;\n        }\n      }\n      return options.minifyURLs(url) + descriptor;\n    }).join(', ');\n  } else if (isMetaViewport(tag, attrs) && attrName === 'content') {\n    attrValue = attrValue.replace(/\\s+/g, '').replace(/[0-9]+\\.[0-9]+/g, function (numString) {\n      // \"0.90000\" -> \"0.9\"\n      // \"1.0\" -> \"1\"\n      // \"1.0001\" -> \"1.0001\" (unchanged)\n      return (+numString).toString();\n    });\n  } else if (isContentSecurityPolicy(tag, attrs) && attrName.toLowerCase() === 'content') {\n    return collapseWhitespaceAll(attrValue);\n  } else if (options.customAttrCollapse && options.customAttrCollapse.test(attrName)) {\n    attrValue = trimWhitespace(attrValue.replace(/ ?[\\n\\r]+ ?/g, '').replace(/\\s{2,}/g, options.conservativeCollapse ? ' ' : ''));\n  } else if (tag === 'script' && attrName === 'type') {\n    attrValue = trimWhitespace(attrValue.replace(/\\s*;\\s*/g, ';'));\n  } else if (isMediaQuery(tag, attrs, attrName)) {\n    attrValue = trimWhitespace(attrValue);\n    return options.minifyCSS(attrValue, 'media');\n  }\n  return attrValue;\n}\nfunction isMetaViewport(tag, attrs) {\n  if (tag !== 'meta') {\n    return false;\n  }\n  for (let i = 0, len = attrs.length; i < len; i++) {\n    if (attrs[i].name === 'name' && attrs[i].value === 'viewport') {\n      return true;\n    }\n  }\n}\nfunction isContentSecurityPolicy(tag, attrs) {\n  if (tag !== 'meta') {\n    return false;\n  }\n  for (let i = 0, len = attrs.length; i < len; i++) {\n    if (attrs[i].name.toLowerCase() === 'http-equiv' && attrs[i].value.toLowerCase() === 'content-security-policy') {\n      return true;\n    }\n  }\n}\nfunction ignoreCSS(id) {\n  return '/* clean-css ignore:start */' + id + '/* clean-css ignore:end */';\n}\n\n// Wrap CSS declarations for CleanCSS > 3.x\n// See https://github.com/jakubpawlowicz/clean-css/issues/418\nfunction wrapCSS(text, type) {\n  switch (type) {\n    case 'inline':\n      return '*{' + text + '}';\n    case 'media':\n      return '@media ' + text + '{a{top:0}}';\n    default:\n      return text;\n  }\n}\nfunction unwrapCSS(text, type) {\n  let matches;\n  switch (type) {\n    case 'inline':\n      matches = text.match(/^\\*\\{([\\s\\S]*)\\}$/);\n      break;\n    case 'media':\n      matches = text.match(/^@media ([\\s\\S]*?)\\s*{[\\s\\S]*}$/);\n      break;\n  }\n  return matches ? matches[1] : text;\n}\nasync function cleanConditionalComment(comment, options) {\n  return options.processConditionalComments ? await replaceAsync(comment, /^(\\[if\\s[^\\]]+]>)([\\s\\S]*?)(<!\\[endif])$/, async function (match, prefix, text, suffix) {\n    return prefix + (await minifyHTML(text, options, true)) + suffix;\n  }) : comment;\n}\nasync function processScript(text, options, currentAttrs) {\n  for (let i = 0, len = currentAttrs.length; i < len; i++) {\n    if (currentAttrs[i].name.toLowerCase() === 'type' && options.processScripts.indexOf(currentAttrs[i].value) > -1) {\n      return await minifyHTML(text, options);\n    }\n  }\n  return text;\n}\n\n// Tag omission rules from https://html.spec.whatwg.org/multipage/syntax.html#optional-tags\n// with the following deviations:\n// - retain <body> if followed by <noscript>\n// - </rb>, </rt>, </rtc>, </rp> & </tfoot> follow https://www.w3.org/TR/html5/syntax.html#optional-tags\n// - retain all tags which are adjacent to non-standard HTML tags\nconst optionalStartTags = new Set(['html', 'head', 'body', 'colgroup', 'tbody']);\nconst optionalEndTags = new Set(['html', 'head', 'body', 'li', 'dt', 'dd', 'p', 'rb', 'rt', 'rtc', 'rp', 'optgroup', 'option', 'colgroup', 'caption', 'thead', 'tbody', 'tfoot', 'tr', 'td', 'th']);\nconst headerTags = new Set(['meta', 'link', 'script', 'style', 'template', 'noscript']);\nconst descriptionTags = new Set(['dt', 'dd']);\nconst pBlockTags = new Set(['address', 'article', 'aside', 'blockquote', 'details', 'div', 'dl', 'fieldset', 'figcaption', 'figure', 'footer', 'form', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'header', 'hgroup', 'hr', 'main', 'menu', 'nav', 'ol', 'p', 'pre', 'section', 'table', 'ul']);\nconst pInlineTags = new Set(['a', 'audio', 'del', 'ins', 'map', 'noscript', 'video']);\nconst rubyTags = new Set(['rb', 'rt', 'rtc', 'rp']);\nconst rtcTag = new Set(['rb', 'rtc', 'rp']);\nconst optionTag = new Set(['option', 'optgroup']);\nconst tableContentTags = new Set(['tbody', 'tfoot']);\nconst tableSectionTags = new Set(['thead', 'tbody', 'tfoot']);\nconst cellTags = new Set(['td', 'th']);\nconst topLevelTags = new Set(['html', 'head', 'body']);\nconst compactTags = new Set(['html', 'body']);\nconst looseTags = new Set(['head', 'colgroup', 'caption']);\nconst trailingTags = new Set(['dt', 'thead']);\nconst htmlTags = new Set(['a', 'abbr', 'acronym', 'address', 'applet', 'area', 'article', 'aside', 'audio', 'b', 'base', 'basefont', 'bdi', 'bdo', 'bgsound', 'big', 'blink', 'blockquote', 'body', 'br', 'button', 'canvas', 'caption', 'center', 'cite', 'code', 'col', 'colgroup', 'command', 'content', 'data', 'datalist', 'dd', 'del', 'details', 'dfn', 'dialog', 'dir', 'div', 'dl', 'dt', 'element', 'em', 'embed', 'fieldset', 'figcaption', 'figure', 'font', 'footer', 'form', 'frame', 'frameset', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'head', 'header', 'hgroup', 'hr', 'html', 'i', 'iframe', 'image', 'img', 'input', 'ins', 'isindex', 'kbd', 'keygen', 'label', 'legend', 'li', 'link', 'listing', 'main', 'map', 'mark', 'marquee', 'menu', 'menuitem', 'meta', 'meter', 'multicol', 'nav', 'nobr', 'noembed', 'noframes', 'noscript', 'object', 'ol', 'optgroup', 'option', 'output', 'p', 'param', 'picture', 'plaintext', 'pre', 'progress', 'q', 'rb', 'rp', 'rt', 'rtc', 'ruby', 's', 'samp', 'script', 'section', 'select', 'shadow', 'small', 'source', 'spacer', 'span', 'strike', 'strong', 'style', 'sub', 'summary', 'sup', 'table', 'tbody', 'td', 'template', 'textarea', 'tfoot', 'th', 'thead', 'time', 'title', 'tr', 'track', 'tt', 'u', 'ul', 'var', 'video', 'wbr', 'xmp']);\nfunction canRemoveParentTag(optionalStartTag, tag) {\n  switch (optionalStartTag) {\n    case 'html':\n    case 'head':\n      return true;\n    case 'body':\n      return !headerTags.has(tag);\n    case 'colgroup':\n      return tag === 'col';\n    case 'tbody':\n      return tag === 'tr';\n  }\n  return false;\n}\nfunction isStartTagMandatory(optionalEndTag, tag) {\n  switch (tag) {\n    case 'colgroup':\n      return optionalEndTag === 'colgroup';\n    case 'tbody':\n      return tableSectionTags.has(optionalEndTag);\n  }\n  return false;\n}\nfunction canRemovePrecedingTag(optionalEndTag, tag) {\n  switch (optionalEndTag) {\n    case 'html':\n    case 'head':\n    case 'body':\n    case 'colgroup':\n    case 'caption':\n      return true;\n    case 'li':\n    case 'optgroup':\n    case 'tr':\n      return tag === optionalEndTag;\n    case 'dt':\n    case 'dd':\n      return descriptionTags.has(tag);\n    case 'p':\n      return pBlockTags.has(tag);\n    case 'rb':\n    case 'rt':\n    case 'rp':\n      return rubyTags.has(tag);\n    case 'rtc':\n      return rtcTag.has(tag);\n    case 'option':\n      return optionTag.has(tag);\n    case 'thead':\n    case 'tbody':\n      return tableContentTags.has(tag);\n    case 'tfoot':\n      return tag === 'tbody';\n    case 'td':\n    case 'th':\n      return cellTags.has(tag);\n  }\n  return false;\n}\nconst reEmptyAttribute = new RegExp('^(?:class|id|style|title|lang|dir|on(?:focus|blur|change|click|dblclick|mouse(' + '?:down|up|over|move|out)|key(?:press|down|up)))$');\nfunction canDeleteEmptyAttribute(tag, attrName, attrValue, options) {\n  const isValueEmpty = !attrValue || /^\\s*$/.test(attrValue);\n  if (!isValueEmpty) {\n    return false;\n  }\n  if (typeof options.removeEmptyAttributes === 'function') {\n    return options.removeEmptyAttributes(attrName, tag);\n  }\n  return tag === 'input' && attrName === 'value' || reEmptyAttribute.test(attrName);\n}\nfunction hasAttrName(name, attrs) {\n  for (let i = attrs.length - 1; i >= 0; i--) {\n    if (attrs[i].name === name) {\n      return true;\n    }\n  }\n  return false;\n}\nfunction canRemoveElement(tag, attrs) {\n  switch (tag) {\n    case 'textarea':\n      return false;\n    case 'audio':\n    case 'script':\n    case 'video':\n      if (hasAttrName('src', attrs)) {\n        return false;\n      }\n      break;\n    case 'iframe':\n      if (hasAttrName('src', attrs) || hasAttrName('srcdoc', attrs)) {\n        return false;\n      }\n      break;\n    case 'object':\n      if (hasAttrName('data', attrs)) {\n        return false;\n      }\n      break;\n    case 'applet':\n      if (hasAttrName('code', attrs)) {\n        return false;\n      }\n      break;\n  }\n  return true;\n}\nfunction canCollapseWhitespace(tag) {\n  return !/^(?:script|style|pre|textarea)$/.test(tag);\n}\nfunction canTrimWhitespace(tag) {\n  return !/^(?:pre|textarea)$/.test(tag);\n}\nasync function normalizeAttr(attr, attrs, tag, options) {\n  const attrName = options.name(attr.name);\n  let attrValue = attr.value;\n  if (options.decodeEntities && attrValue) {\n    attrValue = decodeHTMLStrict(attrValue);\n  }\n  if (options.removeRedundantAttributes && isAttributeRedundant(tag, attrName, attrValue, attrs) || options.removeScriptTypeAttributes && tag === 'script' && attrName === 'type' && isScriptTypeAttribute(attrValue) && !keepScriptTypeAttribute(attrValue) || options.removeStyleLinkTypeAttributes && (tag === 'style' || tag === 'link') && attrName === 'type' && isStyleLinkTypeAttribute(attrValue)) {\n    return;\n  }\n  if (attrValue) {\n    attrValue = await cleanAttributeValue(tag, attrName, attrValue, options, attrs);\n  }\n  if (options.removeEmptyAttributes && canDeleteEmptyAttribute(tag, attrName, attrValue, options)) {\n    return;\n  }\n  if (options.decodeEntities && attrValue) {\n    attrValue = attrValue.replace(/&(#?[0-9a-zA-Z]+;)/g, '&amp;$1');\n  }\n  return {\n    attr,\n    name: attrName,\n    value: attrValue\n  };\n}\nfunction buildAttr(normalized, hasUnarySlash, options, isLast, uidAttr) {\n  const attrName = normalized.name;\n  let attrValue = normalized.value;\n  const attr = normalized.attr;\n  let attrQuote = attr.quote;\n  let attrFragment;\n  let emittedAttrValue;\n  if (typeof attrValue !== 'undefined' && (!options.removeAttributeQuotes || ~attrValue.indexOf(uidAttr) || !canRemoveAttributeQuotes(attrValue))) {\n    if (!options.preventAttributesEscaping) {\n      if (typeof options.quoteCharacter === 'undefined') {\n        const apos = (attrValue.match(/'/g) || []).length;\n        const quot = (attrValue.match(/\"/g) || []).length;\n        attrQuote = apos < quot ? '\\'' : '\"';\n      } else {\n        attrQuote = options.quoteCharacter === '\\'' ? '\\'' : '\"';\n      }\n      if (attrQuote === '\"') {\n        attrValue = attrValue.replace(/\"/g, '&#34;');\n      } else {\n        attrValue = attrValue.replace(/'/g, '&#39;');\n      }\n    }\n    emittedAttrValue = attrQuote + attrValue + attrQuote;\n    if (!isLast && !options.removeTagWhitespace) {\n      emittedAttrValue += ' ';\n    }\n  } else if (isLast && !hasUnarySlash && !/\\/$/.test(attrValue)) {\n    // make sure trailing slash is not interpreted as HTML self-closing tag\n    emittedAttrValue = attrValue;\n  } else {\n    emittedAttrValue = attrValue + ' ';\n  }\n  if (typeof attrValue === 'undefined' || options.collapseBooleanAttributes && isBooleanAttribute(attrName.toLowerCase(), attrValue.toLowerCase())) {\n    attrFragment = attrName;\n    if (!isLast) {\n      attrFragment += ' ';\n    }\n  } else {\n    attrFragment = attrName + attr.customAssign + emittedAttrValue;\n  }\n  return attr.customOpen + attrFragment + attr.customClose;\n}\nfunction identity(value) {\n  return value;\n}\nfunction identityAsync(value) {\n  return Promise.resolve(value);\n}\nconst processOptions = inputOptions => {\n  const options = {\n    name: function (name) {\n      return name.toLowerCase();\n    },\n    canCollapseWhitespace,\n    canTrimWhitespace,\n    html5: true,\n    ignoreCustomComments: [/^!/, /^\\s*#/],\n    ignoreCustomFragments: [/<%[\\s\\S]*?%>/, /<\\?[\\s\\S]*?\\?>/],\n    includeAutoGeneratedTags: true,\n    log: identity,\n    minifyCSS: identityAsync,\n    minifyJS: identity,\n    minifyURLs: identity\n  };\n  Object.keys(inputOptions).forEach(function (key) {\n    const option = inputOptions[key];\n    if (key === 'caseSensitive') {\n      if (option) {\n        options.name = identity;\n      }\n    } else if (key === 'log') {\n      if (typeof option === 'function') {\n        options.log = option;\n      }\n    } else if (key === 'minifyCSS' && typeof option !== 'function') {\n      if (!option) {\n        return;\n      }\n      const cleanCssOptions = typeof option === 'object' ? option : {};\n      options.minifyCSS = async function (text, type) {\n        text = text.replace(/(url\\s*\\(\\s*)(\"|'|)(.*?)\\2(\\s*\\))/ig, function (match, prefix, quote, url, suffix) {\n          return prefix + quote + options.minifyURLs(url) + quote + suffix;\n        });\n        const inputCSS = wrapCSS(text, type);\n        return new Promise(resolve => {\n          new CleanCSS(cleanCssOptions).minify(inputCSS, (_err, output) => {\n            if (output.errors.length > 0) {\n              output.errors.forEach(options.log);\n              resolve(text);\n            }\n            const outputCSS = unwrapCSS(output.styles, type);\n            resolve(outputCSS);\n          });\n        });\n      };\n    } else if (key === 'minifyJS' && typeof option !== 'function') {\n      if (!option) {\n        return;\n      }\n      const terserOptions = typeof option === 'object' ? option : {};\n      terserOptions.parse = {\n        ...terserOptions.parse,\n        bare_returns: false\n      };\n      options.minifyJS = async function (text, inline) {\n        const start = text.match(/^\\s*<!--.*/);\n        const code = start ? text.slice(start[0].length).replace(/\\n\\s*-->\\s*$/, '') : text;\n        terserOptions.parse.bare_returns = inline;\n        try {\n          const result = await terser(code, terserOptions);\n          return result.code.replace(/;$/, '');\n        } catch (error) {\n          options.log(error);\n          return text;\n        }\n      };\n    } else if (key === 'minifyURLs' && typeof option !== 'function') {\n      if (!option) {\n        return;\n      }\n      let relateUrlOptions = option;\n      if (typeof option === 'string') {\n        relateUrlOptions = {\n          site: option\n        };\n      } else if (typeof option !== 'object') {\n        relateUrlOptions = {};\n      }\n      options.minifyURLs = function (text) {\n        try {\n          return RelateURL.relate(text, relateUrlOptions);\n        } catch (err) {\n          options.log(err);\n          return text;\n        }\n      };\n    } else {\n      options[key] = option;\n    }\n  });\n  return options;\n};\nfunction uniqueId(value) {\n  let id;\n  do {\n    id = Math.random().toString(36).replace(/^0\\.[0-9]*/, '');\n  } while (~value.indexOf(id));\n  return id;\n}\nconst specialContentTags = new Set(['script', 'style']);\nasync function createSortFns(value, options, uidIgnore, uidAttr) {\n  const attrChains = options.sortAttributes && Object.create(null);\n  const classChain = options.sortClassName && new TokenChain();\n  function attrNames(attrs) {\n    return attrs.map(function (attr) {\n      return options.name(attr.name);\n    });\n  }\n  function shouldSkipUID(token, uid) {\n    return !uid || token.indexOf(uid) === -1;\n  }\n  function shouldSkipUIDs(token) {\n    return shouldSkipUID(token, uidIgnore) && shouldSkipUID(token, uidAttr);\n  }\n  async function scan(input) {\n    let currentTag, currentType;\n    const parser = new HTMLParser(input, {\n      start: function (tag, attrs) {\n        if (attrChains) {\n          if (!attrChains[tag]) {\n            attrChains[tag] = new TokenChain();\n          }\n          attrChains[tag].add(attrNames(attrs).filter(shouldSkipUIDs));\n        }\n        for (let i = 0, len = attrs.length; i < len; i++) {\n          const attr = attrs[i];\n          if (classChain && attr.value && options.name(attr.name) === 'class') {\n            classChain.add(trimWhitespace(attr.value).split(/[ \\t\\n\\f\\r]+/).filter(shouldSkipUIDs));\n          } else if (options.processScripts && attr.name.toLowerCase() === 'type') {\n            currentTag = tag;\n            currentType = attr.value;\n          }\n        }\n      },\n      end: function () {\n        currentTag = '';\n      },\n      chars: async function (text) {\n        if (options.processScripts && specialContentTags.has(currentTag) && options.processScripts.indexOf(currentType) > -1) {\n          await scan(text);\n        }\n      }\n    });\n    await parser.parse();\n  }\n  const log = options.log;\n  options.log = identity;\n  options.sortAttributes = false;\n  options.sortClassName = false;\n  await scan(await minifyHTML(value, options));\n  options.log = log;\n  if (attrChains) {\n    const attrSorters = Object.create(null);\n    for (const tag in attrChains) {\n      attrSorters[tag] = attrChains[tag].createSorter();\n    }\n    options.sortAttributes = function (tag, attrs) {\n      const sorter = attrSorters[tag];\n      if (sorter) {\n        const attrMap = Object.create(null);\n        const names = attrNames(attrs);\n        names.forEach(function (name, index) {\n          (attrMap[name] || (attrMap[name] = [])).push(attrs[index]);\n        });\n        sorter.sort(names).forEach(function (name, index) {\n          attrs[index] = attrMap[name].shift();\n        });\n      }\n    };\n  }\n  if (classChain) {\n    const sorter = classChain.createSorter();\n    options.sortClassName = function (value) {\n      return sorter.sort(value.split(/[ \\n\\f\\r]+/)).join(' ');\n    };\n  }\n}\nasync function minifyHTML(value, options, partialMarkup) {\n  if (options.collapseWhitespace) {\n    value = collapseWhitespace(value, options, true, true);\n  }\n  const buffer = [];\n  let charsPrevTag;\n  let currentChars = '';\n  let hasChars;\n  let currentTag = '';\n  let currentAttrs = [];\n  const stackNoTrimWhitespace = [];\n  const stackNoCollapseWhitespace = [];\n  let optionalStartTag = '';\n  let optionalEndTag = '';\n  const ignoredMarkupChunks = [];\n  const ignoredCustomMarkupChunks = [];\n  let uidIgnore;\n  let uidAttr;\n  let uidPattern;\n\n  // temporarily replace ignored chunks with comments,\n  // so that we don't have to worry what's there.\n  // for all we care there might be\n  // completely-horribly-broken-alien-non-html-emoj-cthulhu-filled content\n  value = value.replace(/<!-- htmlmin:ignore -->([\\s\\S]*?)<!-- htmlmin:ignore -->/g, function (match, group1) {\n    if (!uidIgnore) {\n      uidIgnore = uniqueId(value);\n      const pattern = new RegExp('^' + uidIgnore + '([0-9]+)$');\n      if (options.ignoreCustomComments) {\n        options.ignoreCustomComments = options.ignoreCustomComments.slice();\n      } else {\n        options.ignoreCustomComments = [];\n      }\n      options.ignoreCustomComments.push(pattern);\n    }\n    const token = '<!--' + uidIgnore + ignoredMarkupChunks.length + '-->';\n    ignoredMarkupChunks.push(group1);\n    return token;\n  });\n  const customFragments = options.ignoreCustomFragments.map(function (re) {\n    return re.source;\n  });\n  if (customFragments.length) {\n    const reCustomIgnore = new RegExp('\\\\s*(?:' + customFragments.join('|') + ')+\\\\s*', 'g');\n    // temporarily replace custom ignored fragments with unique attributes\n    value = value.replace(reCustomIgnore, function (match) {\n      if (!uidAttr) {\n        uidAttr = uniqueId(value);\n        uidPattern = new RegExp('(\\\\s*)' + uidAttr + '([0-9]+)' + uidAttr + '(\\\\s*)', 'g');\n        if (options.minifyCSS) {\n          options.minifyCSS = function (fn) {\n            return function (text, type) {\n              text = text.replace(uidPattern, function (match, prefix, index) {\n                const chunks = ignoredCustomMarkupChunks[+index];\n                return chunks[1] + uidAttr + index + uidAttr + chunks[2];\n              });\n              const ids = [];\n              new CleanCSS().minify(wrapCSS(text, type)).warnings.forEach(function (warning) {\n                const match = uidPattern.exec(warning);\n                if (match) {\n                  const id = uidAttr + match[2] + uidAttr;\n                  text = text.replace(id, ignoreCSS(id));\n                  ids.push(id);\n                }\n              });\n              return fn(text, type).then(chunk => {\n                ids.forEach(function (id) {\n                  chunk = chunk.replace(ignoreCSS(id), id);\n                });\n                return chunk;\n              });\n            };\n          }(options.minifyCSS);\n        }\n        if (options.minifyJS) {\n          options.minifyJS = function (fn) {\n            return function (text, type) {\n              return fn(text.replace(uidPattern, function (match, prefix, index) {\n                const chunks = ignoredCustomMarkupChunks[+index];\n                return chunks[1] + uidAttr + index + uidAttr + chunks[2];\n              }), type);\n            };\n          }(options.minifyJS);\n        }\n      }\n      const token = uidAttr + ignoredCustomMarkupChunks.length + uidAttr;\n      ignoredCustomMarkupChunks.push(/^(\\s*)[\\s\\S]*?(\\s*)$/.exec(match));\n      return '\\t' + token + '\\t';\n    });\n  }\n  if (options.sortAttributes && typeof options.sortAttributes !== 'function' || options.sortClassName && typeof options.sortClassName !== 'function') {\n    await createSortFns(value, options, uidIgnore, uidAttr);\n  }\n  function _canCollapseWhitespace(tag, attrs) {\n    return options.canCollapseWhitespace(tag, attrs, canCollapseWhitespace);\n  }\n  function _canTrimWhitespace(tag, attrs) {\n    return options.canTrimWhitespace(tag, attrs, canTrimWhitespace);\n  }\n  function removeStartTag() {\n    let index = buffer.length - 1;\n    while (index > 0 && !/^<[^/!]/.test(buffer[index])) {\n      index--;\n    }\n    buffer.length = Math.max(0, index);\n  }\n  function removeEndTag() {\n    let index = buffer.length - 1;\n    while (index > 0 && !/^<\\//.test(buffer[index])) {\n      index--;\n    }\n    buffer.length = Math.max(0, index);\n  }\n\n  // look for trailing whitespaces, bypass any inline tags\n  function trimTrailingWhitespace(index, nextTag) {\n    for (let endTag = null; index >= 0 && _canTrimWhitespace(endTag); index--) {\n      const str = buffer[index];\n      const match = str.match(/^<\\/([\\w:-]+)>$/);\n      if (match) {\n        endTag = match[1];\n      } else if (/>$/.test(str) || (buffer[index] = collapseWhitespaceSmart(str, null, nextTag, options))) {\n        break;\n      }\n    }\n  }\n\n  // look for trailing whitespaces from previously processed text\n  // which may not be trimmed due to a following comment or an empty\n  // element which has now been removed\n  function squashTrailingWhitespace(nextTag) {\n    let charsIndex = buffer.length - 1;\n    if (buffer.length > 1) {\n      const item = buffer[buffer.length - 1];\n      if (/^(?:<!|$)/.test(item) && item.indexOf(uidIgnore) === -1) {\n        charsIndex--;\n      }\n    }\n    trimTrailingWhitespace(charsIndex, nextTag);\n  }\n  const parser = new HTMLParser(value, {\n    partialMarkup,\n    continueOnParseError: options.continueOnParseError,\n    customAttrAssign: options.customAttrAssign,\n    customAttrSurround: options.customAttrSurround,\n    html5: options.html5,\n    start: async function (tag, attrs, unary, unarySlash, autoGenerated) {\n      if (tag.toLowerCase() === 'svg') {\n        options = Object.create(options);\n        options.caseSensitive = true;\n        options.keepClosingSlash = true;\n        options.name = identity;\n      }\n      tag = options.name(tag);\n      currentTag = tag;\n      charsPrevTag = tag;\n      if (!inlineTextTags.has(tag)) {\n        currentChars = '';\n      }\n      hasChars = false;\n      currentAttrs = attrs;\n      let optional = options.removeOptionalTags;\n      if (optional) {\n        const htmlTag = htmlTags.has(tag);\n        // <html> may be omitted if first thing inside is not comment\n        // <head> may be omitted if first thing inside is an element\n        // <body> may be omitted if first thing inside is not space, comment, <meta>, <link>, <script>, <style> or <template>\n        // <colgroup> may be omitted if first thing inside is <col>\n        // <tbody> may be omitted if first thing inside is <tr>\n        if (htmlTag && canRemoveParentTag(optionalStartTag, tag)) {\n          removeStartTag();\n        }\n        optionalStartTag = '';\n        // end-tag-followed-by-start-tag omission rules\n        if (htmlTag && canRemovePrecedingTag(optionalEndTag, tag)) {\n          removeEndTag();\n          // <colgroup> cannot be omitted if preceding </colgroup> is omitted\n          // <tbody> cannot be omitted if preceding </tbody>, </thead> or </tfoot> is omitted\n          optional = !isStartTagMandatory(optionalEndTag, tag);\n        }\n        optionalEndTag = '';\n      }\n\n      // set whitespace flags for nested tags (eg. <code> within a <pre>)\n      if (options.collapseWhitespace) {\n        if (!stackNoTrimWhitespace.length) {\n          squashTrailingWhitespace(tag);\n        }\n        if (!unary) {\n          if (!_canTrimWhitespace(tag, attrs) || stackNoTrimWhitespace.length) {\n            stackNoTrimWhitespace.push(tag);\n          }\n          if (!_canCollapseWhitespace(tag, attrs) || stackNoCollapseWhitespace.length) {\n            stackNoCollapseWhitespace.push(tag);\n          }\n        }\n      }\n      const openTag = '<' + tag;\n      const hasUnarySlash = unarySlash && options.keepClosingSlash;\n      buffer.push(openTag);\n      if (options.sortAttributes) {\n        options.sortAttributes(tag, attrs);\n      }\n      const parts = [];\n      for (let i = attrs.length, isLast = true; --i >= 0;) {\n        const normalized = await normalizeAttr(attrs[i], attrs, tag, options);\n        if (normalized) {\n          parts.unshift(buildAttr(normalized, hasUnarySlash, options, isLast, uidAttr));\n          isLast = false;\n        }\n      }\n      if (parts.length > 0) {\n        buffer.push(' ');\n        buffer.push.apply(buffer, parts);\n      } else if (optional && optionalStartTags.has(tag)) {\n        // start tag must never be omitted if it has any attributes\n        optionalStartTag = tag;\n      }\n      buffer.push(buffer.pop() + (hasUnarySlash ? '/' : '') + '>');\n      if (autoGenerated && !options.includeAutoGeneratedTags) {\n        removeStartTag();\n        optionalStartTag = '';\n      }\n    },\n    end: function (tag, attrs, autoGenerated) {\n      if (tag.toLowerCase() === 'svg') {\n        options = Object.getPrototypeOf(options);\n      }\n      tag = options.name(tag);\n\n      // check if current tag is in a whitespace stack\n      if (options.collapseWhitespace) {\n        if (stackNoTrimWhitespace.length) {\n          if (tag === stackNoTrimWhitespace[stackNoTrimWhitespace.length - 1]) {\n            stackNoTrimWhitespace.pop();\n          }\n        } else {\n          squashTrailingWhitespace('/' + tag);\n        }\n        if (stackNoCollapseWhitespace.length && tag === stackNoCollapseWhitespace[stackNoCollapseWhitespace.length - 1]) {\n          stackNoCollapseWhitespace.pop();\n        }\n      }\n      let isElementEmpty = false;\n      if (tag === currentTag) {\n        currentTag = '';\n        isElementEmpty = !hasChars;\n      }\n      if (options.removeOptionalTags) {\n        // <html>, <head> or <body> may be omitted if the element is empty\n        if (isElementEmpty && topLevelTags.has(optionalStartTag)) {\n          removeStartTag();\n        }\n        optionalStartTag = '';\n        // </html> or </body> may be omitted if not followed by comment\n        // </head> may be omitted if not followed by space or comment\n        // </p> may be omitted if no more content in non-</a> parent\n        // except for </dt> or </thead>, end tags may be omitted if no more content in parent element\n        if (htmlTags.has(tag) && optionalEndTag && !trailingTags.has(optionalEndTag) && (optionalEndTag !== 'p' || !pInlineTags.has(tag))) {\n          removeEndTag();\n        }\n        optionalEndTag = optionalEndTags.has(tag) ? tag : '';\n      }\n      if (options.removeEmptyElements && isElementEmpty && canRemoveElement(tag, attrs)) {\n        // remove last \"element\" from buffer\n        removeStartTag();\n        optionalStartTag = '';\n        optionalEndTag = '';\n      } else {\n        if (autoGenerated && !options.includeAutoGeneratedTags) {\n          optionalEndTag = '';\n        } else {\n          buffer.push('</' + tag + '>');\n        }\n        charsPrevTag = '/' + tag;\n        if (!inlineTags.has(tag)) {\n          currentChars = '';\n        } else if (isElementEmpty) {\n          currentChars += '|';\n        }\n      }\n    },\n    chars: async function (text, prevTag, nextTag) {\n      prevTag = prevTag === '' ? 'comment' : prevTag;\n      nextTag = nextTag === '' ? 'comment' : nextTag;\n      if (options.decodeEntities && text && !specialContentTags.has(currentTag)) {\n        text = decodeHTML(text);\n      }\n      if (options.collapseWhitespace) {\n        if (!stackNoTrimWhitespace.length) {\n          if (prevTag === 'comment') {\n            const prevComment = buffer[buffer.length - 1];\n            if (prevComment.indexOf(uidIgnore) === -1) {\n              if (!prevComment) {\n                prevTag = charsPrevTag;\n              }\n              if (buffer.length > 1 && (!prevComment || !options.conservativeCollapse && / $/.test(currentChars))) {\n                const charsIndex = buffer.length - 2;\n                buffer[charsIndex] = buffer[charsIndex].replace(/\\s+$/, function (trailingSpaces) {\n                  text = trailingSpaces + text;\n                  return '';\n                });\n              }\n            }\n          }\n          if (prevTag) {\n            if (prevTag === '/nobr' || prevTag === 'wbr') {\n              if (/^\\s/.test(text)) {\n                let tagIndex = buffer.length - 1;\n                while (tagIndex > 0 && buffer[tagIndex].lastIndexOf('<' + prevTag) !== 0) {\n                  tagIndex--;\n                }\n                trimTrailingWhitespace(tagIndex - 1, 'br');\n              }\n            } else if (inlineTextTags.has(prevTag.charAt(0) === '/' ? prevTag.slice(1) : prevTag)) {\n              text = collapseWhitespace(text, options, /(?:^|\\s)$/.test(currentChars));\n            }\n          }\n          if (prevTag || nextTag) {\n            text = collapseWhitespaceSmart(text, prevTag, nextTag, options);\n          } else {\n            text = collapseWhitespace(text, options, true, true);\n          }\n          if (!text && /\\s$/.test(currentChars) && prevTag && prevTag.charAt(0) === '/') {\n            trimTrailingWhitespace(buffer.length - 1, nextTag);\n          }\n        }\n        if (!stackNoCollapseWhitespace.length && nextTag !== 'html' && !(prevTag && nextTag)) {\n          text = collapseWhitespace(text, options, false, false, true);\n        }\n      }\n      if (options.processScripts && specialContentTags.has(currentTag)) {\n        text = await processScript(text, options, currentAttrs);\n      }\n      if (isExecutableScript(currentTag, currentAttrs)) {\n        text = await options.minifyJS(text);\n      }\n      if (isStyleSheet(currentTag, currentAttrs)) {\n        text = await options.minifyCSS(text);\n      }\n      if (options.removeOptionalTags && text) {\n        // <html> may be omitted if first thing inside is not comment\n        // <body> may be omitted if first thing inside is not space, comment, <meta>, <link>, <script>, <style> or <template>\n        if (optionalStartTag === 'html' || optionalStartTag === 'body' && !/^\\s/.test(text)) {\n          removeStartTag();\n        }\n        optionalStartTag = '';\n        // </html> or </body> may be omitted if not followed by comment\n        // </head>, </colgroup> or </caption> may be omitted if not followed by space or comment\n        if (compactTags.has(optionalEndTag) || looseTags.has(optionalEndTag) && !/^\\s/.test(text)) {\n          removeEndTag();\n        }\n        optionalEndTag = '';\n      }\n      charsPrevTag = /^\\s*$/.test(text) ? prevTag : 'comment';\n      if (options.decodeEntities && text && !specialContentTags.has(currentTag)) {\n        // Escape any `&` symbols that start either:\n        // 1) a legacy named character reference (i.e. one that doesn't end with `;`)\n        // 2) or any other character reference (i.e. one that does end with `;`)\n        // Note that `&` can be escaped as `&amp`, without the semi-colon.\n        // https://mathiasbynens.be/notes/ambiguous-ampersands\n        text = text.replace(/&((?:Iacute|aacute|uacute|plusmn|Otilde|otilde|agrave|Agrave|Yacute|yacute|Oslash|oslash|atilde|Atilde|brvbar|ccedil|Ccedil|Ograve|curren|divide|eacute|Eacute|ograve|Oacute|egrave|Egrave|Ugrave|frac12|frac14|frac34|ugrave|oacute|iacute|Ntilde|ntilde|Uacute|middot|igrave|Igrave|iquest|Aacute|cedil|laquo|micro|iexcl|Icirc|icirc|acirc|Ucirc|Ecirc|ocirc|Ocirc|ecirc|ucirc|Aring|aring|AElig|aelig|acute|pound|raquo|Acirc|times|THORN|szlig|thorn|COPY|auml|ordf|ordm|Uuml|macr|uuml|Auml|ouml|Ouml|para|nbsp|euml|quot|QUOT|Euml|yuml|cent|sect|copy|sup1|sup2|sup3|iuml|Iuml|ETH|shy|reg|not|yen|amp|AMP|REG|uml|eth|deg|gt|GT|LT|lt)(?!;)|(?:#?[0-9a-zA-Z]+;))/g, '&amp$1').replace(/</g, '&lt;');\n      }\n      if (uidPattern && options.collapseWhitespace && stackNoTrimWhitespace.length) {\n        text = text.replace(uidPattern, function (match, prefix, index) {\n          return ignoredCustomMarkupChunks[+index][0];\n        });\n      }\n      currentChars += text;\n      if (text) {\n        hasChars = true;\n      }\n      buffer.push(text);\n    },\n    comment: async function (text, nonStandard) {\n      const prefix = nonStandard ? '<!' : '<!--';\n      const suffix = nonStandard ? '>' : '-->';\n      if (isConditionalComment(text)) {\n        text = prefix + (await cleanConditionalComment(text, options)) + suffix;\n      } else if (options.removeComments) {\n        if (isIgnoredComment(text, options)) {\n          text = '<!--' + text + '-->';\n        } else {\n          text = '';\n        }\n      } else {\n        text = prefix + text + suffix;\n      }\n      if (options.removeOptionalTags && text) {\n        // preceding comments suppress tag omissions\n        optionalStartTag = '';\n        optionalEndTag = '';\n      }\n      buffer.push(text);\n    },\n    doctype: function (doctype) {\n      buffer.push(options.useShortDoctype ? '<!doctype' + (options.removeTagWhitespace ? '' : ' ') + 'html>' : collapseWhitespaceAll(doctype));\n    }\n  });\n  await parser.parse();\n  if (options.removeOptionalTags) {\n    // <html> may be omitted if first thing inside is not comment\n    // <head> or <body> may be omitted if empty\n    if (topLevelTags.has(optionalStartTag)) {\n      removeStartTag();\n    }\n    // except for </dt> or </thead>, end tags may be omitted if no more content in parent element\n    if (optionalEndTag && !trailingTags.has(optionalEndTag)) {\n      removeEndTag();\n    }\n  }\n  if (options.collapseWhitespace) {\n    squashTrailingWhitespace('br');\n  }\n  return joinResultSegments(buffer, options, uidPattern ? function (str) {\n    return str.replace(uidPattern, function (match, prefix, index, suffix) {\n      let chunk = ignoredCustomMarkupChunks[+index][0];\n      if (options.collapseWhitespace) {\n        if (prefix !== '\\t') {\n          chunk = prefix + chunk;\n        }\n        if (suffix !== '\\t') {\n          chunk += suffix;\n        }\n        return collapseWhitespace(chunk, {\n          preserveLineBreaks: options.preserveLineBreaks,\n          conservativeCollapse: !options.trimCustomFragments\n        }, /^[ \\n\\r\\t\\f]/.test(chunk), /[ \\n\\r\\t\\f]$/.test(chunk));\n      }\n      return chunk;\n    });\n  } : identity, uidIgnore ? function (str) {\n    return str.replace(new RegExp('<!--' + uidIgnore + '([0-9]+)-->', 'g'), function (match, index) {\n      return ignoredMarkupChunks[+index];\n    });\n  } : identity);\n}\nfunction joinResultSegments(results, options, restoreCustom, restoreIgnore) {\n  let str;\n  const maxLineLength = options.maxLineLength;\n  const noNewlinesBeforeTagClose = options.noNewlinesBeforeTagClose;\n  if (maxLineLength) {\n    let line = '';\n    const lines = [];\n    while (results.length) {\n      const len = line.length;\n      const end = results[0].indexOf('\\n');\n      const isClosingTag = Boolean(results[0].match(endTag));\n      const shouldKeepSameLine = noNewlinesBeforeTagClose && isClosingTag;\n      if (end < 0) {\n        line += restoreIgnore(restoreCustom(results.shift()));\n      } else {\n        line += restoreIgnore(restoreCustom(results[0].slice(0, end)));\n        results[0] = results[0].slice(end + 1);\n      }\n      if (len > 0 && line.length > maxLineLength && !shouldKeepSameLine) {\n        lines.push(line.slice(0, len));\n        line = line.slice(len);\n      } else if (end >= 0) {\n        lines.push(line);\n        line = '';\n      }\n    }\n    if (line) {\n      lines.push(line);\n    }\n    str = lines.join('\\n');\n  } else {\n    str = restoreIgnore(restoreCustom(results.join('')));\n  }\n  return options.collapseWhitespace ? collapseWhitespace(str, options, true, true) : str;\n}\nexport const minify = async function (value, options) {\n  const start = Date.now();\n  options = processOptions(options || {});\n  const result = await minifyHTML(value, options);\n  options.log('minified in: ' + (Date.now() - start) + 'ms');\n  return result;\n};\nexport default {\n  minify\n};","map":{"version":3,"names":["CleanCSS","decodeHTMLStrict","decodeHTML","RelateURL","minify","terser","HTMLParser","endTag","TokenChain","replaceAsync","trimWhitespace","str","replace","collapseWhitespaceAll","spaces","collapseWhitespace","options","trimLeft","trimRight","collapseAll","lineBreakBefore","lineBreakAfter","preserveLineBreaks","conservative","conservativeCollapse","inlineTags","Set","inlineTextTags","selfClosingInlineTags","collapseWhitespaceSmart","prevTag","nextTag","has","collapseInlineTagWhitespace","charAt","slice","isConditionalComment","text","test","isIgnoredComment","i","len","ignoreCustomComments","length","isEventAttribute","attrName","patterns","customEventAttributes","canRemoveAttributeQuotes","value","attributesInclude","attributes","attribute","name","toLowerCase","isAttributeRedundant","tag","attrValue","attrs","executableScriptsMimetypes","keepScriptsMimetypes","isScriptTypeAttribute","split","keepScriptTypeAttribute","isExecutableScript","isStyleLinkTypeAttribute","isStyleSheet","isSimpleBoolean","isBooleanValue","isBooleanAttribute","isUriTypeAttribute","isNumberTypeAttribute","isLinkType","isMediaQuery","srcsetTags","isSrcset","cleanAttributeValue","minifyJS","sortClassName","minifyURLs","minifyCSS","map","candidate","url","descriptor","match","num","suffix","join","isMetaViewport","numString","toString","isContentSecurityPolicy","customAttrCollapse","ignoreCSS","id","wrapCSS","type","unwrapCSS","matches","cleanConditionalComment","comment","processConditionalComments","prefix","minifyHTML","processScript","currentAttrs","processScripts","indexOf","optionalStartTags","optionalEndTags","headerTags","descriptionTags","pBlockTags","pInlineTags","rubyTags","rtcTag","optionTag","tableContentTags","tableSectionTags","cellTags","topLevelTags","compactTags","looseTags","trailingTags","htmlTags","canRemoveParentTag","optionalStartTag","isStartTagMandatory","optionalEndTag","canRemovePrecedingTag","reEmptyAttribute","RegExp","canDeleteEmptyAttribute","isValueEmpty","removeEmptyAttributes","hasAttrName","canRemoveElement","canCollapseWhitespace","canTrimWhitespace","normalizeAttr","attr","decodeEntities","removeRedundantAttributes","removeScriptTypeAttributes","removeStyleLinkTypeAttributes","buildAttr","normalized","hasUnarySlash","isLast","uidAttr","attrQuote","quote","attrFragment","emittedAttrValue","removeAttributeQuotes","preventAttributesEscaping","quoteCharacter","apos","quot","removeTagWhitespace","collapseBooleanAttributes","customAssign","customOpen","customClose","identity","identityAsync","Promise","resolve","processOptions","inputOptions","html5","ignoreCustomFragments","includeAutoGeneratedTags","log","Object","keys","forEach","key","option","cleanCssOptions","inputCSS","_err","output","errors","outputCSS","styles","terserOptions","parse","bare_returns","inline","start","code","result","error","relateUrlOptions","site","relate","err","uniqueId","Math","random","specialContentTags","createSortFns","uidIgnore","attrChains","sortAttributes","create","classChain","attrNames","shouldSkipUID","token","uid","shouldSkipUIDs","scan","input","currentTag","currentType","parser","add","filter","end","chars","attrSorters","createSorter","sorter","attrMap","names","index","push","sort","shift","partialMarkup","buffer","charsPrevTag","currentChars","hasChars","stackNoTrimWhitespace","stackNoCollapseWhitespace","ignoredMarkupChunks","ignoredCustomMarkupChunks","uidPattern","group1","pattern","customFragments","re","source","reCustomIgnore","fn","chunks","ids","warnings","warning","exec","then","chunk","_canCollapseWhitespace","_canTrimWhitespace","removeStartTag","max","removeEndTag","trimTrailingWhitespace","squashTrailingWhitespace","charsIndex","item","continueOnParseError","customAttrAssign","customAttrSurround","unary","unarySlash","autoGenerated","caseSensitive","keepClosingSlash","optional","removeOptionalTags","htmlTag","openTag","parts","unshift","apply","pop","getPrototypeOf","isElementEmpty","removeEmptyElements","prevComment","trailingSpaces","tagIndex","lastIndexOf","nonStandard","removeComments","doctype","useShortDoctype","joinResultSegments","trimCustomFragments","results","restoreCustom","restoreIgnore","maxLineLength","noNewlinesBeforeTagClose","line","lines","isClosingTag","Boolean","shouldKeepSameLine","Date","now"],"sources":["F:/landinghub-iconic/node_modules/.pnpm/html-minifier-terser@7.2.0/node_modules/html-minifier-terser/src/htmlminifier.js"],"sourcesContent":["import CleanCSS from 'clean-css';\nimport { decodeHTMLStrict, decodeHTML } from 'entities';\nimport RelateURL from 'relateurl';\nimport { minify as terser } from 'terser';\n\nimport { HTMLParser, endTag } from './htmlparser.js';\nimport TokenChain from './tokenchain.js';\nimport { replaceAsync } from './utils.js';\n\nfunction trimWhitespace(str) {\n  return str && str.replace(/^[ \\n\\r\\t\\f]+/, '').replace(/[ \\n\\r\\t\\f]+$/, '');\n}\n\nfunction collapseWhitespaceAll(str) {\n  // Non-breaking space is specifically handled inside the replacer function here:\n  return str && str.replace(/[ \\n\\r\\t\\f\\xA0]+/g, function (spaces) {\n    return spaces === '\\t' ? '\\t' : spaces.replace(/(^|\\xA0+)[^\\xA0]+/g, '$1 ');\n  });\n}\n\nfunction collapseWhitespace(str, options, trimLeft, trimRight, collapseAll) {\n  let lineBreakBefore = ''; let lineBreakAfter = '';\n\n  if (options.preserveLineBreaks) {\n    str = str.replace(/^[ \\n\\r\\t\\f]*?[\\n\\r][ \\n\\r\\t\\f]*/, function () {\n      lineBreakBefore = '\\n';\n      return '';\n    }).replace(/[ \\n\\r\\t\\f]*?[\\n\\r][ \\n\\r\\t\\f]*$/, function () {\n      lineBreakAfter = '\\n';\n      return '';\n    });\n  }\n\n  if (trimLeft) {\n    // Non-breaking space is specifically handled inside the replacer function here:\n    str = str.replace(/^[ \\n\\r\\t\\f\\xA0]+/, function (spaces) {\n      const conservative = !lineBreakBefore && options.conservativeCollapse;\n      if (conservative && spaces === '\\t') {\n        return '\\t';\n      }\n      return spaces.replace(/^[^\\xA0]+/, '').replace(/(\\xA0+)[^\\xA0]+/g, '$1 ') || (conservative ? ' ' : '');\n    });\n  }\n\n  if (trimRight) {\n    // Non-breaking space is specifically handled inside the replacer function here:\n    str = str.replace(/[ \\n\\r\\t\\f\\xA0]+$/, function (spaces) {\n      const conservative = !lineBreakAfter && options.conservativeCollapse;\n      if (conservative && spaces === '\\t') {\n        return '\\t';\n      }\n      return spaces.replace(/[^\\xA0]+(\\xA0+)/g, ' $1').replace(/[^\\xA0]+$/, '') || (conservative ? ' ' : '');\n    });\n  }\n\n  if (collapseAll) {\n    // strip non space whitespace then compress spaces to one\n    str = collapseWhitespaceAll(str);\n  }\n\n  return lineBreakBefore + str + lineBreakAfter;\n}\n\n// non-empty tags that will maintain whitespace around them\nconst inlineTags = new Set(['a', 'abbr', 'acronym', 'b', 'bdi', 'bdo', 'big', 'button', 'cite', 'code', 'del', 'dfn', 'em', 'font', 'i', 'ins', 'kbd', 'label', 'mark', 'math', 'nobr', 'object', 'q', 'rp', 'rt', 'rtc', 'ruby', 's', 'samp', 'select', 'small', 'span', 'strike', 'strong', 'sub', 'sup', 'svg', 'textarea', 'time', 'tt', 'u', 'var']);\n// non-empty tags that will maintain whitespace within them\nconst inlineTextTags = new Set(['a', 'abbr', 'acronym', 'b', 'big', 'del', 'em', 'font', 'i', 'ins', 'kbd', 'mark', 'nobr', 'rp', 's', 'samp', 'small', 'span', 'strike', 'strong', 'sub', 'sup', 'time', 'tt', 'u', 'var']);\n// self-closing tags that will maintain whitespace around them\nconst selfClosingInlineTags = new Set(['comment', 'img', 'input', 'wbr']);\n\nfunction collapseWhitespaceSmart(str, prevTag, nextTag, options) {\n  let trimLeft = prevTag && !selfClosingInlineTags.has(prevTag);\n  if (trimLeft && !options.collapseInlineTagWhitespace) {\n    trimLeft = prevTag.charAt(0) === '/' ? !inlineTags.has(prevTag.slice(1)) : !inlineTextTags.has(prevTag);\n  }\n  let trimRight = nextTag && !selfClosingInlineTags.has(nextTag);\n  if (trimRight && !options.collapseInlineTagWhitespace) {\n    trimRight = nextTag.charAt(0) === '/' ? !inlineTextTags.has(nextTag.slice(1)) : !inlineTags.has(nextTag);\n  }\n  return collapseWhitespace(str, options, trimLeft, trimRight, prevTag && nextTag);\n}\n\nfunction isConditionalComment(text) {\n  return /^\\[if\\s[^\\]]+]|\\[endif]$/.test(text);\n}\n\nfunction isIgnoredComment(text, options) {\n  for (let i = 0, len = options.ignoreCustomComments.length; i < len; i++) {\n    if (options.ignoreCustomComments[i].test(text)) {\n      return true;\n    }\n  }\n  return false;\n}\n\nfunction isEventAttribute(attrName, options) {\n  const patterns = options.customEventAttributes;\n  if (patterns) {\n    for (let i = patterns.length; i--;) {\n      if (patterns[i].test(attrName)) {\n        return true;\n      }\n    }\n    return false;\n  }\n  return /^on[a-z]{3,}$/.test(attrName);\n}\n\nfunction canRemoveAttributeQuotes(value) {\n  // https://mathiasbynens.be/notes/unquoted-attribute-values\n  return /^[^ \\t\\n\\f\\r\"'`=<>]+$/.test(value);\n}\n\nfunction attributesInclude(attributes, attribute) {\n  for (let i = attributes.length; i--;) {\n    if (attributes[i].name.toLowerCase() === attribute) {\n      return true;\n    }\n  }\n  return false;\n}\n\nfunction isAttributeRedundant(tag, attrName, attrValue, attrs) {\n  attrValue = attrValue ? trimWhitespace(attrValue.toLowerCase()) : '';\n\n  return (\n    (tag === 'script' &&\n      attrName === 'language' &&\n      attrValue === 'javascript') ||\n\n    (tag === 'form' &&\n      attrName === 'method' &&\n      attrValue === 'get') ||\n\n    (tag === 'input' &&\n      attrName === 'type' &&\n      attrValue === 'text') ||\n\n    (tag === 'script' &&\n      attrName === 'charset' &&\n      !attributesInclude(attrs, 'src')) ||\n\n    (tag === 'a' &&\n      attrName === 'name' &&\n      attributesInclude(attrs, 'id')) ||\n\n    (tag === 'area' &&\n      attrName === 'shape' &&\n      attrValue === 'rect')\n  );\n}\n\n// https://mathiasbynens.be/demo/javascript-mime-type\n// https://developer.mozilla.org/en/docs/Web/HTML/Element/script#attr-type\nconst executableScriptsMimetypes = new Set([\n  'text/javascript',\n  'text/ecmascript',\n  'text/jscript',\n  'application/javascript',\n  'application/x-javascript',\n  'application/ecmascript',\n  'module'\n]);\n\nconst keepScriptsMimetypes = new Set([\n  'module'\n]);\n\nfunction isScriptTypeAttribute(attrValue = '') {\n  attrValue = trimWhitespace(attrValue.split(/;/, 2)[0]).toLowerCase();\n  return attrValue === '' || executableScriptsMimetypes.has(attrValue);\n}\n\nfunction keepScriptTypeAttribute(attrValue = '') {\n  attrValue = trimWhitespace(attrValue.split(/;/, 2)[0]).toLowerCase();\n  return keepScriptsMimetypes.has(attrValue);\n}\n\nfunction isExecutableScript(tag, attrs) {\n  if (tag !== 'script') {\n    return false;\n  }\n  for (let i = 0, len = attrs.length; i < len; i++) {\n    const attrName = attrs[i].name.toLowerCase();\n    if (attrName === 'type') {\n      return isScriptTypeAttribute(attrs[i].value);\n    }\n  }\n  return true;\n}\n\nfunction isStyleLinkTypeAttribute(attrValue = '') {\n  attrValue = trimWhitespace(attrValue).toLowerCase();\n  return attrValue === '' || attrValue === 'text/css';\n}\n\nfunction isStyleSheet(tag, attrs) {\n  if (tag !== 'style') {\n    return false;\n  }\n  for (let i = 0, len = attrs.length; i < len; i++) {\n    const attrName = attrs[i].name.toLowerCase();\n    if (attrName === 'type') {\n      return isStyleLinkTypeAttribute(attrs[i].value);\n    }\n  }\n  return true;\n}\n\nconst isSimpleBoolean = new Set(['allowfullscreen', 'async', 'autofocus', 'autoplay', 'checked', 'compact', 'controls', 'declare', 'default', 'defaultchecked', 'defaultmuted', 'defaultselected', 'defer', 'disabled', 'enabled', 'formnovalidate', 'hidden', 'indeterminate', 'inert', 'ismap', 'itemscope', 'loop', 'multiple', 'muted', 'nohref', 'noresize', 'noshade', 'novalidate', 'nowrap', 'open', 'pauseonexit', 'readonly', 'required', 'reversed', 'scoped', 'seamless', 'selected', 'sortable', 'truespeed', 'typemustmatch', 'visible']);\nconst isBooleanValue = new Set(['true', 'false']);\n\nfunction isBooleanAttribute(attrName, attrValue) {\n  return isSimpleBoolean.has(attrName) || (attrName === 'draggable' && !isBooleanValue.has(attrValue));\n}\n\nfunction isUriTypeAttribute(attrName, tag) {\n  return (\n    (/^(?:a|area|link|base)$/.test(tag) && attrName === 'href') ||\n    (tag === 'img' && /^(?:src|longdesc|usemap)$/.test(attrName)) ||\n    (tag === 'object' && /^(?:classid|codebase|data|usemap)$/.test(attrName)) ||\n    (tag === 'q' && attrName === 'cite') ||\n    (tag === 'blockquote' && attrName === 'cite') ||\n    ((tag === 'ins' || tag === 'del') && attrName === 'cite') ||\n    (tag === 'form' && attrName === 'action') ||\n    (tag === 'input' && (attrName === 'src' || attrName === 'usemap')) ||\n    (tag === 'head' && attrName === 'profile') ||\n    (tag === 'script' && (attrName === 'src' || attrName === 'for'))\n  );\n}\n\nfunction isNumberTypeAttribute(attrName, tag) {\n  return (\n    (/^(?:a|area|object|button)$/.test(tag) && attrName === 'tabindex') ||\n    (tag === 'input' && (attrName === 'maxlength' || attrName === 'tabindex')) ||\n    (tag === 'select' && (attrName === 'size' || attrName === 'tabindex')) ||\n    (tag === 'textarea' && /^(?:rows|cols|tabindex)$/.test(attrName)) ||\n    (tag === 'colgroup' && attrName === 'span') ||\n    (tag === 'col' && attrName === 'span') ||\n    ((tag === 'th' || tag === 'td') && (attrName === 'rowspan' || attrName === 'colspan'))\n  );\n}\n\nfunction isLinkType(tag, attrs, value) {\n  if (tag !== 'link') {\n    return false;\n  }\n  for (let i = 0, len = attrs.length; i < len; i++) {\n    if (attrs[i].name === 'rel' && attrs[i].value === value) {\n      return true;\n    }\n  }\n}\n\nfunction isMediaQuery(tag, attrs, attrName) {\n  return attrName === 'media' && (isLinkType(tag, attrs, 'stylesheet') || isStyleSheet(tag, attrs));\n}\n\nconst srcsetTags = new Set(['img', 'source']);\n\nfunction isSrcset(attrName, tag) {\n  return attrName === 'srcset' && srcsetTags.has(tag);\n}\n\nasync function cleanAttributeValue(tag, attrName, attrValue, options, attrs) {\n  if (isEventAttribute(attrName, options)) {\n    attrValue = trimWhitespace(attrValue).replace(/^javascript:\\s*/i, '');\n    return options.minifyJS(attrValue, true);\n  } else if (attrName === 'class') {\n    attrValue = trimWhitespace(attrValue);\n    if (options.sortClassName) {\n      attrValue = options.sortClassName(attrValue);\n    } else {\n      attrValue = collapseWhitespaceAll(attrValue);\n    }\n    return attrValue;\n  } else if (isUriTypeAttribute(attrName, tag)) {\n    attrValue = trimWhitespace(attrValue);\n    return isLinkType(tag, attrs, 'canonical') ? attrValue : options.minifyURLs(attrValue);\n  } else if (isNumberTypeAttribute(attrName, tag)) {\n    return trimWhitespace(attrValue);\n  } else if (attrName === 'style') {\n    attrValue = trimWhitespace(attrValue);\n    if (attrValue) {\n      if (/;$/.test(attrValue) && !/&#?[0-9a-zA-Z]+;$/.test(attrValue)) {\n        attrValue = attrValue.replace(/\\s*;$/, ';');\n      }\n      attrValue = await options.minifyCSS(attrValue, 'inline');\n    }\n    return attrValue;\n  } else if (isSrcset(attrName, tag)) {\n    // https://html.spec.whatwg.org/multipage/embedded-content.html#attr-img-srcset\n    attrValue = trimWhitespace(attrValue).split(/\\s+,\\s*|\\s*,\\s+/).map(function (candidate) {\n      let url = candidate;\n      let descriptor = '';\n      const match = candidate.match(/\\s+([1-9][0-9]*w|[0-9]+(?:\\.[0-9]+)?x)$/);\n      if (match) {\n        url = url.slice(0, -match[0].length);\n        const num = +match[1].slice(0, -1);\n        const suffix = match[1].slice(-1);\n        if (num !== 1 || suffix !== 'x') {\n          descriptor = ' ' + num + suffix;\n        }\n      }\n      return options.minifyURLs(url) + descriptor;\n    }).join(', ');\n  } else if (isMetaViewport(tag, attrs) && attrName === 'content') {\n    attrValue = attrValue.replace(/\\s+/g, '').replace(/[0-9]+\\.[0-9]+/g, function (numString) {\n      // \"0.90000\" -> \"0.9\"\n      // \"1.0\" -> \"1\"\n      // \"1.0001\" -> \"1.0001\" (unchanged)\n      return (+numString).toString();\n    });\n  } else if (isContentSecurityPolicy(tag, attrs) && attrName.toLowerCase() === 'content') {\n    return collapseWhitespaceAll(attrValue);\n  } else if (options.customAttrCollapse && options.customAttrCollapse.test(attrName)) {\n    attrValue = trimWhitespace(attrValue.replace(/ ?[\\n\\r]+ ?/g, '').replace(/\\s{2,}/g, options.conservativeCollapse ? ' ' : ''));\n  } else if (tag === 'script' && attrName === 'type') {\n    attrValue = trimWhitespace(attrValue.replace(/\\s*;\\s*/g, ';'));\n  } else if (isMediaQuery(tag, attrs, attrName)) {\n    attrValue = trimWhitespace(attrValue);\n    return options.minifyCSS(attrValue, 'media');\n  }\n  return attrValue;\n}\n\nfunction isMetaViewport(tag, attrs) {\n  if (tag !== 'meta') {\n    return false;\n  }\n  for (let i = 0, len = attrs.length; i < len; i++) {\n    if (attrs[i].name === 'name' && attrs[i].value === 'viewport') {\n      return true;\n    }\n  }\n}\n\nfunction isContentSecurityPolicy(tag, attrs) {\n  if (tag !== 'meta') {\n    return false;\n  }\n  for (let i = 0, len = attrs.length; i < len; i++) {\n    if (attrs[i].name.toLowerCase() === 'http-equiv' && attrs[i].value.toLowerCase() === 'content-security-policy') {\n      return true;\n    }\n  }\n}\n\nfunction ignoreCSS(id) {\n  return '/* clean-css ignore:start */' + id + '/* clean-css ignore:end */';\n}\n\n// Wrap CSS declarations for CleanCSS > 3.x\n// See https://github.com/jakubpawlowicz/clean-css/issues/418\nfunction wrapCSS(text, type) {\n  switch (type) {\n    case 'inline':\n      return '*{' + text + '}';\n    case 'media':\n      return '@media ' + text + '{a{top:0}}';\n    default:\n      return text;\n  }\n}\n\nfunction unwrapCSS(text, type) {\n  let matches;\n  switch (type) {\n    case 'inline':\n      matches = text.match(/^\\*\\{([\\s\\S]*)\\}$/);\n      break;\n    case 'media':\n      matches = text.match(/^@media ([\\s\\S]*?)\\s*{[\\s\\S]*}$/);\n      break;\n  }\n  return matches ? matches[1] : text;\n}\n\nasync function cleanConditionalComment(comment, options) {\n  return options.processConditionalComments\n    ? await replaceAsync(comment, /^(\\[if\\s[^\\]]+]>)([\\s\\S]*?)(<!\\[endif])$/, async function (match, prefix, text, suffix) {\n      return prefix + await minifyHTML(text, options, true) + suffix;\n    })\n    : comment;\n}\n\nasync function processScript(text, options, currentAttrs) {\n  for (let i = 0, len = currentAttrs.length; i < len; i++) {\n    if (currentAttrs[i].name.toLowerCase() === 'type' &&\n      options.processScripts.indexOf(currentAttrs[i].value) > -1) {\n      return await minifyHTML(text, options);\n    }\n  }\n  return text;\n}\n\n// Tag omission rules from https://html.spec.whatwg.org/multipage/syntax.html#optional-tags\n// with the following deviations:\n// - retain <body> if followed by <noscript>\n// - </rb>, </rt>, </rtc>, </rp> & </tfoot> follow https://www.w3.org/TR/html5/syntax.html#optional-tags\n// - retain all tags which are adjacent to non-standard HTML tags\nconst optionalStartTags = new Set(['html', 'head', 'body', 'colgroup', 'tbody']);\nconst optionalEndTags = new Set(['html', 'head', 'body', 'li', 'dt', 'dd', 'p', 'rb', 'rt', 'rtc', 'rp', 'optgroup', 'option', 'colgroup', 'caption', 'thead', 'tbody', 'tfoot', 'tr', 'td', 'th']);\nconst headerTags = new Set(['meta', 'link', 'script', 'style', 'template', 'noscript']);\nconst descriptionTags = new Set(['dt', 'dd']);\nconst pBlockTags = new Set(['address', 'article', 'aside', 'blockquote', 'details', 'div', 'dl', 'fieldset', 'figcaption', 'figure', 'footer', 'form', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'header', 'hgroup', 'hr', 'main', 'menu', 'nav', 'ol', 'p', 'pre', 'section', 'table', 'ul']);\nconst pInlineTags = new Set(['a', 'audio', 'del', 'ins', 'map', 'noscript', 'video']);\nconst rubyTags = new Set(['rb', 'rt', 'rtc', 'rp']);\nconst rtcTag = new Set(['rb', 'rtc', 'rp']);\nconst optionTag = new Set(['option', 'optgroup']);\nconst tableContentTags = new Set(['tbody', 'tfoot']);\nconst tableSectionTags = new Set(['thead', 'tbody', 'tfoot']);\nconst cellTags = new Set(['td', 'th']);\nconst topLevelTags = new Set(['html', 'head', 'body']);\nconst compactTags = new Set(['html', 'body']);\nconst looseTags = new Set(['head', 'colgroup', 'caption']);\nconst trailingTags = new Set(['dt', 'thead']);\nconst htmlTags = new Set(['a', 'abbr', 'acronym', 'address', 'applet', 'area', 'article', 'aside', 'audio', 'b', 'base', 'basefont', 'bdi', 'bdo', 'bgsound', 'big', 'blink', 'blockquote', 'body', 'br', 'button', 'canvas', 'caption', 'center', 'cite', 'code', 'col', 'colgroup', 'command', 'content', 'data', 'datalist', 'dd', 'del', 'details', 'dfn', 'dialog', 'dir', 'div', 'dl', 'dt', 'element', 'em', 'embed', 'fieldset', 'figcaption', 'figure', 'font', 'footer', 'form', 'frame', 'frameset', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'head', 'header', 'hgroup', 'hr', 'html', 'i', 'iframe', 'image', 'img', 'input', 'ins', 'isindex', 'kbd', 'keygen', 'label', 'legend', 'li', 'link', 'listing', 'main', 'map', 'mark', 'marquee', 'menu', 'menuitem', 'meta', 'meter', 'multicol', 'nav', 'nobr', 'noembed', 'noframes', 'noscript', 'object', 'ol', 'optgroup', 'option', 'output', 'p', 'param', 'picture', 'plaintext', 'pre', 'progress', 'q', 'rb', 'rp', 'rt', 'rtc', 'ruby', 's', 'samp', 'script', 'section', 'select', 'shadow', 'small', 'source', 'spacer', 'span', 'strike', 'strong', 'style', 'sub', 'summary', 'sup', 'table', 'tbody', 'td', 'template', 'textarea', 'tfoot', 'th', 'thead', 'time', 'title', 'tr', 'track', 'tt', 'u', 'ul', 'var', 'video', 'wbr', 'xmp']);\n\nfunction canRemoveParentTag(optionalStartTag, tag) {\n  switch (optionalStartTag) {\n    case 'html':\n    case 'head':\n      return true;\n    case 'body':\n      return !headerTags.has(tag);\n    case 'colgroup':\n      return tag === 'col';\n    case 'tbody':\n      return tag === 'tr';\n  }\n  return false;\n}\n\nfunction isStartTagMandatory(optionalEndTag, tag) {\n  switch (tag) {\n    case 'colgroup':\n      return optionalEndTag === 'colgroup';\n    case 'tbody':\n      return tableSectionTags.has(optionalEndTag);\n  }\n  return false;\n}\n\nfunction canRemovePrecedingTag(optionalEndTag, tag) {\n  switch (optionalEndTag) {\n    case 'html':\n    case 'head':\n    case 'body':\n    case 'colgroup':\n    case 'caption':\n      return true;\n    case 'li':\n    case 'optgroup':\n    case 'tr':\n      return tag === optionalEndTag;\n    case 'dt':\n    case 'dd':\n      return descriptionTags.has(tag);\n    case 'p':\n      return pBlockTags.has(tag);\n    case 'rb':\n    case 'rt':\n    case 'rp':\n      return rubyTags.has(tag);\n    case 'rtc':\n      return rtcTag.has(tag);\n    case 'option':\n      return optionTag.has(tag);\n    case 'thead':\n    case 'tbody':\n      return tableContentTags.has(tag);\n    case 'tfoot':\n      return tag === 'tbody';\n    case 'td':\n    case 'th':\n      return cellTags.has(tag);\n  }\n  return false;\n}\n\nconst reEmptyAttribute = new RegExp(\n  '^(?:class|id|style|title|lang|dir|on(?:focus|blur|change|click|dblclick|mouse(' +\n  '?:down|up|over|move|out)|key(?:press|down|up)))$');\n\nfunction canDeleteEmptyAttribute(tag, attrName, attrValue, options) {\n  const isValueEmpty = !attrValue || /^\\s*$/.test(attrValue);\n  if (!isValueEmpty) {\n    return false;\n  }\n  if (typeof options.removeEmptyAttributes === 'function') {\n    return options.removeEmptyAttributes(attrName, tag);\n  }\n  return (tag === 'input' && attrName === 'value') || reEmptyAttribute.test(attrName);\n}\n\nfunction hasAttrName(name, attrs) {\n  for (let i = attrs.length - 1; i >= 0; i--) {\n    if (attrs[i].name === name) {\n      return true;\n    }\n  }\n  return false;\n}\n\nfunction canRemoveElement(tag, attrs) {\n  switch (tag) {\n    case 'textarea':\n      return false;\n    case 'audio':\n    case 'script':\n    case 'video':\n      if (hasAttrName('src', attrs)) {\n        return false;\n      }\n      break;\n    case 'iframe':\n      if (hasAttrName('src', attrs) || hasAttrName('srcdoc', attrs)) {\n        return false;\n      }\n      break;\n    case 'object':\n      if (hasAttrName('data', attrs)) {\n        return false;\n      }\n      break;\n    case 'applet':\n      if (hasAttrName('code', attrs)) {\n        return false;\n      }\n      break;\n  }\n  return true;\n}\n\nfunction canCollapseWhitespace(tag) {\n  return !/^(?:script|style|pre|textarea)$/.test(tag);\n}\n\nfunction canTrimWhitespace(tag) {\n  return !/^(?:pre|textarea)$/.test(tag);\n}\n\nasync function normalizeAttr(attr, attrs, tag, options) {\n  const attrName = options.name(attr.name);\n  let attrValue = attr.value;\n\n  if (options.decodeEntities && attrValue) {\n    attrValue = decodeHTMLStrict(attrValue);\n  }\n\n  if ((options.removeRedundantAttributes &&\n    isAttributeRedundant(tag, attrName, attrValue, attrs)) ||\n    (options.removeScriptTypeAttributes && tag === 'script' &&\n      attrName === 'type' && isScriptTypeAttribute(attrValue) && !keepScriptTypeAttribute(attrValue)) ||\n    (options.removeStyleLinkTypeAttributes && (tag === 'style' || tag === 'link') &&\n      attrName === 'type' && isStyleLinkTypeAttribute(attrValue))) {\n    return;\n  }\n\n  if (attrValue) {\n    attrValue = await cleanAttributeValue(tag, attrName, attrValue, options, attrs);\n  }\n\n  if (options.removeEmptyAttributes &&\n    canDeleteEmptyAttribute(tag, attrName, attrValue, options)) {\n    return;\n  }\n\n  if (options.decodeEntities && attrValue) {\n    attrValue = attrValue.replace(/&(#?[0-9a-zA-Z]+;)/g, '&amp;$1');\n  }\n\n  return {\n    attr,\n    name: attrName,\n    value: attrValue\n  };\n}\n\nfunction buildAttr(normalized, hasUnarySlash, options, isLast, uidAttr) {\n  const attrName = normalized.name;\n  let attrValue = normalized.value;\n  const attr = normalized.attr;\n  let attrQuote = attr.quote;\n  let attrFragment;\n  let emittedAttrValue;\n\n  if (typeof attrValue !== 'undefined' && (!options.removeAttributeQuotes ||\n    ~attrValue.indexOf(uidAttr) || !canRemoveAttributeQuotes(attrValue))) {\n    if (!options.preventAttributesEscaping) {\n      if (typeof options.quoteCharacter === 'undefined') {\n        const apos = (attrValue.match(/'/g) || []).length;\n        const quot = (attrValue.match(/\"/g) || []).length;\n        attrQuote = apos < quot ? '\\'' : '\"';\n      } else {\n        attrQuote = options.quoteCharacter === '\\'' ? '\\'' : '\"';\n      }\n      if (attrQuote === '\"') {\n        attrValue = attrValue.replace(/\"/g, '&#34;');\n      } else {\n        attrValue = attrValue.replace(/'/g, '&#39;');\n      }\n    }\n    emittedAttrValue = attrQuote + attrValue + attrQuote;\n    if (!isLast && !options.removeTagWhitespace) {\n      emittedAttrValue += ' ';\n    }\n  } else if (isLast && !hasUnarySlash && !/\\/$/.test(attrValue)) {\n    // make sure trailing slash is not interpreted as HTML self-closing tag\n    emittedAttrValue = attrValue;\n  } else {\n    emittedAttrValue = attrValue + ' ';\n  }\n\n  if (typeof attrValue === 'undefined' || (options.collapseBooleanAttributes &&\n    isBooleanAttribute(attrName.toLowerCase(), attrValue.toLowerCase()))) {\n    attrFragment = attrName;\n    if (!isLast) {\n      attrFragment += ' ';\n    }\n  } else {\n    attrFragment = attrName + attr.customAssign + emittedAttrValue;\n  }\n\n  return attr.customOpen + attrFragment + attr.customClose;\n}\n\nfunction identity(value) {\n  return value;\n}\n\nfunction identityAsync(value) {\n  return Promise.resolve(value);\n}\n\nconst processOptions = (inputOptions) => {\n  const options = {\n    name: function (name) {\n      return name.toLowerCase();\n    },\n    canCollapseWhitespace,\n    canTrimWhitespace,\n    html5: true,\n    ignoreCustomComments: [\n      /^!/,\n      /^\\s*#/\n    ],\n    ignoreCustomFragments: [\n      /<%[\\s\\S]*?%>/,\n      /<\\?[\\s\\S]*?\\?>/\n    ],\n    includeAutoGeneratedTags: true,\n    log: identity,\n    minifyCSS: identityAsync,\n    minifyJS: identity,\n    minifyURLs: identity\n  };\n\n  Object.keys(inputOptions).forEach(function (key) {\n    const option = inputOptions[key];\n\n    if (key === 'caseSensitive') {\n      if (option) {\n        options.name = identity;\n      }\n    } else if (key === 'log') {\n      if (typeof option === 'function') {\n        options.log = option;\n      }\n    } else if (key === 'minifyCSS' && typeof option !== 'function') {\n      if (!option) {\n        return;\n      }\n\n      const cleanCssOptions = typeof option === 'object' ? option : {};\n\n      options.minifyCSS = async function (text, type) {\n        text = text.replace(/(url\\s*\\(\\s*)(\"|'|)(.*?)\\2(\\s*\\))/ig, function (match, prefix, quote, url, suffix) {\n          return prefix + quote + options.minifyURLs(url) + quote + suffix;\n        });\n\n        const inputCSS = wrapCSS(text, type);\n\n        return new Promise((resolve) => {\n          new CleanCSS(cleanCssOptions).minify(inputCSS, (_err, output) => {\n            if (output.errors.length > 0) {\n              output.errors.forEach(options.log);\n              resolve(text);\n            }\n\n            const outputCSS = unwrapCSS(output.styles, type);\n            resolve(outputCSS);\n          });\n        });\n      };\n    } else if (key === 'minifyJS' && typeof option !== 'function') {\n      if (!option) {\n        return;\n      }\n\n      const terserOptions = typeof option === 'object' ? option : {};\n\n      terserOptions.parse = {\n        ...terserOptions.parse,\n        bare_returns: false\n      };\n\n      options.minifyJS = async function (text, inline) {\n        const start = text.match(/^\\s*<!--.*/);\n        const code = start ? text.slice(start[0].length).replace(/\\n\\s*-->\\s*$/, '') : text;\n\n        terserOptions.parse.bare_returns = inline;\n\n        try {\n          const result = await terser(code, terserOptions);\n          return result.code.replace(/;$/, '');\n        } catch (error) {\n          options.log(error);\n          return text;\n        }\n      };\n    } else if (key === 'minifyURLs' && typeof option !== 'function') {\n      if (!option) {\n        return;\n      }\n\n      let relateUrlOptions = option;\n\n      if (typeof option === 'string') {\n        relateUrlOptions = { site: option };\n      } else if (typeof option !== 'object') {\n        relateUrlOptions = {};\n      }\n\n      options.minifyURLs = function (text) {\n        try {\n          return RelateURL.relate(text, relateUrlOptions);\n        } catch (err) {\n          options.log(err);\n          return text;\n        }\n      };\n    } else {\n      options[key] = option;\n    }\n  });\n  return options;\n};\n\nfunction uniqueId(value) {\n  let id;\n  do {\n    id = Math.random().toString(36).replace(/^0\\.[0-9]*/, '');\n  } while (~value.indexOf(id));\n  return id;\n}\n\nconst specialContentTags = new Set(['script', 'style']);\n\nasync function createSortFns(value, options, uidIgnore, uidAttr) {\n  const attrChains = options.sortAttributes && Object.create(null);\n  const classChain = options.sortClassName && new TokenChain();\n\n  function attrNames(attrs) {\n    return attrs.map(function (attr) {\n      return options.name(attr.name);\n    });\n  }\n\n  function shouldSkipUID(token, uid) {\n    return !uid || token.indexOf(uid) === -1;\n  }\n\n  function shouldSkipUIDs(token) {\n    return shouldSkipUID(token, uidIgnore) && shouldSkipUID(token, uidAttr);\n  }\n\n  async function scan(input) {\n    let currentTag, currentType;\n    const parser = new HTMLParser(input, {\n      start: function (tag, attrs) {\n        if (attrChains) {\n          if (!attrChains[tag]) {\n            attrChains[tag] = new TokenChain();\n          }\n          attrChains[tag].add(attrNames(attrs).filter(shouldSkipUIDs));\n        }\n        for (let i = 0, len = attrs.length; i < len; i++) {\n          const attr = attrs[i];\n          if (classChain && attr.value && options.name(attr.name) === 'class') {\n            classChain.add(trimWhitespace(attr.value).split(/[ \\t\\n\\f\\r]+/).filter(shouldSkipUIDs));\n          } else if (options.processScripts && attr.name.toLowerCase() === 'type') {\n            currentTag = tag;\n            currentType = attr.value;\n          }\n        }\n      },\n      end: function () {\n        currentTag = '';\n      },\n      chars: async function (text) {\n        if (options.processScripts && specialContentTags.has(currentTag) &&\n          options.processScripts.indexOf(currentType) > -1) {\n          await scan(text);\n        }\n      }\n    });\n\n    await parser.parse();\n  }\n\n  const log = options.log;\n  options.log = identity;\n  options.sortAttributes = false;\n  options.sortClassName = false;\n  await scan(await minifyHTML(value, options));\n  options.log = log;\n  if (attrChains) {\n    const attrSorters = Object.create(null);\n    for (const tag in attrChains) {\n      attrSorters[tag] = attrChains[tag].createSorter();\n    }\n    options.sortAttributes = function (tag, attrs) {\n      const sorter = attrSorters[tag];\n      if (sorter) {\n        const attrMap = Object.create(null);\n        const names = attrNames(attrs);\n        names.forEach(function (name, index) {\n          (attrMap[name] || (attrMap[name] = [])).push(attrs[index]);\n        });\n        sorter.sort(names).forEach(function (name, index) {\n          attrs[index] = attrMap[name].shift();\n        });\n      }\n    };\n  }\n  if (classChain) {\n    const sorter = classChain.createSorter();\n    options.sortClassName = function (value) {\n      return sorter.sort(value.split(/[ \\n\\f\\r]+/)).join(' ');\n    };\n  }\n}\n\nasync function minifyHTML(value, options, partialMarkup) {\n  if (options.collapseWhitespace) {\n    value = collapseWhitespace(value, options, true, true);\n  }\n\n  const buffer = [];\n  let charsPrevTag;\n  let currentChars = '';\n  let hasChars;\n  let currentTag = '';\n  let currentAttrs = [];\n  const stackNoTrimWhitespace = [];\n  const stackNoCollapseWhitespace = [];\n  let optionalStartTag = '';\n  let optionalEndTag = '';\n  const ignoredMarkupChunks = [];\n  const ignoredCustomMarkupChunks = [];\n  let uidIgnore;\n  let uidAttr;\n  let uidPattern;\n\n  // temporarily replace ignored chunks with comments,\n  // so that we don't have to worry what's there.\n  // for all we care there might be\n  // completely-horribly-broken-alien-non-html-emoj-cthulhu-filled content\n  value = value.replace(/<!-- htmlmin:ignore -->([\\s\\S]*?)<!-- htmlmin:ignore -->/g, function (match, group1) {\n    if (!uidIgnore) {\n      uidIgnore = uniqueId(value);\n      const pattern = new RegExp('^' + uidIgnore + '([0-9]+)$');\n      if (options.ignoreCustomComments) {\n        options.ignoreCustomComments = options.ignoreCustomComments.slice();\n      } else {\n        options.ignoreCustomComments = [];\n      }\n      options.ignoreCustomComments.push(pattern);\n    }\n    const token = '<!--' + uidIgnore + ignoredMarkupChunks.length + '-->';\n    ignoredMarkupChunks.push(group1);\n    return token;\n  });\n\n  const customFragments = options.ignoreCustomFragments.map(function (re) {\n    return re.source;\n  });\n  if (customFragments.length) {\n    const reCustomIgnore = new RegExp('\\\\s*(?:' + customFragments.join('|') + ')+\\\\s*', 'g');\n    // temporarily replace custom ignored fragments with unique attributes\n    value = value.replace(reCustomIgnore, function (match) {\n      if (!uidAttr) {\n        uidAttr = uniqueId(value);\n        uidPattern = new RegExp('(\\\\s*)' + uidAttr + '([0-9]+)' + uidAttr + '(\\\\s*)', 'g');\n\n        if (options.minifyCSS) {\n          options.minifyCSS = (function (fn) {\n            return function (text, type) {\n              text = text.replace(uidPattern, function (match, prefix, index) {\n                const chunks = ignoredCustomMarkupChunks[+index];\n                return chunks[1] + uidAttr + index + uidAttr + chunks[2];\n              });\n\n              const ids = [];\n              new CleanCSS().minify(wrapCSS(text, type)).warnings.forEach(function (warning) {\n                const match = uidPattern.exec(warning);\n                if (match) {\n                  const id = uidAttr + match[2] + uidAttr;\n                  text = text.replace(id, ignoreCSS(id));\n                  ids.push(id);\n                }\n              });\n\n              return fn(text, type).then(chunk => {\n                ids.forEach(function (id) {\n                  chunk = chunk.replace(ignoreCSS(id), id);\n                });\n\n                return chunk;\n              });\n            };\n          })(options.minifyCSS);\n        }\n\n        if (options.minifyJS) {\n          options.minifyJS = (function (fn) {\n            return function (text, type) {\n              return fn(text.replace(uidPattern, function (match, prefix, index) {\n                const chunks = ignoredCustomMarkupChunks[+index];\n                return chunks[1] + uidAttr + index + uidAttr + chunks[2];\n              }), type);\n            };\n          })(options.minifyJS);\n        }\n      }\n\n      const token = uidAttr + ignoredCustomMarkupChunks.length + uidAttr;\n      ignoredCustomMarkupChunks.push(/^(\\s*)[\\s\\S]*?(\\s*)$/.exec(match));\n      return '\\t' + token + '\\t';\n    });\n  }\n\n  if ((options.sortAttributes && typeof options.sortAttributes !== 'function') ||\n    (options.sortClassName && typeof options.sortClassName !== 'function')) {\n    await createSortFns(value, options, uidIgnore, uidAttr);\n  }\n\n  function _canCollapseWhitespace(tag, attrs) {\n    return options.canCollapseWhitespace(tag, attrs, canCollapseWhitespace);\n  }\n\n  function _canTrimWhitespace(tag, attrs) {\n    return options.canTrimWhitespace(tag, attrs, canTrimWhitespace);\n  }\n\n  function removeStartTag() {\n    let index = buffer.length - 1;\n    while (index > 0 && !/^<[^/!]/.test(buffer[index])) {\n      index--;\n    }\n    buffer.length = Math.max(0, index);\n  }\n\n  function removeEndTag() {\n    let index = buffer.length - 1;\n    while (index > 0 && !/^<\\//.test(buffer[index])) {\n      index--;\n    }\n    buffer.length = Math.max(0, index);\n  }\n\n  // look for trailing whitespaces, bypass any inline tags\n  function trimTrailingWhitespace(index, nextTag) {\n    for (let endTag = null; index >= 0 && _canTrimWhitespace(endTag); index--) {\n      const str = buffer[index];\n      const match = str.match(/^<\\/([\\w:-]+)>$/);\n      if (match) {\n        endTag = match[1];\n      } else if (/>$/.test(str) || (buffer[index] = collapseWhitespaceSmart(str, null, nextTag, options))) {\n        break;\n      }\n    }\n  }\n\n  // look for trailing whitespaces from previously processed text\n  // which may not be trimmed due to a following comment or an empty\n  // element which has now been removed\n  function squashTrailingWhitespace(nextTag) {\n    let charsIndex = buffer.length - 1;\n    if (buffer.length > 1) {\n      const item = buffer[buffer.length - 1];\n      if (/^(?:<!|$)/.test(item) && item.indexOf(uidIgnore) === -1) {\n        charsIndex--;\n      }\n    }\n    trimTrailingWhitespace(charsIndex, nextTag);\n  }\n\n  const parser = new HTMLParser(value, {\n    partialMarkup,\n    continueOnParseError: options.continueOnParseError,\n    customAttrAssign: options.customAttrAssign,\n    customAttrSurround: options.customAttrSurround,\n    html5: options.html5,\n\n    start: async function (tag, attrs, unary, unarySlash, autoGenerated) {\n      if (tag.toLowerCase() === 'svg') {\n        options = Object.create(options);\n        options.caseSensitive = true;\n        options.keepClosingSlash = true;\n        options.name = identity;\n      }\n      tag = options.name(tag);\n      currentTag = tag;\n      charsPrevTag = tag;\n      if (!inlineTextTags.has(tag)) {\n        currentChars = '';\n      }\n      hasChars = false;\n      currentAttrs = attrs;\n\n      let optional = options.removeOptionalTags;\n      if (optional) {\n        const htmlTag = htmlTags.has(tag);\n        // <html> may be omitted if first thing inside is not comment\n        // <head> may be omitted if first thing inside is an element\n        // <body> may be omitted if first thing inside is not space, comment, <meta>, <link>, <script>, <style> or <template>\n        // <colgroup> may be omitted if first thing inside is <col>\n        // <tbody> may be omitted if first thing inside is <tr>\n        if (htmlTag && canRemoveParentTag(optionalStartTag, tag)) {\n          removeStartTag();\n        }\n        optionalStartTag = '';\n        // end-tag-followed-by-start-tag omission rules\n        if (htmlTag && canRemovePrecedingTag(optionalEndTag, tag)) {\n          removeEndTag();\n          // <colgroup> cannot be omitted if preceding </colgroup> is omitted\n          // <tbody> cannot be omitted if preceding </tbody>, </thead> or </tfoot> is omitted\n          optional = !isStartTagMandatory(optionalEndTag, tag);\n        }\n        optionalEndTag = '';\n      }\n\n      // set whitespace flags for nested tags (eg. <code> within a <pre>)\n      if (options.collapseWhitespace) {\n        if (!stackNoTrimWhitespace.length) {\n          squashTrailingWhitespace(tag);\n        }\n        if (!unary) {\n          if (!_canTrimWhitespace(tag, attrs) || stackNoTrimWhitespace.length) {\n            stackNoTrimWhitespace.push(tag);\n          }\n          if (!_canCollapseWhitespace(tag, attrs) || stackNoCollapseWhitespace.length) {\n            stackNoCollapseWhitespace.push(tag);\n          }\n        }\n      }\n\n      const openTag = '<' + tag;\n      const hasUnarySlash = unarySlash && options.keepClosingSlash;\n\n      buffer.push(openTag);\n\n      if (options.sortAttributes) {\n        options.sortAttributes(tag, attrs);\n      }\n\n      const parts = [];\n      for (let i = attrs.length, isLast = true; --i >= 0;) {\n        const normalized = await normalizeAttr(attrs[i], attrs, tag, options);\n        if (normalized) {\n          parts.unshift(buildAttr(normalized, hasUnarySlash, options, isLast, uidAttr));\n          isLast = false;\n        }\n      }\n      if (parts.length > 0) {\n        buffer.push(' ');\n        buffer.push.apply(buffer, parts);\n      } else if (optional && optionalStartTags.has(tag)) {\n        // start tag must never be omitted if it has any attributes\n        optionalStartTag = tag;\n      }\n\n      buffer.push(buffer.pop() + (hasUnarySlash ? '/' : '') + '>');\n\n      if (autoGenerated && !options.includeAutoGeneratedTags) {\n        removeStartTag();\n        optionalStartTag = '';\n      }\n    },\n    end: function (tag, attrs, autoGenerated) {\n      if (tag.toLowerCase() === 'svg') {\n        options = Object.getPrototypeOf(options);\n      }\n      tag = options.name(tag);\n\n      // check if current tag is in a whitespace stack\n      if (options.collapseWhitespace) {\n        if (stackNoTrimWhitespace.length) {\n          if (tag === stackNoTrimWhitespace[stackNoTrimWhitespace.length - 1]) {\n            stackNoTrimWhitespace.pop();\n          }\n        } else {\n          squashTrailingWhitespace('/' + tag);\n        }\n        if (stackNoCollapseWhitespace.length &&\n          tag === stackNoCollapseWhitespace[stackNoCollapseWhitespace.length - 1]) {\n          stackNoCollapseWhitespace.pop();\n        }\n      }\n\n      let isElementEmpty = false;\n      if (tag === currentTag) {\n        currentTag = '';\n        isElementEmpty = !hasChars;\n      }\n\n      if (options.removeOptionalTags) {\n        // <html>, <head> or <body> may be omitted if the element is empty\n        if (isElementEmpty && topLevelTags.has(optionalStartTag)) {\n          removeStartTag();\n        }\n        optionalStartTag = '';\n        // </html> or </body> may be omitted if not followed by comment\n        // </head> may be omitted if not followed by space or comment\n        // </p> may be omitted if no more content in non-</a> parent\n        // except for </dt> or </thead>, end tags may be omitted if no more content in parent element\n        if (htmlTags.has(tag) && optionalEndTag && !trailingTags.has(optionalEndTag) && (optionalEndTag !== 'p' || !pInlineTags.has(tag))) {\n          removeEndTag();\n        }\n        optionalEndTag = optionalEndTags.has(tag) ? tag : '';\n      }\n\n      if (options.removeEmptyElements && isElementEmpty && canRemoveElement(tag, attrs)) {\n        // remove last \"element\" from buffer\n        removeStartTag();\n        optionalStartTag = '';\n        optionalEndTag = '';\n      } else {\n        if (autoGenerated && !options.includeAutoGeneratedTags) {\n          optionalEndTag = '';\n        } else {\n          buffer.push('</' + tag + '>');\n        }\n        charsPrevTag = '/' + tag;\n        if (!inlineTags.has(tag)) {\n          currentChars = '';\n        } else if (isElementEmpty) {\n          currentChars += '|';\n        }\n      }\n    },\n    chars: async function (text, prevTag, nextTag) {\n      prevTag = prevTag === '' ? 'comment' : prevTag;\n      nextTag = nextTag === '' ? 'comment' : nextTag;\n      if (options.decodeEntities && text && !specialContentTags.has(currentTag)) {\n        text = decodeHTML(text);\n      }\n      if (options.collapseWhitespace) {\n        if (!stackNoTrimWhitespace.length) {\n          if (prevTag === 'comment') {\n            const prevComment = buffer[buffer.length - 1];\n            if (prevComment.indexOf(uidIgnore) === -1) {\n              if (!prevComment) {\n                prevTag = charsPrevTag;\n              }\n              if (buffer.length > 1 && (!prevComment || (!options.conservativeCollapse && / $/.test(currentChars)))) {\n                const charsIndex = buffer.length - 2;\n                buffer[charsIndex] = buffer[charsIndex].replace(/\\s+$/, function (trailingSpaces) {\n                  text = trailingSpaces + text;\n                  return '';\n                });\n              }\n            }\n          }\n          if (prevTag) {\n            if (prevTag === '/nobr' || prevTag === 'wbr') {\n              if (/^\\s/.test(text)) {\n                let tagIndex = buffer.length - 1;\n                while (tagIndex > 0 && buffer[tagIndex].lastIndexOf('<' + prevTag) !== 0) {\n                  tagIndex--;\n                }\n                trimTrailingWhitespace(tagIndex - 1, 'br');\n              }\n            } else if (inlineTextTags.has(prevTag.charAt(0) === '/' ? prevTag.slice(1) : prevTag)) {\n              text = collapseWhitespace(text, options, /(?:^|\\s)$/.test(currentChars));\n            }\n          }\n          if (prevTag || nextTag) {\n            text = collapseWhitespaceSmart(text, prevTag, nextTag, options);\n          } else {\n            text = collapseWhitespace(text, options, true, true);\n          }\n          if (!text && /\\s$/.test(currentChars) && prevTag && prevTag.charAt(0) === '/') {\n            trimTrailingWhitespace(buffer.length - 1, nextTag);\n          }\n        }\n        if (!stackNoCollapseWhitespace.length && nextTag !== 'html' && !(prevTag && nextTag)) {\n          text = collapseWhitespace(text, options, false, false, true);\n        }\n      }\n      if (options.processScripts && specialContentTags.has(currentTag)) {\n        text = await processScript(text, options, currentAttrs);\n      }\n      if (isExecutableScript(currentTag, currentAttrs)) {\n        text = await options.minifyJS(text);\n      }\n      if (isStyleSheet(currentTag, currentAttrs)) {\n        text = await options.minifyCSS(text);\n      }\n      if (options.removeOptionalTags && text) {\n        // <html> may be omitted if first thing inside is not comment\n        // <body> may be omitted if first thing inside is not space, comment, <meta>, <link>, <script>, <style> or <template>\n        if (optionalStartTag === 'html' || (optionalStartTag === 'body' && !/^\\s/.test(text))) {\n          removeStartTag();\n        }\n        optionalStartTag = '';\n        // </html> or </body> may be omitted if not followed by comment\n        // </head>, </colgroup> or </caption> may be omitted if not followed by space or comment\n        if (compactTags.has(optionalEndTag) || (looseTags.has(optionalEndTag) && !/^\\s/.test(text))) {\n          removeEndTag();\n        }\n        optionalEndTag = '';\n      }\n      charsPrevTag = /^\\s*$/.test(text) ? prevTag : 'comment';\n      if (options.decodeEntities && text && !specialContentTags.has(currentTag)) {\n        // Escape any `&` symbols that start either:\n        // 1) a legacy named character reference (i.e. one that doesn't end with `;`)\n        // 2) or any other character reference (i.e. one that does end with `;`)\n        // Note that `&` can be escaped as `&amp`, without the semi-colon.\n        // https://mathiasbynens.be/notes/ambiguous-ampersands\n        text = text.replace(/&((?:Iacute|aacute|uacute|plusmn|Otilde|otilde|agrave|Agrave|Yacute|yacute|Oslash|oslash|atilde|Atilde|brvbar|ccedil|Ccedil|Ograve|curren|divide|eacute|Eacute|ograve|Oacute|egrave|Egrave|Ugrave|frac12|frac14|frac34|ugrave|oacute|iacute|Ntilde|ntilde|Uacute|middot|igrave|Igrave|iquest|Aacute|cedil|laquo|micro|iexcl|Icirc|icirc|acirc|Ucirc|Ecirc|ocirc|Ocirc|ecirc|ucirc|Aring|aring|AElig|aelig|acute|pound|raquo|Acirc|times|THORN|szlig|thorn|COPY|auml|ordf|ordm|Uuml|macr|uuml|Auml|ouml|Ouml|para|nbsp|euml|quot|QUOT|Euml|yuml|cent|sect|copy|sup1|sup2|sup3|iuml|Iuml|ETH|shy|reg|not|yen|amp|AMP|REG|uml|eth|deg|gt|GT|LT|lt)(?!;)|(?:#?[0-9a-zA-Z]+;))/g, '&amp$1').replace(/</g, '&lt;');\n      }\n      if (uidPattern && options.collapseWhitespace && stackNoTrimWhitespace.length) {\n        text = text.replace(uidPattern, function (match, prefix, index) {\n          return ignoredCustomMarkupChunks[+index][0];\n        });\n      }\n      currentChars += text;\n      if (text) {\n        hasChars = true;\n      }\n      buffer.push(text);\n    },\n    comment: async function (text, nonStandard) {\n      const prefix = nonStandard ? '<!' : '<!--';\n      const suffix = nonStandard ? '>' : '-->';\n      if (isConditionalComment(text)) {\n        text = prefix + await cleanConditionalComment(text, options) + suffix;\n      } else if (options.removeComments) {\n        if (isIgnoredComment(text, options)) {\n          text = '<!--' + text + '-->';\n        } else {\n          text = '';\n        }\n      } else {\n        text = prefix + text + suffix;\n      }\n      if (options.removeOptionalTags && text) {\n        // preceding comments suppress tag omissions\n        optionalStartTag = '';\n        optionalEndTag = '';\n      }\n      buffer.push(text);\n    },\n    doctype: function (doctype) {\n      buffer.push(options.useShortDoctype\n        ? '<!doctype' +\n        (options.removeTagWhitespace ? '' : ' ') + 'html>'\n        : collapseWhitespaceAll(doctype));\n    }\n  });\n\n  await parser.parse();\n\n  if (options.removeOptionalTags) {\n    // <html> may be omitted if first thing inside is not comment\n    // <head> or <body> may be omitted if empty\n    if (topLevelTags.has(optionalStartTag)) {\n      removeStartTag();\n    }\n    // except for </dt> or </thead>, end tags may be omitted if no more content in parent element\n    if (optionalEndTag && !trailingTags.has(optionalEndTag)) {\n      removeEndTag();\n    }\n  }\n  if (options.collapseWhitespace) {\n    squashTrailingWhitespace('br');\n  }\n\n  return joinResultSegments(buffer, options, uidPattern\n    ? function (str) {\n      return str.replace(uidPattern, function (match, prefix, index, suffix) {\n        let chunk = ignoredCustomMarkupChunks[+index][0];\n        if (options.collapseWhitespace) {\n          if (prefix !== '\\t') {\n            chunk = prefix + chunk;\n          }\n          if (suffix !== '\\t') {\n            chunk += suffix;\n          }\n          return collapseWhitespace(chunk, {\n            preserveLineBreaks: options.preserveLineBreaks,\n            conservativeCollapse: !options.trimCustomFragments\n          }, /^[ \\n\\r\\t\\f]/.test(chunk), /[ \\n\\r\\t\\f]$/.test(chunk));\n        }\n        return chunk;\n      });\n    }\n    : identity, uidIgnore\n    ? function (str) {\n      return str.replace(new RegExp('<!--' + uidIgnore + '([0-9]+)-->', 'g'), function (match, index) {\n        return ignoredMarkupChunks[+index];\n      });\n    }\n    : identity);\n}\n\nfunction joinResultSegments(results, options, restoreCustom, restoreIgnore) {\n  let str;\n  const maxLineLength = options.maxLineLength;\n  const noNewlinesBeforeTagClose = options.noNewlinesBeforeTagClose;\n\n  if (maxLineLength) {\n    let line = ''; const lines = [];\n    while (results.length) {\n      const len = line.length;\n      const end = results[0].indexOf('\\n');\n      const isClosingTag = Boolean(results[0].match(endTag));\n      const shouldKeepSameLine = noNewlinesBeforeTagClose && isClosingTag;\n\n      if (end < 0) {\n        line += restoreIgnore(restoreCustom(results.shift()));\n      } else {\n        line += restoreIgnore(restoreCustom(results[0].slice(0, end)));\n        results[0] = results[0].slice(end + 1);\n      }\n      if (len > 0 && line.length > maxLineLength && !shouldKeepSameLine) {\n        lines.push(line.slice(0, len));\n        line = line.slice(len);\n      } else if (end >= 0) {\n        lines.push(line);\n        line = '';\n      }\n    }\n    if (line) {\n      lines.push(line);\n    }\n    str = lines.join('\\n');\n  } else {\n    str = restoreIgnore(restoreCustom(results.join('')));\n  }\n  return options.collapseWhitespace ? collapseWhitespace(str, options, true, true) : str;\n}\n\nexport const minify = async function (value, options) {\n  const start = Date.now();\n  options = processOptions(options || {});\n  const result = await minifyHTML(value, options);\n  options.log('minified in: ' + (Date.now() - start) + 'ms');\n  return result;\n};\n\nexport default { minify };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}