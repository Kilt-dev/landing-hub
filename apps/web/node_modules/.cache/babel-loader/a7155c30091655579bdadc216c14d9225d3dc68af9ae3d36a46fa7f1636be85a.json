{"ast":null,"code":"/***********************************************************************\n\n  A JavaScript tokenizer / parser / beautifier / compressor.\n  https://github.com/mishoo/UglifyJS2\n\n  -------------------------------- (C) ---------------------------------\n\n                           Author: Mihai Bazon\n                         <mihai.bazon@gmail.com>\n                       http://mihai.bazon.net/blog\n\n  Distributed under the BSD license:\n\n    Copyright 2012 (c) Mihai Bazon <mihai.bazon@gmail.com>\n\n    Redistribution and use in source and binary forms, with or without\n    modification, are permitted provided that the following conditions\n    are met:\n\n        * Redistributions of source code must retain the above\n          copyright notice, this list of conditions and the following\n          disclaimer.\n\n        * Redistributions in binary form must reproduce the above\n          copyright notice, this list of conditions and the following\n          disclaimer in the documentation and/or other materials\n          provided with the distribution.\n\n    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER “AS IS” AND ANY\n    EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n    IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n    PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER BE\n    LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,\n    OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n    PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n    PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR\n    TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF\n    THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n    SUCH DAMAGE.\n\n ***********************************************************************/\n\nimport { AST_Accessor, AST_Array, AST_Assign, AST_Await, AST_Binary, AST_Block, AST_Call, AST_Case, AST_Chain, AST_Class, AST_ClassStaticBlock, AST_ClassExpression, AST_Conditional, AST_Default, AST_Defun, AST_Destructuring, AST_Do, AST_Exit, AST_Expansion, AST_For, AST_ForIn, AST_If, AST_LabeledStatement, AST_Lambda, AST_New, AST_Node, AST_Number, AST_ObjectKeyVal, AST_PropAccess, AST_Scope, AST_Sequence, AST_SimpleStatement, AST_Symbol, AST_SymbolCatch, AST_SymbolConst, AST_SymbolDeclaration, AST_SymbolDefun, AST_SymbolFunarg, AST_SymbolLambda, AST_SymbolRef, AST_This, AST_Toplevel, AST_Try, AST_Unary, AST_UnaryPrefix, AST_Undefined, AST_UsingDef, AST_VarDef, AST_VarDefLike, AST_While, AST_Yield, walk, walk_body, walk_parent } from \"../ast.js\";\nimport { HOP, make_node, noop } from \"../utils/index.js\";\nimport { lazy_op, is_modified, is_lhs } from \"./inference.js\";\nimport { INLINED, clear_flag } from \"./compressor-flags.js\";\nimport { read_property, has_break_or_continue, is_recursive_ref } from \"./common.js\";\n\n/**\n * Define the method AST_Node#reduce_vars, which goes through the AST in\n * execution order to perform basic flow analysis\n */\nfunction def_reduce_vars(node, func) {\n  node.DEFMETHOD(\"reduce_vars\", func);\n}\ndef_reduce_vars(AST_Node, noop);\n\n/** Clear definition properties */\nfunction reset_def(compressor, def) {\n  def.assignments = 0;\n  def.chained = false;\n  def.direct_access = false;\n  def.escaped = 0;\n  def.recursive_refs = 0;\n  def.references = [];\n  def.single_use = undefined;\n  if (def.scope.pinned() || def.orig[0] instanceof AST_SymbolFunarg && def.scope.uses_arguments) {\n    def.fixed = false;\n  } else if (def.orig[0] instanceof AST_SymbolConst || !compressor.exposed(def)) {\n    def.fixed = def.init;\n  } else {\n    def.fixed = false;\n  }\n}\nfunction reset_variables(tw, compressor, node) {\n  node.variables.forEach(function (def) {\n    reset_def(compressor, def);\n    if (def.fixed === null) {\n      tw.defs_to_safe_ids.set(def.id, tw.safe_ids);\n      mark(tw, def, true);\n    } else if (def.fixed) {\n      tw.loop_ids.set(def.id, tw.in_loop);\n      mark(tw, def, true);\n    }\n  });\n}\nfunction reset_block_variables(compressor, node) {\n  if (node.block_scope) node.block_scope.variables.forEach(def => {\n    reset_def(compressor, def);\n  });\n}\nfunction push(tw) {\n  tw.safe_ids = Object.create(tw.safe_ids);\n}\nfunction pop(tw) {\n  tw.safe_ids = Object.getPrototypeOf(tw.safe_ids);\n}\nfunction mark(tw, def, safe) {\n  tw.safe_ids[def.id] = safe;\n}\nfunction safe_to_read(tw, def) {\n  if (def.single_use == \"m\") return false;\n  if (tw.safe_ids[def.id]) {\n    if (def.fixed == null) {\n      var orig = def.orig[0];\n      if (orig instanceof AST_SymbolFunarg || orig.name == \"arguments\") return false;\n      def.fixed = make_node(AST_Undefined, orig);\n    }\n    return true;\n  }\n  return def.fixed instanceof AST_Defun;\n}\nfunction safe_to_assign(tw, def, scope, value) {\n  if (def.fixed === undefined) return true;\n  let def_safe_ids;\n  if (def.fixed === null && (def_safe_ids = tw.defs_to_safe_ids.get(def.id))) {\n    def_safe_ids[def.id] = false;\n    tw.defs_to_safe_ids.delete(def.id);\n    return true;\n  }\n  if (!HOP(tw.safe_ids, def.id)) return false;\n  if (!safe_to_read(tw, def)) return false;\n  if (def.fixed === false) return false;\n  if (def.fixed != null && (!value || def.references.length > def.assignments)) return false;\n  if (def.fixed instanceof AST_Defun) {\n    return value instanceof AST_Node && def.fixed.parent_scope === scope;\n  }\n  return def.orig.every(sym => {\n    return !(sym instanceof AST_SymbolConst || sym instanceof AST_SymbolDefun || sym instanceof AST_SymbolLambda);\n  });\n}\nfunction ref_once(tw, compressor, def) {\n  return compressor.option(\"unused\") && !def.scope.pinned() && def.references.length - def.recursive_refs == 1 && tw.loop_ids.get(def.id) === tw.in_loop;\n}\nfunction is_immutable(value) {\n  if (!value) return false;\n  return value.is_constant() || value instanceof AST_Lambda || value instanceof AST_This;\n}\n\n// A definition \"escapes\" when its value can leave the point of use.\n// Example: `a = b || c`\n// In this example, \"b\" and \"c\" are escaping, because they're going into \"a\"\n//\n// def.escaped is != 0 when it escapes.\n//\n// When greater than 1, it means that N chained properties will be read off\n// of that def before an escape occurs. This is useful for evaluating\n// property accesses, where you need to know when to stop.\nfunction mark_escaped(tw, d, scope, node, value, level = 0, depth = 1) {\n  var parent = tw.parent(level);\n  if (value) {\n    if (value.is_constant()) return;\n    if (value instanceof AST_ClassExpression) return;\n  }\n  if (parent instanceof AST_Assign && (parent.operator === \"=\" || parent.logical) && node === parent.right || parent instanceof AST_Call && (node !== parent.expression || parent instanceof AST_New) || parent instanceof AST_Exit && node === parent.value && node.scope !== d.scope || parent instanceof AST_VarDefLike && node === parent.value || parent instanceof AST_Yield && node === parent.value && node.scope !== d.scope) {\n    if (depth > 1 && !(value && value.is_constant_expression(scope))) depth = 1;\n    if (!d.escaped || d.escaped > depth) d.escaped = depth;\n    return;\n  } else if (parent instanceof AST_Array || parent instanceof AST_Await || parent instanceof AST_Binary && lazy_op.has(parent.operator) || parent instanceof AST_Conditional && node !== parent.condition || parent instanceof AST_Expansion || parent instanceof AST_Sequence && node === parent.tail_node()) {\n    mark_escaped(tw, d, scope, parent, parent, level + 1, depth);\n  } else if (parent instanceof AST_ObjectKeyVal && node === parent.value) {\n    var obj = tw.parent(level + 1);\n    mark_escaped(tw, d, scope, obj, obj, level + 2, depth);\n  } else if (parent instanceof AST_PropAccess && node === parent.expression) {\n    value = read_property(value, parent.property);\n    mark_escaped(tw, d, scope, parent, value, level + 1, depth + 1);\n    if (value) return;\n  }\n  if (level > 0) return;\n  if (parent instanceof AST_Sequence && node !== parent.tail_node()) return;\n  if (parent instanceof AST_SimpleStatement) return;\n  d.direct_access = true;\n}\nconst suppress = node => walk(node, node => {\n  if (!(node instanceof AST_Symbol)) return;\n  var d = node.definition();\n  if (!d) return;\n  if (node instanceof AST_SymbolRef) d.references.push(node);\n  d.fixed = false;\n});\ndef_reduce_vars(AST_Accessor, function (tw, descend, compressor) {\n  push(tw);\n  reset_variables(tw, compressor, this);\n  descend();\n  pop(tw);\n  return true;\n});\ndef_reduce_vars(AST_Assign, function (tw, descend, compressor) {\n  var node = this;\n  if (node.left instanceof AST_Destructuring) {\n    suppress(node.left);\n    return;\n  }\n  const finish_walk = () => {\n    if (node.logical) {\n      node.left.walk(tw);\n      push(tw);\n      node.right.walk(tw);\n      pop(tw);\n      return true;\n    }\n  };\n  var sym = node.left;\n  if (!(sym instanceof AST_SymbolRef)) return finish_walk();\n  var def = sym.definition();\n  var safe = safe_to_assign(tw, def, sym.scope, node.right);\n  def.assignments++;\n  if (!safe) return finish_walk();\n  var fixed = def.fixed;\n  if (!fixed && node.operator != \"=\" && !node.logical) return finish_walk();\n  var eq = node.operator == \"=\";\n  var value = eq ? node.right : node;\n  if (is_modified(compressor, tw, node, value, 0)) return finish_walk();\n  def.references.push(sym);\n  if (!node.logical) {\n    if (!eq) def.chained = true;\n    def.fixed = eq ? function () {\n      return node.right;\n    } : function () {\n      return make_node(AST_Binary, node, {\n        operator: node.operator.slice(0, -1),\n        left: fixed instanceof AST_Node ? fixed : fixed(),\n        right: node.right\n      });\n    };\n  }\n  if (node.logical) {\n    mark(tw, def, false);\n    push(tw);\n    node.right.walk(tw);\n    pop(tw);\n    return true;\n  }\n  mark(tw, def, false);\n  node.right.walk(tw);\n  mark(tw, def, true);\n  mark_escaped(tw, def, sym.scope, node, value, 0, 1);\n  return true;\n});\ndef_reduce_vars(AST_Binary, function (tw) {\n  if (!lazy_op.has(this.operator)) return;\n  this.left.walk(tw);\n  push(tw);\n  this.right.walk(tw);\n  pop(tw);\n  return true;\n});\ndef_reduce_vars(AST_Block, function (tw, descend, compressor) {\n  reset_block_variables(compressor, this);\n});\ndef_reduce_vars(AST_Case, function (tw) {\n  push(tw);\n  this.expression.walk(tw);\n  pop(tw);\n  push(tw);\n  walk_body(this, tw);\n  pop(tw);\n  return true;\n});\ndef_reduce_vars(AST_Class, function (tw, descend) {\n  clear_flag(this, INLINED);\n  push(tw);\n  descend();\n  pop(tw);\n  return true;\n});\ndef_reduce_vars(AST_ClassStaticBlock, function (tw, descend, compressor) {\n  reset_block_variables(compressor, this);\n});\ndef_reduce_vars(AST_Conditional, function (tw) {\n  this.condition.walk(tw);\n  push(tw);\n  this.consequent.walk(tw);\n  pop(tw);\n  push(tw);\n  this.alternative.walk(tw);\n  pop(tw);\n  return true;\n});\ndef_reduce_vars(AST_Chain, function (tw, descend) {\n  // Chains' conditions apply left-to-right, cumulatively.\n  // If we walk normally we don't go in that order because we would pop before pushing again\n  // Solution: AST_PropAccess and AST_Call push when they are optional, and never pop.\n  // Then we pop everything when they are done being walked.\n  const safe_ids = tw.safe_ids;\n  descend();\n\n  // Unroll back to start\n  tw.safe_ids = safe_ids;\n  return true;\n});\ndef_reduce_vars(AST_Call, function (tw) {\n  this.expression.walk(tw);\n  if (this.optional) {\n    // Never pop -- it's popped at AST_Chain above\n    push(tw);\n  }\n  for (const arg of this.args) arg.walk(tw);\n  return true;\n});\ndef_reduce_vars(AST_PropAccess, function (tw) {\n  if (!this.optional) return;\n  this.expression.walk(tw);\n\n  // Never pop -- it's popped at AST_Chain above\n  push(tw);\n  if (this.property instanceof AST_Node) this.property.walk(tw);\n  return true;\n});\ndef_reduce_vars(AST_Default, function (tw, descend) {\n  push(tw);\n  descend();\n  pop(tw);\n  return true;\n});\nfunction mark_lambda(tw, descend, compressor) {\n  clear_flag(this, INLINED);\n  push(tw);\n  reset_variables(tw, compressor, this);\n  var iife;\n  if (!this.name && !this.uses_arguments && !this.pinned() && (iife = tw.parent()) instanceof AST_Call && iife.expression === this && !iife.args.some(arg => arg instanceof AST_Expansion) && this.argnames.every(arg_name => arg_name instanceof AST_Symbol)) {\n    // Virtually turn IIFE parameters into variable definitions:\n    //   (function(a,b) {...})(c,d) => (function() {var a=c,b=d; ...})()\n    // So existing transformation rules can work on them.\n    this.argnames.forEach((arg, i) => {\n      if (!arg.definition) return;\n      var d = arg.definition();\n      // Avoid setting fixed when there's more than one origin for a variable value\n      if (d.orig.length > 1) return;\n      if (d.fixed === undefined && (!this.uses_arguments || tw.has_directive(\"use strict\"))) {\n        d.fixed = function () {\n          return iife.args[i] || make_node(AST_Undefined, iife);\n        };\n        tw.loop_ids.set(d.id, tw.in_loop);\n        mark(tw, d, true);\n      } else {\n        d.fixed = false;\n      }\n    });\n  }\n  descend();\n  pop(tw);\n  handle_defined_after_hoist(this);\n  return true;\n}\n\n/**\n * It's possible for a hoisted function to use something that's not defined yet. Example:\n *\n * hoisted();\n * var defined_after = true;\n * function hoisted() {\n *   // use defined_after\n * }\n *\n * Or even indirectly:\n *\n * B();\n * var defined_after = true;\n * function A() {\n *   // use defined_after\n * }\n * function B() {\n *   A();\n * }\n *\n * Access a variable before declaration will either throw a ReferenceError\n * (if the variable is declared with `let` or `const`),\n * or get an `undefined` (if the variable is declared with `var`).\n *\n * If the variable is inlined into the function, the behavior will change.\n *\n * This function is called on the parent to disallow inlining of such variables,\n */\nfunction handle_defined_after_hoist(parent) {\n  const defuns = [];\n  walk(parent, node => {\n    if (node === parent) return;\n    if (node instanceof AST_Defun) {\n      defuns.push(node);\n      return true;\n    }\n    if (node instanceof AST_Scope || node instanceof AST_SimpleStatement) return true;\n  });\n\n  // `defun` id to array of `defun` it uses\n  const defun_dependencies_map = new Map();\n  // `defun` id to array of enclosing `def` that are used by the function\n  const dependencies_map = new Map();\n  // all symbol ids that will be tracked for read/write\n  const symbols_of_interest = new Set();\n  const defuns_of_interest = new Set();\n  for (const defun of defuns) {\n    const fname_def = defun.name.definition();\n    const enclosing_defs = [];\n    for (const def of defun.enclosed) {\n      if (def.fixed === false || def === fname_def || def.scope.get_defun_scope() !== parent) {\n        continue;\n      }\n      symbols_of_interest.add(def.id);\n\n      // found a reference to another function\n      if (def.assignments === 0 && def.orig.length === 1 && def.orig[0] instanceof AST_SymbolDefun) {\n        defuns_of_interest.add(def.id);\n        symbols_of_interest.add(def.id);\n        defuns_of_interest.add(fname_def.id);\n        symbols_of_interest.add(fname_def.id);\n        if (!defun_dependencies_map.has(fname_def.id)) {\n          defun_dependencies_map.set(fname_def.id, []);\n        }\n        defun_dependencies_map.get(fname_def.id).push(def.id);\n        continue;\n      }\n      enclosing_defs.push(def);\n    }\n    if (enclosing_defs.length) {\n      dependencies_map.set(fname_def.id, enclosing_defs);\n      defuns_of_interest.add(fname_def.id);\n      symbols_of_interest.add(fname_def.id);\n    }\n  }\n\n  // No defuns use outside constants\n  if (!dependencies_map.size) {\n    return;\n  }\n\n  // Increment to count \"symbols of interest\" (defuns or defs) that we found.\n  // These are tracked in AST order so we can check which is after which.\n  let symbol_index = 1;\n  // Map a defun ID to its first read (a `symbol_index`)\n  const defun_first_read_map = new Map();\n  // Map a symbol ID to its last write (a `symbol_index`)\n  const symbol_last_write_map = new Map();\n  walk_parent(parent, (node, walk_info) => {\n    if (node instanceof AST_Symbol && node.thedef) {\n      const id = node.definition().id;\n      symbol_index++;\n\n      // Track last-writes to symbols\n      if (symbols_of_interest.has(id)) {\n        if (node instanceof AST_SymbolDeclaration || is_lhs(node, walk_info.parent())) {\n          symbol_last_write_map.set(id, symbol_index);\n        }\n      }\n\n      // Track first-reads of defuns (refined later)\n      if (defuns_of_interest.has(id)) {\n        if (!defun_first_read_map.has(id) && !is_recursive_ref(walk_info, id)) {\n          defun_first_read_map.set(id, symbol_index);\n        }\n      }\n    }\n  });\n\n  // Refine `defun_first_read_map` to be as high as possible\n  for (const [defun, defun_first_read] of defun_first_read_map) {\n    // Update all dependencies of `defun`\n    const queue = new Set(defun_dependencies_map.get(defun));\n    for (const enclosed_defun of queue) {\n      let enclosed_defun_first_read = defun_first_read_map.get(enclosed_defun);\n      if (enclosed_defun_first_read != null && enclosed_defun_first_read < defun_first_read) {\n        continue;\n      }\n      defun_first_read_map.set(enclosed_defun, defun_first_read);\n      for (const enclosed_enclosed_defun of defun_dependencies_map.get(enclosed_defun) || []) {\n        queue.add(enclosed_enclosed_defun);\n      }\n    }\n  }\n\n  // ensure write-then-read order, otherwise clear `fixed`\n  // This is safe because last-writes (found_symbol_writes) are assumed to be as late as possible, and first-reads (defun_first_read_map) are assumed to be as early as possible.\n  for (const [defun, defs] of dependencies_map) {\n    const defun_first_read = defun_first_read_map.get(defun);\n    if (defun_first_read === undefined) {\n      continue;\n    }\n    for (const def of defs) {\n      if (def.fixed === false) {\n        continue;\n      }\n      let def_last_write = symbol_last_write_map.get(def.id) || 0;\n      if (defun_first_read < def_last_write) {\n        def.fixed = false;\n      }\n    }\n  }\n}\ndef_reduce_vars(AST_Lambda, mark_lambda);\ndef_reduce_vars(AST_Do, function (tw, descend, compressor) {\n  reset_block_variables(compressor, this);\n  const saved_loop = tw.in_loop;\n  tw.in_loop = this;\n  push(tw);\n  this.body.walk(tw);\n  if (has_break_or_continue(this)) {\n    pop(tw);\n    push(tw);\n  }\n  this.condition.walk(tw);\n  pop(tw);\n  tw.in_loop = saved_loop;\n  return true;\n});\ndef_reduce_vars(AST_For, function (tw, descend, compressor) {\n  reset_block_variables(compressor, this);\n  if (this.init) this.init.walk(tw);\n  const saved_loop = tw.in_loop;\n  tw.in_loop = this;\n  push(tw);\n  if (this.condition) this.condition.walk(tw);\n  this.body.walk(tw);\n  if (this.step) {\n    if (has_break_or_continue(this)) {\n      pop(tw);\n      push(tw);\n    }\n    this.step.walk(tw);\n  }\n  pop(tw);\n  tw.in_loop = saved_loop;\n  return true;\n});\ndef_reduce_vars(AST_ForIn, function (tw, descend, compressor) {\n  reset_block_variables(compressor, this);\n  suppress(this.init);\n  this.object.walk(tw);\n  const saved_loop = tw.in_loop;\n  tw.in_loop = this;\n  push(tw);\n  this.body.walk(tw);\n  pop(tw);\n  tw.in_loop = saved_loop;\n  return true;\n});\ndef_reduce_vars(AST_If, function (tw) {\n  this.condition.walk(tw);\n  push(tw);\n  this.body.walk(tw);\n  pop(tw);\n  if (this.alternative) {\n    push(tw);\n    this.alternative.walk(tw);\n    pop(tw);\n  }\n  return true;\n});\ndef_reduce_vars(AST_LabeledStatement, function (tw) {\n  push(tw);\n  this.body.walk(tw);\n  pop(tw);\n  return true;\n});\ndef_reduce_vars(AST_SymbolCatch, function () {\n  this.definition().fixed = false;\n});\ndef_reduce_vars(AST_SymbolRef, function (tw, descend, compressor) {\n  var d = this.definition();\n  d.references.push(this);\n  if (d.references.length == 1 && !d.fixed && d.orig[0] instanceof AST_SymbolDefun) {\n    tw.loop_ids.set(d.id, tw.in_loop);\n  }\n  var fixed_value;\n  if (d.fixed === undefined || !safe_to_read(tw, d)) {\n    d.fixed = false;\n  } else if (d.fixed) {\n    fixed_value = this.fixed_value();\n    if (fixed_value instanceof AST_Lambda && is_recursive_ref(tw, d)) {\n      d.recursive_refs++;\n    } else if (fixed_value && !compressor.exposed(d) && ref_once(tw, compressor, d)) {\n      d.single_use = fixed_value instanceof AST_Lambda && !fixed_value.pinned() || fixed_value instanceof AST_Class || d.scope === this.scope && fixed_value.is_constant_expression();\n    } else {\n      d.single_use = false;\n    }\n    if (is_modified(compressor, tw, this, fixed_value, 0, is_immutable(fixed_value))) {\n      if (d.single_use) {\n        d.single_use = \"m\";\n      } else {\n        d.fixed = false;\n      }\n    }\n  }\n  mark_escaped(tw, d, this.scope, this, fixed_value, 0, 1);\n});\ndef_reduce_vars(AST_Toplevel, function (tw, descend, compressor) {\n  this.globals.forEach(function (def) {\n    reset_def(compressor, def);\n  });\n  reset_variables(tw, compressor, this);\n  descend();\n  handle_defined_after_hoist(this);\n  return true;\n});\ndef_reduce_vars(AST_Try, function (tw, descend, compressor) {\n  reset_block_variables(compressor, this);\n  push(tw);\n  this.body.walk(tw);\n  pop(tw);\n  if (this.bcatch) {\n    push(tw);\n    this.bcatch.walk(tw);\n    pop(tw);\n  }\n  if (this.bfinally) this.bfinally.walk(tw);\n  return true;\n});\ndef_reduce_vars(AST_Unary, function (tw) {\n  var node = this;\n  if (node.operator !== \"++\" && node.operator !== \"--\") return;\n  var exp = node.expression;\n  if (!(exp instanceof AST_SymbolRef)) return;\n  var def = exp.definition();\n  var safe = safe_to_assign(tw, def, exp.scope, true);\n  def.assignments++;\n  if (!safe) return;\n  var fixed = def.fixed;\n  if (!fixed) return;\n  def.references.push(exp);\n  def.chained = true;\n  def.fixed = function () {\n    return make_node(AST_Binary, node, {\n      operator: node.operator.slice(0, -1),\n      left: make_node(AST_UnaryPrefix, node, {\n        operator: \"+\",\n        expression: fixed instanceof AST_Node ? fixed : fixed()\n      }),\n      right: make_node(AST_Number, node, {\n        value: 1\n      })\n    });\n  };\n  mark(tw, def, true);\n  return true;\n});\ndef_reduce_vars(AST_VarDef, function (tw, descend) {\n  var node = this;\n  if (node.name instanceof AST_Destructuring) {\n    suppress(node.name);\n    return;\n  }\n  var d = node.name.definition();\n  if (node.value) {\n    if (safe_to_assign(tw, d, node.name.scope, node.value)) {\n      d.fixed = function () {\n        return node.value;\n      };\n      tw.loop_ids.set(d.id, tw.in_loop);\n      mark(tw, d, false);\n      descend();\n      mark(tw, d, true);\n      return true;\n    } else {\n      d.fixed = false;\n    }\n  }\n});\ndef_reduce_vars(AST_UsingDef, function () {\n  suppress(this.name);\n});\ndef_reduce_vars(AST_While, function (tw, descend, compressor) {\n  reset_block_variables(compressor, this);\n  const saved_loop = tw.in_loop;\n  tw.in_loop = this;\n  push(tw);\n  descend();\n  pop(tw);\n  tw.in_loop = saved_loop;\n  return true;\n});","map":{"version":3,"names":["AST_Accessor","AST_Array","AST_Assign","AST_Await","AST_Binary","AST_Block","AST_Call","AST_Case","AST_Chain","AST_Class","AST_ClassStaticBlock","AST_ClassExpression","AST_Conditional","AST_Default","AST_Defun","AST_Destructuring","AST_Do","AST_Exit","AST_Expansion","AST_For","AST_ForIn","AST_If","AST_LabeledStatement","AST_Lambda","AST_New","AST_Node","AST_Number","AST_ObjectKeyVal","AST_PropAccess","AST_Scope","AST_Sequence","AST_SimpleStatement","AST_Symbol","AST_SymbolCatch","AST_SymbolConst","AST_SymbolDeclaration","AST_SymbolDefun","AST_SymbolFunarg","AST_SymbolLambda","AST_SymbolRef","AST_This","AST_Toplevel","AST_Try","AST_Unary","AST_UnaryPrefix","AST_Undefined","AST_UsingDef","AST_VarDef","AST_VarDefLike","AST_While","AST_Yield","walk","walk_body","walk_parent","HOP","make_node","noop","lazy_op","is_modified","is_lhs","INLINED","clear_flag","read_property","has_break_or_continue","is_recursive_ref","def_reduce_vars","node","func","DEFMETHOD","reset_def","compressor","def","assignments","chained","direct_access","escaped","recursive_refs","references","single_use","undefined","scope","pinned","orig","uses_arguments","fixed","exposed","init","reset_variables","tw","variables","forEach","defs_to_safe_ids","set","id","safe_ids","mark","loop_ids","in_loop","reset_block_variables","block_scope","push","Object","create","pop","getPrototypeOf","safe","safe_to_read","name","safe_to_assign","value","def_safe_ids","get","delete","length","parent_scope","every","sym","ref_once","option","is_immutable","is_constant","mark_escaped","d","level","depth","parent","operator","logical","right","expression","is_constant_expression","has","condition","tail_node","obj","property","suppress","definition","descend","left","finish_walk","eq","slice","consequent","alternative","optional","arg","args","mark_lambda","iife","some","argnames","arg_name","i","has_directive","handle_defined_after_hoist","defuns","defun_dependencies_map","Map","dependencies_map","symbols_of_interest","Set","defuns_of_interest","defun","fname_def","enclosing_defs","enclosed","get_defun_scope","add","size","symbol_index","defun_first_read_map","symbol_last_write_map","walk_info","thedef","defun_first_read","queue","enclosed_defun","enclosed_defun_first_read","enclosed_enclosed_defun","defs","def_last_write","saved_loop","body","step","object","fixed_value","globals","bcatch","bfinally","exp"],"sources":["F:/landinghub-iconic/node_modules/.pnpm/terser@5.44.0/node_modules/terser/lib/compress/reduce-vars.js"],"sourcesContent":["/***********************************************************************\n\n  A JavaScript tokenizer / parser / beautifier / compressor.\n  https://github.com/mishoo/UglifyJS2\n\n  -------------------------------- (C) ---------------------------------\n\n                           Author: Mihai Bazon\n                         <mihai.bazon@gmail.com>\n                       http://mihai.bazon.net/blog\n\n  Distributed under the BSD license:\n\n    Copyright 2012 (c) Mihai Bazon <mihai.bazon@gmail.com>\n\n    Redistribution and use in source and binary forms, with or without\n    modification, are permitted provided that the following conditions\n    are met:\n\n        * Redistributions of source code must retain the above\n          copyright notice, this list of conditions and the following\n          disclaimer.\n\n        * Redistributions in binary form must reproduce the above\n          copyright notice, this list of conditions and the following\n          disclaimer in the documentation and/or other materials\n          provided with the distribution.\n\n    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER “AS IS” AND ANY\n    EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n    IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n    PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER BE\n    LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,\n    OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n    PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n    PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR\n    TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF\n    THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n    SUCH DAMAGE.\n\n ***********************************************************************/\n\nimport {\n    AST_Accessor,\n    AST_Array,\n    AST_Assign,\n    AST_Await,\n    AST_Binary,\n    AST_Block,\n    AST_Call,\n    AST_Case,\n    AST_Chain,\n    AST_Class,\n    AST_ClassStaticBlock,\n    AST_ClassExpression,\n    AST_Conditional,\n    AST_Default,\n    AST_Defun,\n    AST_Destructuring,\n    AST_Do,\n    AST_Exit,\n    AST_Expansion,\n    AST_For,\n    AST_ForIn,\n    AST_If,\n    AST_LabeledStatement,\n    AST_Lambda,\n    AST_New,\n    AST_Node,\n    AST_Number,\n    AST_ObjectKeyVal,\n    AST_PropAccess,\n    AST_Scope,\n    AST_Sequence,\n    AST_SimpleStatement,\n    AST_Symbol,\n    AST_SymbolCatch,\n    AST_SymbolConst,\n    AST_SymbolDeclaration,\n    AST_SymbolDefun,\n    AST_SymbolFunarg,\n    AST_SymbolLambda,\n    AST_SymbolRef,\n    AST_This,\n    AST_Toplevel,\n    AST_Try,\n    AST_Unary,\n    AST_UnaryPrefix,\n    AST_Undefined,\n    AST_UsingDef,\n    AST_VarDef,\n    AST_VarDefLike,\n    AST_While,\n    AST_Yield,\n\n    walk,\n    walk_body,\n    walk_parent,\n} from \"../ast.js\";\nimport { HOP, make_node, noop } from \"../utils/index.js\";\n\nimport { lazy_op, is_modified, is_lhs } from \"./inference.js\";\nimport { INLINED, clear_flag } from \"./compressor-flags.js\";\nimport { read_property, has_break_or_continue, is_recursive_ref } from \"./common.js\";\n\n/**\n * Define the method AST_Node#reduce_vars, which goes through the AST in\n * execution order to perform basic flow analysis\n */\nfunction def_reduce_vars(node, func) {\n    node.DEFMETHOD(\"reduce_vars\", func);\n}\n\ndef_reduce_vars(AST_Node, noop);\n\n/** Clear definition properties */\nfunction reset_def(compressor, def) {\n    def.assignments = 0;\n    def.chained = false;\n    def.direct_access = false;\n    def.escaped = 0;\n    def.recursive_refs = 0;\n    def.references = [];\n    def.single_use = undefined;\n    if (\n        def.scope.pinned()\n        || (def.orig[0] instanceof AST_SymbolFunarg && def.scope.uses_arguments)\n    ) {\n        def.fixed = false;\n    } else if (def.orig[0] instanceof AST_SymbolConst || !compressor.exposed(def)) {\n        def.fixed = def.init;\n    } else {\n        def.fixed = false;\n    }\n}\n\nfunction reset_variables(tw, compressor, node) {\n    node.variables.forEach(function(def) {\n        reset_def(compressor, def);\n        if (def.fixed === null) {\n            tw.defs_to_safe_ids.set(def.id, tw.safe_ids);\n            mark(tw, def, true);\n        } else if (def.fixed) {\n            tw.loop_ids.set(def.id, tw.in_loop);\n            mark(tw, def, true);\n        }\n    });\n}\n\nfunction reset_block_variables(compressor, node) {\n    if (node.block_scope) node.block_scope.variables.forEach((def) => {\n        reset_def(compressor, def);\n    });\n}\n\nfunction push(tw) {\n    tw.safe_ids = Object.create(tw.safe_ids);\n}\n\nfunction pop(tw) {\n    tw.safe_ids = Object.getPrototypeOf(tw.safe_ids);\n}\n\nfunction mark(tw, def, safe) {\n    tw.safe_ids[def.id] = safe;\n}\n\nfunction safe_to_read(tw, def) {\n    if (def.single_use == \"m\") return false;\n    if (tw.safe_ids[def.id]) {\n        if (def.fixed == null) {\n            var orig = def.orig[0];\n            if (orig instanceof AST_SymbolFunarg || orig.name == \"arguments\") return false;\n            def.fixed = make_node(AST_Undefined, orig);\n        }\n        return true;\n    }\n    return def.fixed instanceof AST_Defun;\n}\n\nfunction safe_to_assign(tw, def, scope, value) {\n    if (def.fixed === undefined) return true;\n    let def_safe_ids;\n    if (def.fixed === null\n        && (def_safe_ids = tw.defs_to_safe_ids.get(def.id))\n    ) {\n        def_safe_ids[def.id] = false;\n        tw.defs_to_safe_ids.delete(def.id);\n        return true;\n    }\n    if (!HOP(tw.safe_ids, def.id)) return false;\n    if (!safe_to_read(tw, def)) return false;\n    if (def.fixed === false) return false;\n    if (def.fixed != null && (!value || def.references.length > def.assignments)) return false;\n    if (def.fixed instanceof AST_Defun) {\n        return value instanceof AST_Node && def.fixed.parent_scope === scope;\n    }\n    return def.orig.every((sym) => {\n        return !(sym instanceof AST_SymbolConst\n            || sym instanceof AST_SymbolDefun\n            || sym instanceof AST_SymbolLambda);\n    });\n}\n\nfunction ref_once(tw, compressor, def) {\n    return compressor.option(\"unused\")\n        && !def.scope.pinned()\n        && def.references.length - def.recursive_refs == 1\n        && tw.loop_ids.get(def.id) === tw.in_loop;\n}\n\nfunction is_immutable(value) {\n    if (!value) return false;\n    return value.is_constant()\n        || value instanceof AST_Lambda\n        || value instanceof AST_This;\n}\n\n// A definition \"escapes\" when its value can leave the point of use.\n// Example: `a = b || c`\n// In this example, \"b\" and \"c\" are escaping, because they're going into \"a\"\n//\n// def.escaped is != 0 when it escapes.\n//\n// When greater than 1, it means that N chained properties will be read off\n// of that def before an escape occurs. This is useful for evaluating\n// property accesses, where you need to know when to stop.\nfunction mark_escaped(tw, d, scope, node, value, level = 0, depth = 1) {\n    var parent = tw.parent(level);\n    if (value) {\n        if (value.is_constant()) return;\n        if (value instanceof AST_ClassExpression) return;\n    }\n\n    if (\n        parent instanceof AST_Assign && (parent.operator === \"=\" || parent.logical) && node === parent.right\n        || parent instanceof AST_Call && (node !== parent.expression || parent instanceof AST_New)\n        || parent instanceof AST_Exit && node === parent.value && node.scope !== d.scope\n        || parent instanceof AST_VarDefLike && node === parent.value\n        || parent instanceof AST_Yield && node === parent.value && node.scope !== d.scope\n    ) {\n        if (depth > 1 && !(value && value.is_constant_expression(scope))) depth = 1;\n        if (!d.escaped || d.escaped > depth) d.escaped = depth;\n        return;\n    } else if (\n        parent instanceof AST_Array\n        || parent instanceof AST_Await\n        || parent instanceof AST_Binary && lazy_op.has(parent.operator)\n        || parent instanceof AST_Conditional && node !== parent.condition\n        || parent instanceof AST_Expansion\n        || parent instanceof AST_Sequence && node === parent.tail_node()\n    ) {\n        mark_escaped(tw, d, scope, parent, parent, level + 1, depth);\n    } else if (parent instanceof AST_ObjectKeyVal && node === parent.value) {\n        var obj = tw.parent(level + 1);\n\n        mark_escaped(tw, d, scope, obj, obj, level + 2, depth);\n    } else if (parent instanceof AST_PropAccess && node === parent.expression) {\n        value = read_property(value, parent.property);\n\n        mark_escaped(tw, d, scope, parent, value, level + 1, depth + 1);\n        if (value) return;\n    }\n\n    if (level > 0) return;\n    if (parent instanceof AST_Sequence && node !== parent.tail_node()) return;\n    if (parent instanceof AST_SimpleStatement) return;\n\n    d.direct_access = true;\n}\n\nconst suppress = node => walk(node, node => {\n    if (!(node instanceof AST_Symbol)) return;\n    var d = node.definition();\n    if (!d) return;\n    if (node instanceof AST_SymbolRef) d.references.push(node);\n    d.fixed = false;\n});\n\ndef_reduce_vars(AST_Accessor, function(tw, descend, compressor) {\n    push(tw);\n    reset_variables(tw, compressor, this);\n    descend();\n    pop(tw);\n    return true;\n});\n\ndef_reduce_vars(AST_Assign, function(tw, descend, compressor) {\n    var node = this;\n    if (node.left instanceof AST_Destructuring) {\n        suppress(node.left);\n        return;\n    }\n\n    const finish_walk = () => {\n        if (node.logical) {\n            node.left.walk(tw);\n\n            push(tw);\n            node.right.walk(tw);\n            pop(tw);\n\n            return true;\n        }\n    };\n\n    var sym = node.left;\n    if (!(sym instanceof AST_SymbolRef)) return finish_walk();\n\n    var def = sym.definition();\n    var safe = safe_to_assign(tw, def, sym.scope, node.right);\n    def.assignments++;\n    if (!safe) return finish_walk();\n\n    var fixed = def.fixed;\n    if (!fixed && node.operator != \"=\" && !node.logical) return finish_walk();\n\n    var eq = node.operator == \"=\";\n    var value = eq ? node.right : node;\n    if (is_modified(compressor, tw, node, value, 0)) return finish_walk();\n\n    def.references.push(sym);\n\n    if (!node.logical) {\n        if (!eq) def.chained = true;\n\n        def.fixed = eq ? function() {\n            return node.right;\n        } : function() {\n            return make_node(AST_Binary, node, {\n                operator: node.operator.slice(0, -1),\n                left: fixed instanceof AST_Node ? fixed : fixed(),\n                right: node.right\n            });\n        };\n    }\n\n    if (node.logical) {\n        mark(tw, def, false);\n        push(tw);\n        node.right.walk(tw);\n        pop(tw);\n        return true;\n    }\n\n    mark(tw, def, false);\n    node.right.walk(tw);\n    mark(tw, def, true);\n\n    mark_escaped(tw, def, sym.scope, node, value, 0, 1);\n\n    return true;\n});\n\ndef_reduce_vars(AST_Binary, function(tw) {\n    if (!lazy_op.has(this.operator)) return;\n    this.left.walk(tw);\n    push(tw);\n    this.right.walk(tw);\n    pop(tw);\n    return true;\n});\n\ndef_reduce_vars(AST_Block, function(tw, descend, compressor) {\n    reset_block_variables(compressor, this);\n});\n\ndef_reduce_vars(AST_Case, function(tw) {\n    push(tw);\n    this.expression.walk(tw);\n    pop(tw);\n    push(tw);\n    walk_body(this, tw);\n    pop(tw);\n    return true;\n});\n\ndef_reduce_vars(AST_Class, function(tw, descend) {\n    clear_flag(this, INLINED);\n    push(tw);\n    descend();\n    pop(tw);\n    return true;\n});\n\ndef_reduce_vars(AST_ClassStaticBlock, function(tw, descend, compressor) {\n    reset_block_variables(compressor, this);\n});\n\ndef_reduce_vars(AST_Conditional, function(tw) {\n    this.condition.walk(tw);\n    push(tw);\n    this.consequent.walk(tw);\n    pop(tw);\n    push(tw);\n    this.alternative.walk(tw);\n    pop(tw);\n    return true;\n});\n\ndef_reduce_vars(AST_Chain, function(tw, descend) {\n    // Chains' conditions apply left-to-right, cumulatively.\n    // If we walk normally we don't go in that order because we would pop before pushing again\n    // Solution: AST_PropAccess and AST_Call push when they are optional, and never pop.\n    // Then we pop everything when they are done being walked.\n    const safe_ids = tw.safe_ids;\n\n    descend();\n\n    // Unroll back to start\n    tw.safe_ids = safe_ids;\n    return true;\n});\n\ndef_reduce_vars(AST_Call, function (tw) {\n    this.expression.walk(tw);\n\n    if (this.optional) {\n        // Never pop -- it's popped at AST_Chain above\n        push(tw);\n    }\n\n    for (const arg of this.args) arg.walk(tw);\n\n    return true;\n});\n\ndef_reduce_vars(AST_PropAccess, function (tw) {\n    if (!this.optional) return;\n\n    this.expression.walk(tw);\n\n    // Never pop -- it's popped at AST_Chain above\n    push(tw);\n\n    if (this.property instanceof AST_Node) this.property.walk(tw);\n\n    return true;\n});\n\ndef_reduce_vars(AST_Default, function(tw, descend) {\n    push(tw);\n    descend();\n    pop(tw);\n    return true;\n});\n\nfunction mark_lambda(tw, descend, compressor) {\n    clear_flag(this, INLINED);\n    push(tw);\n    reset_variables(tw, compressor, this);\n\n    var iife;\n    if (!this.name\n        && !this.uses_arguments\n        && !this.pinned()\n        && (iife = tw.parent()) instanceof AST_Call\n        && iife.expression === this\n        && !iife.args.some(arg => arg instanceof AST_Expansion)\n        && this.argnames.every(arg_name => arg_name instanceof AST_Symbol)\n    ) {\n        // Virtually turn IIFE parameters into variable definitions:\n        //   (function(a,b) {...})(c,d) => (function() {var a=c,b=d; ...})()\n        // So existing transformation rules can work on them.\n        this.argnames.forEach((arg, i) => {\n            if (!arg.definition) return;\n            var d = arg.definition();\n            // Avoid setting fixed when there's more than one origin for a variable value\n            if (d.orig.length > 1) return;\n            if (d.fixed === undefined && (!this.uses_arguments || tw.has_directive(\"use strict\"))) {\n                d.fixed = function() {\n                    return iife.args[i] || make_node(AST_Undefined, iife);\n                };\n                tw.loop_ids.set(d.id, tw.in_loop);\n                mark(tw, d, true);\n            } else {\n                d.fixed = false;\n            }\n        });\n    }\n\n    descend();\n    pop(tw);\n\n    handle_defined_after_hoist(this);\n\n    return true;\n}\n\n/**\n * It's possible for a hoisted function to use something that's not defined yet. Example:\n *\n * hoisted();\n * var defined_after = true;\n * function hoisted() {\n *   // use defined_after\n * }\n *\n * Or even indirectly:\n *\n * B();\n * var defined_after = true;\n * function A() {\n *   // use defined_after\n * }\n * function B() {\n *   A();\n * }\n *\n * Access a variable before declaration will either throw a ReferenceError\n * (if the variable is declared with `let` or `const`),\n * or get an `undefined` (if the variable is declared with `var`).\n *\n * If the variable is inlined into the function, the behavior will change.\n *\n * This function is called on the parent to disallow inlining of such variables,\n */\nfunction handle_defined_after_hoist(parent) {\n    const defuns = [];\n    walk(parent, node => {\n        if (node === parent) return;\n        if (node instanceof AST_Defun) {\n            defuns.push(node);\n            return true;\n        }\n        if (\n            node instanceof AST_Scope\n            || node instanceof AST_SimpleStatement\n        ) return true;\n    });\n\n    // `defun` id to array of `defun` it uses\n    const defun_dependencies_map = new Map();\n    // `defun` id to array of enclosing `def` that are used by the function\n    const dependencies_map = new Map();\n    // all symbol ids that will be tracked for read/write\n    const symbols_of_interest = new Set();\n    const defuns_of_interest = new Set();\n\n    for (const defun of defuns) {\n        const fname_def = defun.name.definition();\n        const enclosing_defs = [];\n\n        for (const def of defun.enclosed) {\n            if (\n                def.fixed === false\n                || def === fname_def\n                || def.scope.get_defun_scope() !== parent\n            ) {\n                continue;\n            }\n\n            symbols_of_interest.add(def.id);\n\n            // found a reference to another function\n            if (\n                def.assignments === 0\n                && def.orig.length === 1\n                && def.orig[0] instanceof AST_SymbolDefun\n            ) {\n                defuns_of_interest.add(def.id);\n                symbols_of_interest.add(def.id);\n\n                defuns_of_interest.add(fname_def.id);\n                symbols_of_interest.add(fname_def.id);\n\n                if (!defun_dependencies_map.has(fname_def.id)) {\n                    defun_dependencies_map.set(fname_def.id, []);\n                }\n                defun_dependencies_map.get(fname_def.id).push(def.id);\n\n                continue;\n            }\n\n            enclosing_defs.push(def);\n        }\n\n        if (enclosing_defs.length) {\n            dependencies_map.set(fname_def.id, enclosing_defs);\n            defuns_of_interest.add(fname_def.id);\n            symbols_of_interest.add(fname_def.id);\n        }\n    }\n\n    // No defuns use outside constants\n    if (!dependencies_map.size) {\n        return;\n    }\n\n    // Increment to count \"symbols of interest\" (defuns or defs) that we found.\n    // These are tracked in AST order so we can check which is after which.\n    let symbol_index = 1;\n    // Map a defun ID to its first read (a `symbol_index`)\n    const defun_first_read_map = new Map();\n    // Map a symbol ID to its last write (a `symbol_index`)\n    const symbol_last_write_map = new Map();\n\n    walk_parent(parent, (node, walk_info) => {\n        if (node instanceof AST_Symbol && node.thedef) {\n            const id = node.definition().id;\n\n            symbol_index++;\n\n            // Track last-writes to symbols\n            if (symbols_of_interest.has(id)) {\n                if (node instanceof AST_SymbolDeclaration || is_lhs(node, walk_info.parent())) {\n                    symbol_last_write_map.set(id, symbol_index);\n                }\n            }\n\n            // Track first-reads of defuns (refined later)\n            if (defuns_of_interest.has(id)) {\n                if (!defun_first_read_map.has(id) && !is_recursive_ref(walk_info, id)) {\n                    defun_first_read_map.set(id, symbol_index);\n                }\n            }\n        }\n    });\n\n    // Refine `defun_first_read_map` to be as high as possible\n    for (const [defun, defun_first_read] of defun_first_read_map) {\n        // Update all dependencies of `defun`\n        const queue = new Set(defun_dependencies_map.get(defun));\n        for (const enclosed_defun of queue) {\n            let enclosed_defun_first_read = defun_first_read_map.get(enclosed_defun);\n            if (enclosed_defun_first_read != null && enclosed_defun_first_read < defun_first_read) {\n                continue;\n            }\n\n            defun_first_read_map.set(enclosed_defun, defun_first_read);\n\n            for (const enclosed_enclosed_defun of defun_dependencies_map.get(enclosed_defun) || []) {\n                queue.add(enclosed_enclosed_defun);\n            }\n        }\n    }\n\n    // ensure write-then-read order, otherwise clear `fixed`\n    // This is safe because last-writes (found_symbol_writes) are assumed to be as late as possible, and first-reads (defun_first_read_map) are assumed to be as early as possible.\n    for (const [defun, defs] of dependencies_map) {\n        const defun_first_read = defun_first_read_map.get(defun);\n        if (defun_first_read === undefined) {\n            continue;\n        }\n\n        for (const def of defs) {\n            if (def.fixed === false) {\n                continue;\n            }\n\n            let def_last_write = symbol_last_write_map.get(def.id) || 0;\n\n            if (defun_first_read < def_last_write) {\n                def.fixed = false;\n            }\n        }\n    }\n}\n\ndef_reduce_vars(AST_Lambda, mark_lambda);\n\ndef_reduce_vars(AST_Do, function(tw, descend, compressor) {\n    reset_block_variables(compressor, this);\n    const saved_loop = tw.in_loop;\n    tw.in_loop = this;\n    push(tw);\n    this.body.walk(tw);\n    if (has_break_or_continue(this)) {\n        pop(tw);\n        push(tw);\n    }\n    this.condition.walk(tw);\n    pop(tw);\n    tw.in_loop = saved_loop;\n    return true;\n});\n\ndef_reduce_vars(AST_For, function(tw, descend, compressor) {\n    reset_block_variables(compressor, this);\n    if (this.init) this.init.walk(tw);\n    const saved_loop = tw.in_loop;\n    tw.in_loop = this;\n    push(tw);\n    if (this.condition) this.condition.walk(tw);\n    this.body.walk(tw);\n    if (this.step) {\n        if (has_break_or_continue(this)) {\n            pop(tw);\n            push(tw);\n        }\n        this.step.walk(tw);\n    }\n    pop(tw);\n    tw.in_loop = saved_loop;\n    return true;\n});\n\ndef_reduce_vars(AST_ForIn, function(tw, descend, compressor) {\n    reset_block_variables(compressor, this);\n    suppress(this.init);\n    this.object.walk(tw);\n    const saved_loop = tw.in_loop;\n    tw.in_loop = this;\n    push(tw);\n    this.body.walk(tw);\n    pop(tw);\n    tw.in_loop = saved_loop;\n    return true;\n});\n\ndef_reduce_vars(AST_If, function(tw) {\n    this.condition.walk(tw);\n    push(tw);\n    this.body.walk(tw);\n    pop(tw);\n    if (this.alternative) {\n        push(tw);\n        this.alternative.walk(tw);\n        pop(tw);\n    }\n    return true;\n});\n\ndef_reduce_vars(AST_LabeledStatement, function(tw) {\n    push(tw);\n    this.body.walk(tw);\n    pop(tw);\n    return true;\n});\n\ndef_reduce_vars(AST_SymbolCatch, function() {\n    this.definition().fixed = false;\n});\n\ndef_reduce_vars(AST_SymbolRef, function(tw, descend, compressor) {\n    var d = this.definition();\n    d.references.push(this);\n    if (d.references.length == 1\n        && !d.fixed\n        && d.orig[0] instanceof AST_SymbolDefun) {\n        tw.loop_ids.set(d.id, tw.in_loop);\n    }\n    var fixed_value;\n    if (d.fixed === undefined || !safe_to_read(tw, d)) {\n        d.fixed = false;\n    } else if (d.fixed) {\n        fixed_value = this.fixed_value();\n        if (\n            fixed_value instanceof AST_Lambda\n            && is_recursive_ref(tw, d)\n        ) {\n            d.recursive_refs++;\n        } else if (fixed_value\n            && !compressor.exposed(d)\n            && ref_once(tw, compressor, d)\n        ) {\n            d.single_use =\n                fixed_value instanceof AST_Lambda && !fixed_value.pinned()\n                || fixed_value instanceof AST_Class\n                || d.scope === this.scope && fixed_value.is_constant_expression();\n        } else {\n            d.single_use = false;\n        }\n        if (is_modified(compressor, tw, this, fixed_value, 0, is_immutable(fixed_value))) {\n            if (d.single_use) {\n                d.single_use = \"m\";\n            } else {\n                d.fixed = false;\n            }\n        }\n    }\n    mark_escaped(tw, d, this.scope, this, fixed_value, 0, 1);\n});\n\ndef_reduce_vars(AST_Toplevel, function(tw, descend, compressor) {\n    this.globals.forEach(function(def) {\n        reset_def(compressor, def);\n    });\n    reset_variables(tw, compressor, this);\n    descend();\n    handle_defined_after_hoist(this);\n    return true;\n});\n\ndef_reduce_vars(AST_Try, function(tw, descend, compressor) {\n    reset_block_variables(compressor, this);\n    push(tw);\n    this.body.walk(tw);\n    pop(tw);\n    if (this.bcatch) {\n        push(tw);\n        this.bcatch.walk(tw);\n        pop(tw);\n    }\n    if (this.bfinally) this.bfinally.walk(tw);\n    return true;\n});\n\ndef_reduce_vars(AST_Unary, function(tw) {\n    var node = this;\n    if (node.operator !== \"++\" && node.operator !== \"--\") return;\n    var exp = node.expression;\n    if (!(exp instanceof AST_SymbolRef)) return;\n    var def = exp.definition();\n    var safe = safe_to_assign(tw, def, exp.scope, true);\n    def.assignments++;\n    if (!safe) return;\n    var fixed = def.fixed;\n    if (!fixed) return;\n    def.references.push(exp);\n    def.chained = true;\n    def.fixed = function() {\n        return make_node(AST_Binary, node, {\n            operator: node.operator.slice(0, -1),\n            left: make_node(AST_UnaryPrefix, node, {\n                operator: \"+\",\n                expression: fixed instanceof AST_Node ? fixed : fixed()\n            }),\n            right: make_node(AST_Number, node, {\n                value: 1\n            })\n        });\n    };\n    mark(tw, def, true);\n    return true;\n});\n\ndef_reduce_vars(AST_VarDef, function(tw, descend) {\n    var node = this;\n    if (node.name instanceof AST_Destructuring) {\n        suppress(node.name);\n        return;\n    }\n    var d = node.name.definition();\n    if (node.value) {\n        if (safe_to_assign(tw, d, node.name.scope, node.value)) {\n            d.fixed = function() {\n                return node.value;\n            };\n            tw.loop_ids.set(d.id, tw.in_loop);\n            mark(tw, d, false);\n            descend();\n            mark(tw, d, true);\n            return true;\n        } else {\n            d.fixed = false;\n        }\n    }\n});\n\ndef_reduce_vars(AST_UsingDef, function() {\n    suppress(this.name);\n});\n\ndef_reduce_vars(AST_While, function(tw, descend, compressor) {\n    reset_block_variables(compressor, this);\n    const saved_loop = tw.in_loop;\n    tw.in_loop = this;\n    push(tw);\n    descend();\n    pop(tw);\n    tw.in_loop = saved_loop;\n    return true;\n});\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}