{"ast":null,"code":"/***********************************************************************\n\n  A JavaScript tokenizer / parser / beautifier / compressor.\n  https://github.com/mishoo/UglifyJS\n\n  -------------------------------- (C) ---------------------------------\n\n                           Author: Mihai Bazon\n                         <mihai.bazon@gmail.com>\n                       http://mihai.bazon.net/blog\n\n  Distributed under the BSD license:\n\n    Copyright 2012 (c) Mihai Bazon <mihai.bazon@gmail.com>\n\n    Redistribution and use in source and binary forms, with or without\n    modification, are permitted provided that the following conditions\n    are met:\n\n        * Redistributions of source code must retain the above\n          copyright notice, this list of conditions and the following\n          disclaimer.\n\n        * Redistributions in binary form must reproduce the above\n          copyright notice, this list of conditions and the following\n          disclaimer in the documentation and/or other materials\n          provided with the distribution.\n\n    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER “AS IS” AND ANY\n    EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n    IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n    PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER BE\n    LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,\n    OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n    PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n    PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR\n    TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF\n    THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n    SUCH DAMAGE.\n\n ***********************************************************************/\n\n\"use strict\";\n\n(function () {\n  var MOZ_TO_ME = {\n    Program: function (M) {\n      return new AST_Toplevel({\n        start: my_start_token(M),\n        end: my_end_token(M),\n        body: normalize_directives(M.body.map(from_moz))\n      });\n    },\n    ArrowFunctionExpression: function (M) {\n      var argnames = [],\n        rest = null;\n      M.params.forEach(function (param) {\n        if (param.type == \"RestElement\") {\n          rest = from_moz(param.argument);\n        } else {\n          argnames.push(from_moz(param));\n        }\n      });\n      var fn = new (M.async ? AST_AsyncArrow : AST_Arrow)({\n        start: my_start_token(M),\n        end: my_end_token(M),\n        argnames: argnames,\n        rest: rest\n      });\n      var node = from_moz(M.body);\n      if (node instanceof AST_BlockStatement) {\n        fn.body = normalize_directives(node.body);\n        fn.value = null;\n      } else {\n        fn.body = [];\n        fn.value = node;\n      }\n      return fn;\n    },\n    FunctionDeclaration: function (M) {\n      var ctor;\n      if (M.async) {\n        ctor = M.generator ? AST_AsyncGeneratorDefun : AST_AsyncDefun;\n      } else {\n        ctor = M.generator ? AST_GeneratorDefun : AST_Defun;\n      }\n      var argnames = [],\n        rest = null;\n      M.params.forEach(function (param) {\n        if (param.type == \"RestElement\") {\n          rest = from_moz(param.argument);\n        } else {\n          argnames.push(from_moz(param));\n        }\n      });\n      return new ctor({\n        start: my_start_token(M),\n        end: my_end_token(M),\n        name: from_moz(M.id),\n        argnames: argnames,\n        rest: rest,\n        body: normalize_directives(from_moz(M.body).body)\n      });\n    },\n    FunctionExpression: function (M) {\n      var ctor;\n      if (M.async) {\n        ctor = M.generator ? AST_AsyncGeneratorFunction : AST_AsyncFunction;\n      } else {\n        ctor = M.generator ? AST_GeneratorFunction : AST_Function;\n      }\n      var argnames = [],\n        rest = null;\n      M.params.forEach(function (param) {\n        if (param.type == \"RestElement\") {\n          rest = from_moz(param.argument);\n        } else {\n          argnames.push(from_moz(param));\n        }\n      });\n      return new ctor({\n        start: my_start_token(M),\n        end: my_end_token(M),\n        name: from_moz(M.id),\n        argnames: argnames,\n        rest: rest,\n        body: normalize_directives(from_moz(M.body).body)\n      });\n    },\n    CallExpression: function (M) {\n      return new AST_Call({\n        start: my_start_token(M),\n        end: my_end_token(M),\n        expression: from_moz(M.callee),\n        args: M.arguments.map(from_moz),\n        optional: M.optional,\n        pure: M.pure\n      });\n    },\n    ClassDeclaration: function (M) {\n      return new AST_DefClass({\n        start: my_start_token(M),\n        end: my_end_token(M),\n        name: from_moz(M.id),\n        extends: from_moz(M.superClass),\n        properties: M.body.body.map(from_moz)\n      });\n    },\n    ClassExpression: function (M) {\n      return new AST_ClassExpression({\n        start: my_start_token(M),\n        end: my_end_token(M),\n        name: from_moz(M.id),\n        extends: from_moz(M.superClass),\n        properties: M.body.body.map(from_moz)\n      });\n    },\n    MethodDefinition: function (M) {\n      var key = M.key,\n        internal = false;\n      if (M.computed) {\n        key = from_moz(key);\n      } else if (key.type == \"PrivateIdentifier\") {\n        internal = true;\n        key = \"#\" + key.name;\n      } else {\n        key = read_name(key);\n      }\n      var ctor = AST_ClassMethod,\n        value = from_moz(M.value);\n      switch (M.kind) {\n        case \"get\":\n          ctor = AST_ClassGetter;\n          value = new AST_Accessor(value);\n          break;\n        case \"set\":\n          ctor = AST_ClassSetter;\n          value = new AST_Accessor(value);\n          break;\n      }\n      return new ctor({\n        start: my_start_token(M),\n        end: my_end_token(M),\n        key: key,\n        private: internal,\n        static: M.static,\n        value: value\n      });\n    },\n    PropertyDefinition: function (M) {\n      var key = M.key,\n        internal = false;\n      if (M.computed) {\n        key = from_moz(key);\n      } else if (key.type == \"PrivateIdentifier\") {\n        internal = true;\n        key = \"#\" + key.name;\n      } else {\n        key = read_name(key);\n      }\n      return new AST_ClassField({\n        start: my_start_token(M),\n        end: my_end_token(M),\n        key: key,\n        private: internal,\n        static: M.static,\n        value: from_moz(M.value)\n      });\n    },\n    StaticBlock: function (M) {\n      var start = my_start_token(M);\n      var end = my_end_token(M);\n      return new AST_ClassInit({\n        start: start,\n        end: end,\n        value: new AST_ClassInitBlock({\n          start: start,\n          end: end,\n          body: normalize_directives(M.body.map(from_moz))\n        })\n      });\n    },\n    ForOfStatement: function (M) {\n      return new (M.await ? AST_ForAwaitOf : AST_ForOf)({\n        start: my_start_token(M),\n        end: my_end_token(M),\n        init: from_moz(M.left),\n        object: from_moz(M.right),\n        body: from_moz(M.body)\n      });\n    },\n    TryStatement: function (M) {\n      var handlers = M.handlers || [M.handler];\n      if (handlers.length > 1 || M.guardedHandlers && M.guardedHandlers.length) {\n        throw new Error(\"Multiple catch clauses are not supported.\");\n      }\n      return new AST_Try({\n        start: my_start_token(M),\n        end: my_end_token(M),\n        body: from_moz(M.block).body,\n        bcatch: from_moz(handlers[0]),\n        bfinally: M.finalizer ? new AST_Finally(from_moz(M.finalizer)) : null\n      });\n    },\n    Property: function (M) {\n      var key = M.computed ? from_moz(M.key) : read_name(M.key);\n      var args = {\n        start: my_start_token(M),\n        end: my_end_token(M),\n        key: key,\n        value: from_moz(M.value)\n      };\n      if (M.kind == \"init\") return new (M.method ? AST_ObjectMethod : AST_ObjectKeyVal)(args);\n      args.value = new AST_Accessor(args.value);\n      if (M.kind == \"get\") return new AST_ObjectGetter(args);\n      if (M.kind == \"set\") return new AST_ObjectSetter(args);\n    },\n    ArrayExpression: function (M) {\n      return new AST_Array({\n        start: my_start_token(M),\n        end: my_end_token(M),\n        elements: M.elements.map(function (elem) {\n          return elem === null ? new AST_Hole() : from_moz(elem);\n        })\n      });\n    },\n    ArrayPattern: function (M) {\n      var elements = [],\n        rest = null;\n      M.elements.forEach(function (el) {\n        if (el === null) {\n          elements.push(new AST_Hole());\n        } else if (el.type == \"RestElement\") {\n          rest = from_moz(el.argument);\n        } else {\n          elements.push(from_moz(el));\n        }\n      });\n      return new AST_DestructuredArray({\n        start: my_start_token(M),\n        end: my_end_token(M),\n        elements: elements,\n        rest: rest\n      });\n    },\n    ObjectPattern: function (M) {\n      var props = [],\n        rest = null;\n      M.properties.forEach(function (prop) {\n        if (prop.type == \"RestElement\") {\n          rest = from_moz(prop.argument);\n        } else {\n          props.push(new AST_DestructuredKeyVal(from_moz(prop)));\n        }\n      });\n      return new AST_DestructuredObject({\n        start: my_start_token(M),\n        end: my_end_token(M),\n        properties: props,\n        rest: rest\n      });\n    },\n    MemberExpression: function (M) {\n      return new (M.computed ? AST_Sub : AST_Dot)({\n        start: my_start_token(M),\n        end: my_end_token(M),\n        optional: M.optional,\n        expression: from_moz(M.object),\n        property: M.computed ? from_moz(M.property) : M.property.name\n      });\n    },\n    MetaProperty: function (M) {\n      var expr = from_moz(M.meta);\n      var prop = read_name(M.property);\n      if (expr.name == \"new\" && prop == \"target\") return new AST_NewTarget({\n        start: my_start_token(M),\n        end: my_end_token(M),\n        name: \"new.target\"\n      });\n      return new AST_Dot({\n        start: my_start_token(M),\n        end: my_end_token(M),\n        expression: expr,\n        property: prop\n      });\n    },\n    SwitchCase: function (M) {\n      return new (M.test ? AST_Case : AST_Default)({\n        start: my_start_token(M),\n        end: my_end_token(M),\n        expression: from_moz(M.test),\n        body: M.consequent.map(from_moz)\n      });\n    },\n    ExportAllDeclaration: function (M) {\n      var start = my_start_token(M);\n      var end = my_end_token(M);\n      return new AST_ExportForeign({\n        start: start,\n        end: end,\n        aliases: [M.exported ? from_moz_alias(M.exported) : new AST_String({\n          start: start,\n          value: \"*\",\n          end: end\n        })],\n        keys: [new AST_String({\n          start: start,\n          value: \"*\",\n          end: end\n        })],\n        path: from_moz(M.source)\n      });\n    },\n    ExportDefaultDeclaration: function (M) {\n      var decl = from_moz(M.declaration);\n      if (!decl.name) switch (decl.CTOR) {\n        case AST_AsyncDefun:\n          decl = new AST_AsyncFunction(decl);\n          break;\n        case AST_AsyncGeneratorDefun:\n          decl = new AST_AsyncGeneratorFunction(decl);\n          break;\n        case AST_DefClass:\n          decl = new AST_ClassExpression(decl);\n          break;\n        case AST_Defun:\n          decl = new AST_Function(decl);\n          break;\n        case AST_GeneratorDefun:\n          decl = new AST_GeneratorFunction(decl);\n          break;\n      }\n      return new AST_ExportDefault({\n        start: my_start_token(M),\n        end: my_end_token(M),\n        body: decl\n      });\n    },\n    ExportNamedDeclaration: function (M) {\n      if (M.declaration) return new AST_ExportDeclaration({\n        start: my_start_token(M),\n        end: my_end_token(M),\n        body: from_moz(M.declaration)\n      });\n      if (M.source) {\n        var aliases = [],\n          keys = [];\n        M.specifiers.forEach(function (prop) {\n          aliases.push(from_moz_alias(prop.exported));\n          keys.push(from_moz_alias(prop.local));\n        });\n        return new AST_ExportForeign({\n          start: my_start_token(M),\n          end: my_end_token(M),\n          aliases: aliases,\n          keys: keys,\n          path: from_moz(M.source)\n        });\n      }\n      return new AST_ExportReferences({\n        start: my_start_token(M),\n        end: my_end_token(M),\n        properties: M.specifiers.map(function (prop) {\n          var sym = new AST_SymbolExport(from_moz(prop.local));\n          sym.alias = from_moz_alias(prop.exported);\n          return sym;\n        })\n      });\n    },\n    ImportDeclaration: function (M) {\n      var start = my_start_token(M);\n      var end = my_end_token(M);\n      var all = null,\n        def = null,\n        props = null;\n      M.specifiers.forEach(function (prop) {\n        var sym = new AST_SymbolImport(from_moz(prop.local));\n        switch (prop.type) {\n          case \"ImportDefaultSpecifier\":\n            def = sym;\n            def.key = new AST_String({\n              start: start,\n              value: \"\",\n              end: end\n            });\n            break;\n          case \"ImportNamespaceSpecifier\":\n            all = sym;\n            all.key = new AST_String({\n              start: start,\n              value: \"*\",\n              end: end\n            });\n            break;\n          default:\n            sym.key = from_moz_alias(prop.imported);\n            if (!props) props = [];\n            props.push(sym);\n            break;\n        }\n      });\n      return new AST_Import({\n        start: start,\n        end: end,\n        all: all,\n        default: def,\n        properties: props,\n        path: from_moz(M.source)\n      });\n    },\n    ImportExpression: function (M) {\n      var start = my_start_token(M);\n      var arg = from_moz(M.source);\n      return new AST_Call({\n        start: start,\n        end: my_end_token(M),\n        expression: new AST_SymbolRef({\n          start: start,\n          end: arg.start,\n          name: \"import\"\n        }),\n        args: [arg]\n      });\n    },\n    VariableDeclaration: function (M) {\n      return new ({\n        const: AST_Const,\n        let: AST_Let\n      }[M.kind] || AST_Var)({\n        start: my_start_token(M),\n        end: my_end_token(M),\n        definitions: M.declarations.map(from_moz)\n      });\n    },\n    Literal: function (M) {\n      var args = {\n        start: my_start_token(M),\n        end: my_end_token(M)\n      };\n      if (M.bigint) {\n        args.value = M.bigint.toLowerCase();\n        return new AST_BigInt(args);\n      }\n      var val = M.value;\n      if (val === null) return new AST_Null(args);\n      var rx = M.regex;\n      if (rx && rx.pattern) {\n        // RegExpLiteral as per ESTree AST spec\n        args.value = new RegExp(rx.pattern, rx.flags);\n        args.value.raw_source = rx.pattern;\n        return new AST_RegExp(args);\n      } else if (rx) {\n        // support legacy RegExp\n        args.value = M.regex && M.raw ? M.raw : val;\n        return new AST_RegExp(args);\n      }\n      switch (typeof val) {\n        case \"string\":\n          args.value = val;\n          return new AST_String(args);\n        case \"number\":\n          if (isNaN(val)) return new AST_NaN(args);\n          var negate, node;\n          if (isFinite(val)) {\n            negate = 1 / val < 0;\n            args.value = negate ? -val : val;\n            node = new AST_Number(args);\n          } else {\n            negate = val < 0;\n            node = new AST_Infinity(args);\n          }\n          return negate ? new AST_UnaryPrefix({\n            start: args.start,\n            end: args.end,\n            operator: \"-\",\n            expression: node\n          }) : node;\n        case \"boolean\":\n          return new (val ? AST_True : AST_False)(args);\n      }\n    },\n    TemplateLiteral: function (M) {\n      return new AST_Template({\n        start: my_start_token(M),\n        end: my_end_token(M),\n        expressions: M.expressions.map(from_moz),\n        strings: M.quasis.map(function (el) {\n          return el.value.raw;\n        })\n      });\n    },\n    TaggedTemplateExpression: function (M) {\n      var tmpl = from_moz(M.quasi);\n      tmpl.start = my_start_token(M);\n      tmpl.end = my_end_token(M);\n      tmpl.tag = from_moz(M.tag);\n      return tmpl;\n    },\n    Identifier: function (M) {\n      var p,\n        level = FROM_MOZ_STACK.length - 1;\n      do {\n        p = FROM_MOZ_STACK[--level];\n      } while (p.type == \"ArrayPattern\" || p.type == \"AssignmentPattern\" && p.left === FROM_MOZ_STACK[level + 1] || p.type == \"ObjectPattern\" || p.type == \"Property\" && p.value === FROM_MOZ_STACK[level + 1] || p.type == \"VariableDeclarator\" && p.id === FROM_MOZ_STACK[level + 1]);\n      var ctor = AST_SymbolRef;\n      switch (p.type) {\n        case \"ArrowFunctionExpression\":\n          if (p.body !== FROM_MOZ_STACK[level + 1]) ctor = AST_SymbolFunarg;\n          break;\n        case \"BreakStatement\":\n        case \"ContinueStatement\":\n          ctor = AST_LabelRef;\n          break;\n        case \"CatchClause\":\n          ctor = AST_SymbolCatch;\n          break;\n        case \"ClassDeclaration\":\n          if (p.id === FROM_MOZ_STACK[level + 1]) ctor = AST_SymbolDefClass;\n          break;\n        case \"ClassExpression\":\n          if (p.id === FROM_MOZ_STACK[level + 1]) ctor = AST_SymbolClass;\n          break;\n        case \"FunctionDeclaration\":\n          ctor = p.id === FROM_MOZ_STACK[level + 1] ? AST_SymbolDefun : AST_SymbolFunarg;\n          break;\n        case \"FunctionExpression\":\n          ctor = p.id === FROM_MOZ_STACK[level + 1] ? AST_SymbolLambda : AST_SymbolFunarg;\n          break;\n        case \"LabeledStatement\":\n          ctor = AST_Label;\n          break;\n        case \"VariableDeclaration\":\n          ctor = {\n            const: AST_SymbolConst,\n            let: AST_SymbolLet\n          }[p.kind] || AST_SymbolVar;\n          break;\n      }\n      return new ctor({\n        start: my_start_token(M),\n        end: my_end_token(M),\n        name: M.name\n      });\n    },\n    Super: function (M) {\n      return new AST_Super({\n        start: my_start_token(M),\n        end: my_end_token(M),\n        name: \"super\"\n      });\n    },\n    ThisExpression: function (M) {\n      return new AST_This({\n        start: my_start_token(M),\n        end: my_end_token(M),\n        name: \"this\"\n      });\n    },\n    ParenthesizedExpression: function (M) {\n      var node = from_moz(M.expression);\n      if (!node.start.parens) node.start.parens = [];\n      node.start.parens.push(my_start_token(M));\n      if (!node.end.parens) node.end.parens = [];\n      node.end.parens.push(my_end_token(M));\n      return node;\n    },\n    ChainExpression: function (M) {\n      var node = from_moz(M.expression);\n      node.terminal = true;\n      return node;\n    }\n  };\n  MOZ_TO_ME.UpdateExpression = MOZ_TO_ME.UnaryExpression = function To_Moz_Unary(M) {\n    var prefix = \"prefix\" in M ? M.prefix : M.type == \"UnaryExpression\" ? true : false;\n    return new (prefix ? AST_UnaryPrefix : AST_UnaryPostfix)({\n      start: my_start_token(M),\n      end: my_end_token(M),\n      operator: M.operator,\n      expression: from_moz(M.argument)\n    });\n  };\n  map(\"EmptyStatement\", AST_EmptyStatement);\n  map(\"ExpressionStatement\", AST_SimpleStatement, \"expression>body\");\n  map(\"BlockStatement\", AST_BlockStatement, \"body@body\");\n  map(\"IfStatement\", AST_If, \"test>condition, consequent>body, alternate>alternative\");\n  map(\"LabeledStatement\", AST_LabeledStatement, \"label>label, body>body\");\n  map(\"BreakStatement\", AST_Break, \"label>label\");\n  map(\"ContinueStatement\", AST_Continue, \"label>label\");\n  map(\"WithStatement\", AST_With, \"object>expression, body>body\");\n  map(\"SwitchStatement\", AST_Switch, \"discriminant>expression, cases@body\");\n  map(\"ReturnStatement\", AST_Return, \"argument>value\");\n  map(\"ThrowStatement\", AST_Throw, \"argument>value\");\n  map(\"WhileStatement\", AST_While, \"test>condition, body>body\");\n  map(\"DoWhileStatement\", AST_Do, \"test>condition, body>body\");\n  map(\"ForStatement\", AST_For, \"init>init, test>condition, update>step, body>body\");\n  map(\"ForInStatement\", AST_ForIn, \"left>init, right>object, body>body\");\n  map(\"DebuggerStatement\", AST_Debugger);\n  map(\"VariableDeclarator\", AST_VarDef, \"id>name, init>value\");\n  map(\"CatchClause\", AST_Catch, \"param>argname, body%body\");\n  map(\"BinaryExpression\", AST_Binary, \"operator=operator, left>left, right>right\");\n  map(\"LogicalExpression\", AST_Binary, \"operator=operator, left>left, right>right\");\n  map(\"AssignmentExpression\", AST_Assign, \"operator=operator, left>left, right>right\");\n  map(\"AssignmentPattern\", AST_DefaultValue, \"left>name, right>value\");\n  map(\"ConditionalExpression\", AST_Conditional, \"test>condition, consequent>consequent, alternate>alternative\");\n  map(\"NewExpression\", AST_New, \"callee>expression, arguments@args, pure=pure\");\n  map(\"SequenceExpression\", AST_Sequence, \"expressions@expressions\");\n  map(\"SpreadElement\", AST_Spread, \"argument>expression\");\n  map(\"ObjectExpression\", AST_Object, \"properties@properties\");\n  map(\"AwaitExpression\", AST_Await, \"argument>expression\");\n  map(\"YieldExpression\", AST_Yield, \"argument>expression, delegate=nested\");\n  def_to_moz(AST_Toplevel, function To_Moz_Program(M) {\n    return to_moz_scope(\"Program\", M);\n  });\n  def_to_moz(AST_LambdaDefinition, function To_Moz_FunctionDeclaration(M) {\n    var params = M.argnames.map(to_moz);\n    if (M.rest) params.push({\n      type: \"RestElement\",\n      argument: to_moz(M.rest)\n    });\n    return {\n      type: \"FunctionDeclaration\",\n      id: to_moz(M.name),\n      async: is_async(M),\n      generator: is_generator(M),\n      params: params,\n      body: to_moz_scope(\"BlockStatement\", M)\n    };\n  });\n  def_to_moz(AST_Lambda, function To_Moz_FunctionExpression(M) {\n    var params = M.argnames.map(to_moz);\n    if (M.rest) params.push({\n      type: \"RestElement\",\n      argument: to_moz(M.rest)\n    });\n    if (is_arrow(M)) return {\n      type: \"ArrowFunctionExpression\",\n      async: is_async(M),\n      params: params,\n      expression: !!M.value,\n      body: M.value ? to_moz(M.value) : to_moz_scope(\"BlockStatement\", M)\n    };\n    return {\n      type: \"FunctionExpression\",\n      id: to_moz(M.name),\n      async: is_async(M),\n      generator: is_generator(M),\n      params: params,\n      body: to_moz_scope(\"BlockStatement\", M)\n    };\n  });\n  def_to_moz(AST_Call, function To_Moz_CallExpression(M) {\n    var expr = M.expression;\n    if (M.args.length == 1 && expr instanceof AST_SymbolRef && expr.name == \"import\") return {\n      type: \"ImportExpression\",\n      source: to_moz(M.args[0])\n    };\n    return {\n      type: \"CallExpression\",\n      callee: to_moz(expr),\n      arguments: M.args.map(to_moz),\n      optional: M.optional,\n      pure: M.pure\n    };\n  });\n  def_to_moz(AST_DefClass, function To_Moz_ClassDeclaration(M) {\n    return {\n      type: \"ClassDeclaration\",\n      id: to_moz(M.name),\n      superClass: to_moz(M.extends),\n      body: {\n        type: \"ClassBody\",\n        body: M.properties.map(to_moz)\n      }\n    };\n  });\n  def_to_moz(AST_ClassExpression, function To_Moz_ClassExpression(M) {\n    return {\n      type: \"ClassExpression\",\n      id: to_moz(M.name),\n      superClass: to_moz(M.extends),\n      body: {\n        type: \"ClassBody\",\n        body: M.properties.map(to_moz)\n      }\n    };\n  });\n  function To_Moz_MethodDefinition(kind) {\n    return function (M) {\n      var computed = M.key instanceof AST_Node;\n      var key = computed ? to_moz(M.key) : M.private ? {\n        type: \"PrivateIdentifier\",\n        name: M.key.slice(1)\n      } : {\n        type: \"Literal\",\n        value: M.key\n      };\n      return {\n        type: \"MethodDefinition\",\n        kind: kind,\n        computed: computed,\n        key: key,\n        static: M.static,\n        value: to_moz(M.value)\n      };\n    };\n  }\n  def_to_moz(AST_ClassGetter, To_Moz_MethodDefinition(\"get\"));\n  def_to_moz(AST_ClassSetter, To_Moz_MethodDefinition(\"set\"));\n  def_to_moz(AST_ClassMethod, To_Moz_MethodDefinition(\"method\"));\n  def_to_moz(AST_ClassField, function To_Moz_PropertyDefinition(M) {\n    var computed = M.key instanceof AST_Node;\n    var key = computed ? to_moz(M.key) : M.private ? {\n      type: \"PrivateIdentifier\",\n      name: M.key.slice(1)\n    } : {\n      type: \"Literal\",\n      value: M.key\n    };\n    return {\n      type: \"PropertyDefinition\",\n      computed: computed,\n      key: key,\n      static: M.static,\n      value: to_moz(M.value)\n    };\n  });\n  def_to_moz(AST_ClassInit, function To_Moz_StaticBlock(M) {\n    return to_moz_scope(\"StaticBlock\", M.value);\n  });\n  function To_Moz_ForOfStatement(is_await) {\n    return function (M) {\n      return {\n        type: \"ForOfStatement\",\n        await: is_await,\n        left: to_moz(M.init),\n        right: to_moz(M.object),\n        body: to_moz(M.body)\n      };\n    };\n  }\n  def_to_moz(AST_ForAwaitOf, To_Moz_ForOfStatement(true));\n  def_to_moz(AST_ForOf, To_Moz_ForOfStatement(false));\n  def_to_moz(AST_Directive, function To_Moz_Directive(M) {\n    return {\n      type: \"ExpressionStatement\",\n      directive: M.value,\n      expression: set_moz_loc(M, {\n        type: \"Literal\",\n        value: M.value\n      })\n    };\n  });\n  def_to_moz(AST_SwitchBranch, function To_Moz_SwitchCase(M) {\n    return {\n      type: \"SwitchCase\",\n      test: to_moz(M.expression),\n      consequent: M.body.map(to_moz)\n    };\n  });\n  def_to_moz(AST_Try, function To_Moz_TryStatement(M) {\n    return {\n      type: \"TryStatement\",\n      block: to_moz_block(M),\n      handler: to_moz(M.bcatch),\n      finalizer: to_moz(M.bfinally)\n    };\n  });\n  def_to_moz(AST_Catch, function To_Moz_CatchClause(M) {\n    return {\n      type: \"CatchClause\",\n      param: to_moz(M.argname),\n      body: to_moz_block(M)\n    };\n  });\n  def_to_moz(AST_ExportDeclaration, function To_Moz_ExportNamedDeclaration_declaration(M) {\n    return {\n      type: \"ExportNamedDeclaration\",\n      declaration: to_moz(M.body),\n      specifiers: []\n    };\n  });\n  def_to_moz(AST_ExportDefault, function To_Moz_ExportDefaultDeclaration(M) {\n    return {\n      type: \"ExportDefaultDeclaration\",\n      declaration: to_moz(M.body)\n    };\n  });\n  def_to_moz(AST_ExportForeign, function To_Moz_ExportAllDeclaration_ExportNamedDeclaration(M) {\n    if (M.keys[0].value == \"*\") return {\n      type: \"ExportAllDeclaration\",\n      exported: M.aliases[0].value == \"*\" ? null : to_moz_alias(M.aliases[0]),\n      source: to_moz(M.path)\n    };\n    var specifiers = [];\n    for (var i = 0; i < M.aliases.length; i++) {\n      specifiers.push(set_moz_loc({\n        start: M.keys[i].start,\n        end: M.aliases[i].end\n      }, {\n        type: \"ExportSpecifier\",\n        local: to_moz_alias(M.keys[i]),\n        exported: to_moz_alias(M.aliases[i])\n      }));\n    }\n    return {\n      type: \"ExportNamedDeclaration\",\n      specifiers: specifiers,\n      source: to_moz(M.path)\n    };\n  });\n  def_to_moz(AST_ExportReferences, function To_Moz_ExportNamedDeclaration_specifiers(M) {\n    return {\n      type: \"ExportNamedDeclaration\",\n      specifiers: M.properties.map(function (prop) {\n        return set_moz_loc({\n          start: prop.start,\n          end: prop.alias.end\n        }, {\n          type: \"ExportSpecifier\",\n          local: to_moz(prop),\n          exported: to_moz_alias(prop.alias)\n        });\n      })\n    };\n  });\n  def_to_moz(AST_Import, function To_Moz_ImportDeclaration(M) {\n    var specifiers = M.properties ? M.properties.map(function (prop) {\n      return set_moz_loc({\n        start: prop.key.start,\n        end: prop.end\n      }, {\n        type: \"ImportSpecifier\",\n        local: to_moz(prop),\n        imported: to_moz_alias(prop.key)\n      });\n    }) : [];\n    if (M.all) specifiers.unshift(set_moz_loc(M.all, {\n      type: \"ImportNamespaceSpecifier\",\n      local: to_moz(M.all)\n    }));\n    if (M.default) specifiers.unshift(set_moz_loc(M.default, {\n      type: \"ImportDefaultSpecifier\",\n      local: to_moz(M.default)\n    }));\n    return {\n      type: \"ImportDeclaration\",\n      specifiers: specifiers,\n      source: to_moz(M.path)\n    };\n  });\n  def_to_moz(AST_Definitions, function To_Moz_VariableDeclaration(M) {\n    return {\n      type: \"VariableDeclaration\",\n      kind: M.TYPE.toLowerCase(),\n      declarations: M.definitions.map(to_moz)\n    };\n  });\n  def_to_moz(AST_PropAccess, function To_Moz_MemberExpression(M) {\n    var computed = M instanceof AST_Sub;\n    var expr = {\n      type: \"MemberExpression\",\n      object: to_moz(M.expression),\n      computed: computed,\n      optional: M.optional,\n      property: computed ? to_moz(M.property) : {\n        type: \"Identifier\",\n        name: M.property\n      }\n    };\n    return M.terminal ? {\n      type: \"ChainExpression\",\n      expression: expr\n    } : expr;\n  });\n  def_to_moz(AST_Unary, function To_Moz_Unary(M) {\n    return {\n      type: M.operator == \"++\" || M.operator == \"--\" ? \"UpdateExpression\" : \"UnaryExpression\",\n      operator: M.operator,\n      prefix: M instanceof AST_UnaryPrefix,\n      argument: to_moz(M.expression)\n    };\n  });\n  def_to_moz(AST_Binary, function To_Moz_BinaryExpression(M) {\n    return {\n      type: M.operator == \"&&\" || M.operator == \"||\" ? \"LogicalExpression\" : \"BinaryExpression\",\n      left: to_moz(M.left),\n      operator: M.operator,\n      right: to_moz(M.right)\n    };\n  });\n  def_to_moz(AST_Array, function To_Moz_ArrayExpression(M) {\n    return {\n      type: \"ArrayExpression\",\n      elements: M.elements.map(to_moz)\n    };\n  });\n  def_to_moz(AST_DestructuredArray, function To_Moz_ArrayPattern(M) {\n    var elements = M.elements.map(to_moz);\n    if (M.rest) elements.push({\n      type: \"RestElement\",\n      argument: to_moz(M.rest)\n    });\n    return {\n      type: \"ArrayPattern\",\n      elements: elements\n    };\n  });\n  def_to_moz(AST_DestructuredKeyVal, function To_Moz_Property(M) {\n    var computed = M.key instanceof AST_Node;\n    var key = computed ? to_moz(M.key) : {\n      type: \"Literal\",\n      value: M.key\n    };\n    return {\n      type: \"Property\",\n      kind: \"init\",\n      computed: computed,\n      method: false,\n      shorthand: false,\n      key: key,\n      value: to_moz(M.value)\n    };\n  });\n  def_to_moz(AST_DestructuredObject, function To_Moz_ObjectPattern(M) {\n    var props = M.properties.map(to_moz);\n    if (M.rest) props.push({\n      type: \"RestElement\",\n      argument: to_moz(M.rest)\n    });\n    return {\n      type: \"ObjectPattern\",\n      properties: props\n    };\n  });\n  def_to_moz(AST_ObjectProperty, function To_Moz_Property(M) {\n    var computed = M.key instanceof AST_Node;\n    var key = computed ? to_moz(M.key) : {\n      type: \"Literal\",\n      value: M.key\n    };\n    var kind;\n    if (M instanceof AST_ObjectKeyVal) {\n      kind = \"init\";\n    } else if (M instanceof AST_ObjectGetter) {\n      kind = \"get\";\n    } else if (M instanceof AST_ObjectSetter) {\n      kind = \"set\";\n    }\n    return {\n      type: \"Property\",\n      kind: kind,\n      computed: computed,\n      method: M instanceof AST_ObjectMethod,\n      shorthand: false,\n      key: key,\n      value: to_moz(M.value)\n    };\n  });\n  def_to_moz(AST_Symbol, function To_Moz_Identifier(M) {\n    var def = M.definition();\n    return {\n      type: \"Identifier\",\n      name: def && def.mangled_name || M.name\n    };\n  });\n  def_to_moz(AST_Super, function To_Moz_Super() {\n    return {\n      type: \"Super\"\n    };\n  });\n  def_to_moz(AST_This, function To_Moz_ThisExpression() {\n    return {\n      type: \"ThisExpression\"\n    };\n  });\n  def_to_moz(AST_NewTarget, function To_Moz_MetaProperty() {\n    return {\n      type: \"MetaProperty\",\n      meta: {\n        type: \"Identifier\",\n        name: \"new\"\n      },\n      property: {\n        type: \"Identifier\",\n        name: \"target\"\n      }\n    };\n  });\n  def_to_moz(AST_RegExp, function To_Moz_RegExpLiteral(M) {\n    var flags = M.value.toString().match(/\\/([gimuy]*)$/)[1];\n    var value = \"/\" + M.value.raw_source + \"/\" + flags;\n    return {\n      type: \"Literal\",\n      value: value,\n      raw: value,\n      regex: {\n        pattern: M.value.raw_source,\n        flags: flags\n      }\n    };\n  });\n  def_to_moz(AST_BigInt, function To_Moz_BigInt(M) {\n    var value = M.value;\n    return {\n      type: \"Literal\",\n      bigint: value,\n      raw: value + \"n\"\n    };\n  });\n  function To_Moz_Literal(M) {\n    var value = M.value;\n    if (typeof value === \"number\" && (value < 0 || value === 0 && 1 / value < 0)) {\n      return {\n        type: \"UnaryExpression\",\n        operator: \"-\",\n        prefix: true,\n        argument: {\n          type: \"Literal\",\n          value: -value,\n          raw: M.start.raw\n        }\n      };\n    }\n    return {\n      type: \"Literal\",\n      value: value,\n      raw: M.start.raw\n    };\n  }\n  def_to_moz(AST_Boolean, To_Moz_Literal);\n  def_to_moz(AST_Constant, To_Moz_Literal);\n  def_to_moz(AST_Null, To_Moz_Literal);\n  def_to_moz(AST_Atom, function To_Moz_Atom(M) {\n    return {\n      type: \"Identifier\",\n      name: String(M.value)\n    };\n  });\n  def_to_moz(AST_Template, function To_Moz_TemplateLiteral_TaggedTemplateExpression(M) {\n    var last = M.strings.length - 1;\n    var tmpl = {\n      type: \"TemplateLiteral\",\n      expressions: M.expressions.map(to_moz),\n      quasis: M.strings.map(function (str, index) {\n        return {\n          type: \"TemplateElement\",\n          tail: index == last,\n          value: {\n            raw: str\n          }\n        };\n      })\n    };\n    if (!M.tag) return tmpl;\n    return {\n      type: \"TaggedTemplateExpression\",\n      tag: to_moz(M.tag),\n      quasi: tmpl\n    };\n  });\n  AST_Block.DEFMETHOD(\"to_mozilla_ast\", AST_BlockStatement.prototype.to_mozilla_ast);\n  AST_Hole.DEFMETHOD(\"to_mozilla_ast\", return_null);\n  AST_Node.DEFMETHOD(\"to_mozilla_ast\", function () {\n    throw new Error(\"Cannot convert AST_\" + this.TYPE);\n  });\n\n  /* -----[ tools ]----- */\n\n  function normalize_directives(body) {\n    for (var i = 0; i < body.length; i++) {\n      var stat = body[i];\n      if (!(stat instanceof AST_SimpleStatement)) break;\n      var node = stat.body;\n      if (!(node instanceof AST_String)) break;\n      if (stat.start.pos !== node.start.pos) break;\n      body[i] = new AST_Directive(node);\n    }\n    return body;\n  }\n  function raw_token(moznode) {\n    if (moznode.type == \"Literal\") {\n      return moznode.raw != null ? moznode.raw : moznode.value + \"\";\n    }\n  }\n  function my_start_token(moznode) {\n    var loc = moznode.loc,\n      start = loc && loc.start;\n    var range = moznode.range;\n    return new AST_Token({\n      file: loc && loc.source,\n      line: start && start.line,\n      col: start && start.column,\n      pos: range ? range[0] : moznode.start,\n      endline: start && start.line,\n      endcol: start && start.column,\n      endpos: range ? range[0] : moznode.start,\n      raw: raw_token(moznode)\n    });\n  }\n  function my_end_token(moznode) {\n    var loc = moznode.loc,\n      end = loc && loc.end;\n    var range = moznode.range;\n    return new AST_Token({\n      file: loc && loc.source,\n      line: end && end.line,\n      col: end && end.column,\n      pos: range ? range[1] : moznode.end,\n      endline: end && end.line,\n      endcol: end && end.column,\n      endpos: range ? range[1] : moznode.end,\n      raw: raw_token(moznode)\n    });\n  }\n  function read_name(M) {\n    return \"\" + M[M.type == \"Identifier\" ? \"name\" : \"value\"];\n  }\n  function map(moztype, mytype, propmap) {\n    var moz_to_me = [\"start: my_start_token(M)\", \"end: my_end_token(M)\"];\n    var me_to_moz = [\"type: \" + JSON.stringify(moztype)];\n    if (propmap) propmap.split(/\\s*,\\s*/).forEach(function (prop) {\n      var m = /([a-z0-9$_]+)(=|@|>|%)([a-z0-9$_]+)/i.exec(prop);\n      if (!m) throw new Error(\"Can't understand property map: \" + prop);\n      var moz = m[1],\n        how = m[2],\n        my = m[3];\n      switch (how) {\n        case \"@\":\n          moz_to_me.push(my + \": M.\" + moz + \".map(from_moz)\");\n          me_to_moz.push(moz + \": M.\" + my + \".map(to_moz)\");\n          break;\n        case \">\":\n          moz_to_me.push(my + \": from_moz(M.\" + moz + \")\");\n          me_to_moz.push(moz + \": to_moz(M.\" + my + \")\");\n          break;\n        case \"=\":\n          moz_to_me.push(my + \": M.\" + moz);\n          me_to_moz.push(moz + \": M.\" + my);\n          break;\n        case \"%\":\n          moz_to_me.push(my + \": from_moz(M.\" + moz + \").body\");\n          me_to_moz.push(moz + \": to_moz_block(M)\");\n          break;\n        default:\n          throw new Error(\"Can't understand operator in propmap: \" + prop);\n      }\n    });\n    MOZ_TO_ME[moztype] = new Function(\"U2\", \"my_start_token\", \"my_end_token\", \"from_moz\", [\"return function From_Moz_\" + moztype + \"(M) {\", \"    return new U2.AST_\" + mytype.TYPE + \"({\", moz_to_me.join(\",\\n\"), \"    });\", \"};\"].join(\"\\n\"))(exports, my_start_token, my_end_token, from_moz);\n    def_to_moz(mytype, new Function(\"to_moz\", \"to_moz_block\", \"to_moz_scope\", [\"return function To_Moz_\" + moztype + \"(M) {\", \"    return {\", me_to_moz.join(\",\\n\"), \"    };\", \"};\"].join(\"\\n\"))(to_moz, to_moz_block, to_moz_scope));\n  }\n  var FROM_MOZ_STACK = null;\n  function from_moz(moz) {\n    FROM_MOZ_STACK.push(moz);\n    var node = null;\n    if (moz) {\n      if (!HOP(MOZ_TO_ME, moz.type)) throw new Error(\"Unsupported type: \" + moz.type);\n      node = MOZ_TO_ME[moz.type](moz);\n    }\n    FROM_MOZ_STACK.pop();\n    return node;\n  }\n  function from_moz_alias(moz) {\n    return new AST_String({\n      start: my_start_token(moz),\n      value: read_name(moz),\n      end: my_end_token(moz)\n    });\n  }\n  AST_Node.from_mozilla_ast = function (node) {\n    var save_stack = FROM_MOZ_STACK;\n    FROM_MOZ_STACK = [];\n    var ast = from_moz(node);\n    FROM_MOZ_STACK = save_stack;\n    ast.walk(new TreeWalker(function (node) {\n      if (node instanceof AST_LabelRef) {\n        for (var level = 0, parent; parent = this.parent(level); level++) {\n          if (parent instanceof AST_Scope) break;\n          if (parent instanceof AST_LabeledStatement && parent.label.name == node.name) {\n            node.thedef = parent.label;\n            break;\n          }\n        }\n        if (!node.thedef) {\n          var s = node.start;\n          js_error(\"Undefined label \" + node.name, s.file, s.line, s.col, s.pos);\n        }\n      }\n    }));\n    return ast;\n  };\n  function set_moz_loc(mynode, moznode) {\n    var start = mynode.start;\n    var end = mynode.end;\n    if (start.pos != null && end.endpos != null) {\n      moznode.range = [start.pos, end.endpos];\n    }\n    if (start.line) {\n      moznode.loc = {\n        start: {\n          line: start.line,\n          column: start.col\n        },\n        end: end.endline ? {\n          line: end.endline,\n          column: end.endcol\n        } : null\n      };\n      if (start.file) {\n        moznode.loc.source = start.file;\n      }\n    }\n    return moznode;\n  }\n  function def_to_moz(mytype, handler) {\n    mytype.DEFMETHOD(\"to_mozilla_ast\", function () {\n      return set_moz_loc(this, handler(this));\n    });\n  }\n  function to_moz(node) {\n    return node != null ? node.to_mozilla_ast() : null;\n  }\n  function to_moz_alias(alias) {\n    return is_identifier_string(alias.value) ? set_moz_loc(alias, {\n      type: \"Identifier\",\n      name: alias.value\n    }) : to_moz(alias);\n  }\n  function to_moz_block(node) {\n    return {\n      type: \"BlockStatement\",\n      body: node.body.map(to_moz)\n    };\n  }\n  function to_moz_scope(type, node) {\n    var body = node.body.map(to_moz);\n    if (node.body[0] instanceof AST_SimpleStatement && node.body[0].body instanceof AST_String) {\n      body.unshift(to_moz(new AST_EmptyStatement(node.body[0])));\n    }\n    return {\n      type: type,\n      body: body\n    };\n  }\n})();","map":{"version":3,"names":["MOZ_TO_ME","Program","M","AST_Toplevel","start","my_start_token","end","my_end_token","body","normalize_directives","map","from_moz","ArrowFunctionExpression","argnames","rest","params","forEach","param","type","argument","push","fn","async","AST_AsyncArrow","AST_Arrow","node","AST_BlockStatement","value","FunctionDeclaration","ctor","generator","AST_AsyncGeneratorDefun","AST_AsyncDefun","AST_GeneratorDefun","AST_Defun","name","id","FunctionExpression","AST_AsyncGeneratorFunction","AST_AsyncFunction","AST_GeneratorFunction","AST_Function","CallExpression","AST_Call","expression","callee","args","arguments","optional","pure","ClassDeclaration","AST_DefClass","extends","superClass","properties","ClassExpression","AST_ClassExpression","MethodDefinition","key","internal","computed","read_name","AST_ClassMethod","kind","AST_ClassGetter","AST_Accessor","AST_ClassSetter","private","static","PropertyDefinition","AST_ClassField","StaticBlock","AST_ClassInit","AST_ClassInitBlock","ForOfStatement","await","AST_ForAwaitOf","AST_ForOf","init","left","object","right","TryStatement","handlers","handler","length","guardedHandlers","Error","AST_Try","block","bcatch","bfinally","finalizer","AST_Finally","Property","method","AST_ObjectMethod","AST_ObjectKeyVal","AST_ObjectGetter","AST_ObjectSetter","ArrayExpression","AST_Array","elements","elem","AST_Hole","ArrayPattern","el","AST_DestructuredArray","ObjectPattern","props","prop","AST_DestructuredKeyVal","AST_DestructuredObject","MemberExpression","AST_Sub","AST_Dot","property","MetaProperty","expr","meta","AST_NewTarget","SwitchCase","test","AST_Case","AST_Default","consequent","ExportAllDeclaration","AST_ExportForeign","aliases","exported","from_moz_alias","AST_String","keys","path","source","ExportDefaultDeclaration","decl","declaration","CTOR","AST_ExportDefault","ExportNamedDeclaration","AST_ExportDeclaration","specifiers","local","AST_ExportReferences","sym","AST_SymbolExport","alias","ImportDeclaration","all","def","AST_SymbolImport","imported","AST_Import","default","ImportExpression","arg","AST_SymbolRef","VariableDeclaration","const","AST_Const","let","AST_Let","AST_Var","definitions","declarations","Literal","bigint","toLowerCase","AST_BigInt","val","AST_Null","rx","regex","pattern","RegExp","flags","raw_source","AST_RegExp","raw","isNaN","AST_NaN","negate","isFinite","AST_Number","AST_Infinity","AST_UnaryPrefix","operator","AST_True","AST_False","TemplateLiteral","AST_Template","expressions","strings","quasis","TaggedTemplateExpression","tmpl","quasi","tag","Identifier","p","level","FROM_MOZ_STACK","AST_SymbolFunarg","AST_LabelRef","AST_SymbolCatch","AST_SymbolDefClass","AST_SymbolClass","AST_SymbolDefun","AST_SymbolLambda","AST_Label","AST_SymbolConst","AST_SymbolLet","AST_SymbolVar","Super","AST_Super","ThisExpression","AST_This","ParenthesizedExpression","parens","ChainExpression","terminal","UpdateExpression","UnaryExpression","To_Moz_Unary","prefix","AST_UnaryPostfix","AST_EmptyStatement","AST_SimpleStatement","AST_If","AST_LabeledStatement","AST_Break","AST_Continue","AST_With","AST_Switch","AST_Return","AST_Throw","AST_While","AST_Do","AST_For","AST_ForIn","AST_Debugger","AST_VarDef","AST_Catch","AST_Binary","AST_Assign","AST_DefaultValue","AST_Conditional","AST_New","AST_Sequence","AST_Spread","AST_Object","AST_Await","AST_Yield","def_to_moz","To_Moz_Program","to_moz_scope","AST_LambdaDefinition","To_Moz_FunctionDeclaration","to_moz","is_async","is_generator","AST_Lambda","To_Moz_FunctionExpression","is_arrow","To_Moz_CallExpression","To_Moz_ClassDeclaration","To_Moz_ClassExpression","To_Moz_MethodDefinition","AST_Node","slice","To_Moz_PropertyDefinition","To_Moz_StaticBlock","To_Moz_ForOfStatement","is_await","AST_Directive","To_Moz_Directive","directive","set_moz_loc","AST_SwitchBranch","To_Moz_SwitchCase","To_Moz_TryStatement","to_moz_block","To_Moz_CatchClause","argname","To_Moz_ExportNamedDeclaration_declaration","To_Moz_ExportDefaultDeclaration","To_Moz_ExportAllDeclaration_ExportNamedDeclaration","to_moz_alias","i","To_Moz_ExportNamedDeclaration_specifiers","To_Moz_ImportDeclaration","unshift","AST_Definitions","To_Moz_VariableDeclaration","TYPE","AST_PropAccess","To_Moz_MemberExpression","AST_Unary","To_Moz_BinaryExpression","To_Moz_ArrayExpression","To_Moz_ArrayPattern","To_Moz_Property","shorthand","To_Moz_ObjectPattern","AST_ObjectProperty","AST_Symbol","To_Moz_Identifier","definition","mangled_name","To_Moz_Super","To_Moz_ThisExpression","To_Moz_MetaProperty","To_Moz_RegExpLiteral","toString","match","To_Moz_BigInt","To_Moz_Literal","AST_Boolean","AST_Constant","AST_Atom","To_Moz_Atom","String","To_Moz_TemplateLiteral_TaggedTemplateExpression","last","str","index","tail","AST_Block","DEFMETHOD","prototype","to_mozilla_ast","return_null","stat","pos","raw_token","moznode","loc","range","AST_Token","file","line","col","column","endline","endcol","endpos","moztype","mytype","propmap","moz_to_me","me_to_moz","JSON","stringify","split","m","exec","moz","how","my","Function","join","exports","HOP","pop","from_mozilla_ast","save_stack","ast","walk","TreeWalker","parent","AST_Scope","label","thedef","s","js_error","mynode","is_identifier_string"],"sources":["F:/landinghub-iconic/node_modules/.pnpm/uglify-js@3.19.3/node_modules/uglify-js/lib/mozilla-ast.js"],"sourcesContent":["/***********************************************************************\n\n  A JavaScript tokenizer / parser / beautifier / compressor.\n  https://github.com/mishoo/UglifyJS\n\n  -------------------------------- (C) ---------------------------------\n\n                           Author: Mihai Bazon\n                         <mihai.bazon@gmail.com>\n                       http://mihai.bazon.net/blog\n\n  Distributed under the BSD license:\n\n    Copyright 2012 (c) Mihai Bazon <mihai.bazon@gmail.com>\n\n    Redistribution and use in source and binary forms, with or without\n    modification, are permitted provided that the following conditions\n    are met:\n\n        * Redistributions of source code must retain the above\n          copyright notice, this list of conditions and the following\n          disclaimer.\n\n        * Redistributions in binary form must reproduce the above\n          copyright notice, this list of conditions and the following\n          disclaimer in the documentation and/or other materials\n          provided with the distribution.\n\n    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER “AS IS” AND ANY\n    EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n    IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n    PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER BE\n    LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,\n    OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n    PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n    PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR\n    TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF\n    THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n    SUCH DAMAGE.\n\n ***********************************************************************/\n\n\"use strict\";\n\n(function() {\n    var MOZ_TO_ME = {\n        Program: function(M) {\n            return new AST_Toplevel({\n                start: my_start_token(M),\n                end: my_end_token(M),\n                body: normalize_directives(M.body.map(from_moz)),\n            });\n        },\n        ArrowFunctionExpression: function(M) {\n            var argnames = [], rest = null;\n            M.params.forEach(function(param) {\n                if (param.type == \"RestElement\") {\n                    rest = from_moz(param.argument);\n                } else {\n                    argnames.push(from_moz(param));\n                }\n            });\n            var fn = new (M.async ? AST_AsyncArrow : AST_Arrow)({\n                start: my_start_token(M),\n                end: my_end_token(M),\n                argnames: argnames,\n                rest: rest,\n            });\n            var node = from_moz(M.body);\n            if (node instanceof AST_BlockStatement) {\n                fn.body = normalize_directives(node.body);\n                fn.value = null;\n            } else {\n                fn.body = [];\n                fn.value = node;\n            }\n            return fn;\n        },\n        FunctionDeclaration: function(M) {\n            var ctor;\n            if (M.async) {\n                ctor = M.generator ? AST_AsyncGeneratorDefun : AST_AsyncDefun;\n            } else {\n                ctor = M.generator ? AST_GeneratorDefun : AST_Defun;\n            }\n            var argnames = [], rest = null;\n            M.params.forEach(function(param) {\n                if (param.type == \"RestElement\") {\n                    rest = from_moz(param.argument);\n                } else {\n                    argnames.push(from_moz(param));\n                }\n            });\n            return new ctor({\n                start: my_start_token(M),\n                end: my_end_token(M),\n                name: from_moz(M.id),\n                argnames: argnames,\n                rest: rest,\n                body: normalize_directives(from_moz(M.body).body),\n            });\n        },\n        FunctionExpression: function(M) {\n            var ctor;\n            if (M.async) {\n                ctor = M.generator ? AST_AsyncGeneratorFunction : AST_AsyncFunction;\n            } else {\n                ctor = M.generator ? AST_GeneratorFunction : AST_Function;\n            }\n            var argnames = [], rest = null;\n            M.params.forEach(function(param) {\n                if (param.type == \"RestElement\") {\n                    rest = from_moz(param.argument);\n                } else {\n                    argnames.push(from_moz(param));\n                }\n            });\n            return new ctor({\n                start: my_start_token(M),\n                end: my_end_token(M),\n                name: from_moz(M.id),\n                argnames: argnames,\n                rest: rest,\n                body: normalize_directives(from_moz(M.body).body),\n            });\n        },\n        CallExpression: function(M) {\n            return new AST_Call({\n                start: my_start_token(M),\n                end: my_end_token(M),\n                expression: from_moz(M.callee),\n                args: M.arguments.map(from_moz),\n                optional: M.optional,\n                pure: M.pure,\n            });\n        },\n        ClassDeclaration: function(M) {\n            return new AST_DefClass({\n                start: my_start_token(M),\n                end: my_end_token(M),\n                name: from_moz(M.id),\n                extends: from_moz(M.superClass),\n                properties: M.body.body.map(from_moz),\n            });\n        },\n        ClassExpression: function(M) {\n            return new AST_ClassExpression({\n                start: my_start_token(M),\n                end: my_end_token(M),\n                name: from_moz(M.id),\n                extends: from_moz(M.superClass),\n                properties: M.body.body.map(from_moz),\n            });\n        },\n        MethodDefinition: function(M) {\n            var key = M.key, internal = false;\n            if (M.computed) {\n                key = from_moz(key);\n            } else if (key.type == \"PrivateIdentifier\") {\n                internal = true;\n                key = \"#\" + key.name;\n            } else {\n                key = read_name(key);\n            }\n            var ctor = AST_ClassMethod, value = from_moz(M.value);\n            switch (M.kind) {\n              case \"get\":\n                ctor = AST_ClassGetter;\n                value = new AST_Accessor(value);\n                break;\n              case \"set\":\n                ctor = AST_ClassSetter;\n                value = new AST_Accessor(value);\n                break;\n            }\n            return new ctor({\n                start: my_start_token(M),\n                end: my_end_token(M),\n                key: key,\n                private: internal,\n                static: M.static,\n                value: value,\n            });\n        },\n        PropertyDefinition: function(M) {\n            var key = M.key, internal = false;\n            if (M.computed) {\n                key = from_moz(key);\n            } else if (key.type == \"PrivateIdentifier\") {\n                internal = true;\n                key = \"#\" + key.name;\n            } else {\n                key = read_name(key);\n            }\n            return new AST_ClassField({\n                start: my_start_token(M),\n                end: my_end_token(M),\n                key: key,\n                private: internal,\n                static: M.static,\n                value: from_moz(M.value),\n            });\n        },\n        StaticBlock: function(M) {\n            var start = my_start_token(M);\n            var end = my_end_token(M);\n            return new AST_ClassInit({\n                start: start,\n                end: end,\n                value: new AST_ClassInitBlock({\n                    start: start,\n                    end: end,\n                    body: normalize_directives(M.body.map(from_moz)),\n                }),\n            });\n        },\n        ForOfStatement: function(M) {\n            return new (M.await ? AST_ForAwaitOf : AST_ForOf)({\n                start: my_start_token(M),\n                end: my_end_token(M),\n                init: from_moz(M.left),\n                object: from_moz(M.right),\n                body: from_moz(M.body),\n            });\n        },\n        TryStatement: function(M) {\n            var handlers = M.handlers || [M.handler];\n            if (handlers.length > 1 || M.guardedHandlers && M.guardedHandlers.length) {\n                throw new Error(\"Multiple catch clauses are not supported.\");\n            }\n            return new AST_Try({\n                start    : my_start_token(M),\n                end      : my_end_token(M),\n                body     : from_moz(M.block).body,\n                bcatch   : from_moz(handlers[0]),\n                bfinally : M.finalizer ? new AST_Finally(from_moz(M.finalizer)) : null,\n            });\n        },\n        Property: function(M) {\n            var key = M.computed ? from_moz(M.key) : read_name(M.key);\n            var args = {\n                start: my_start_token(M),\n                end: my_end_token(M),\n                key: key,\n                value: from_moz(M.value),\n            };\n            if (M.kind == \"init\") return new (M.method ? AST_ObjectMethod : AST_ObjectKeyVal)(args);\n            args.value = new AST_Accessor(args.value);\n            if (M.kind == \"get\") return new AST_ObjectGetter(args);\n            if (M.kind == \"set\") return new AST_ObjectSetter(args);\n        },\n        ArrayExpression: function(M) {\n            return new AST_Array({\n                start: my_start_token(M),\n                end: my_end_token(M),\n                elements: M.elements.map(function(elem) {\n                    return elem === null ? new AST_Hole() : from_moz(elem);\n                }),\n            });\n        },\n        ArrayPattern: function(M) {\n            var elements = [], rest = null;\n            M.elements.forEach(function(el) {\n                if (el === null) {\n                    elements.push(new AST_Hole());\n                } else if (el.type == \"RestElement\") {\n                    rest = from_moz(el.argument);\n                } else {\n                    elements.push(from_moz(el));\n                }\n            });\n            return new AST_DestructuredArray({\n                start: my_start_token(M),\n                end: my_end_token(M),\n                elements: elements,\n                rest: rest,\n            });\n        },\n        ObjectPattern: function(M) {\n            var props = [], rest = null;\n            M.properties.forEach(function(prop) {\n                if (prop.type == \"RestElement\") {\n                    rest = from_moz(prop.argument);\n                } else {\n                    props.push(new AST_DestructuredKeyVal(from_moz(prop)));\n                }\n            });\n            return new AST_DestructuredObject({\n                start: my_start_token(M),\n                end: my_end_token(M),\n                properties: props,\n                rest: rest,\n            });\n        },\n        MemberExpression: function(M) {\n            return new (M.computed ? AST_Sub : AST_Dot)({\n                start: my_start_token(M),\n                end: my_end_token(M),\n                optional: M.optional,\n                expression: from_moz(M.object),\n                property: M.computed ? from_moz(M.property) : M.property.name,\n            });\n        },\n        MetaProperty: function(M) {\n            var expr = from_moz(M.meta);\n            var prop = read_name(M.property);\n            if (expr.name == \"new\" && prop == \"target\") return new AST_NewTarget({\n                start: my_start_token(M),\n                end: my_end_token(M),\n                name: \"new.target\",\n            });\n            return new AST_Dot({\n                start: my_start_token(M),\n                end: my_end_token(M),\n                expression: expr,\n                property: prop,\n            });\n        },\n        SwitchCase: function(M) {\n            return new (M.test ? AST_Case : AST_Default)({\n                start      : my_start_token(M),\n                end        : my_end_token(M),\n                expression : from_moz(M.test),\n                body       : M.consequent.map(from_moz),\n            });\n        },\n        ExportAllDeclaration: function(M) {\n            var start = my_start_token(M);\n            var end = my_end_token(M);\n            return new AST_ExportForeign({\n                start: start,\n                end: end,\n                aliases: [ M.exported ? from_moz_alias(M.exported) : new AST_String({\n                    start: start,\n                    value: \"*\",\n                    end: end,\n                }) ],\n                keys: [ new AST_String({\n                    start: start,\n                    value: \"*\",\n                    end: end,\n                }) ],\n                path: from_moz(M.source),\n            });\n        },\n        ExportDefaultDeclaration: function(M) {\n            var decl = from_moz(M.declaration);\n            if (!decl.name) switch (decl.CTOR) {\n              case AST_AsyncDefun:\n                decl = new AST_AsyncFunction(decl);\n                break;\n              case AST_AsyncGeneratorDefun:\n                decl = new AST_AsyncGeneratorFunction(decl);\n                break;\n              case AST_DefClass:\n                decl = new AST_ClassExpression(decl);\n                break;\n              case AST_Defun:\n                decl = new AST_Function(decl);\n                break;\n              case AST_GeneratorDefun:\n                decl = new AST_GeneratorFunction(decl);\n                break;\n            }\n            return new AST_ExportDefault({\n                start: my_start_token(M),\n                end: my_end_token(M),\n                body: decl,\n            });\n        },\n        ExportNamedDeclaration: function(M) {\n            if (M.declaration) return new AST_ExportDeclaration({\n                start: my_start_token(M),\n                end: my_end_token(M),\n                body: from_moz(M.declaration),\n            });\n            if (M.source) {\n                var aliases = [], keys = [];\n                M.specifiers.forEach(function(prop) {\n                    aliases.push(from_moz_alias(prop.exported));\n                    keys.push(from_moz_alias(prop.local));\n                });\n                return new AST_ExportForeign({\n                    start: my_start_token(M),\n                    end: my_end_token(M),\n                    aliases: aliases,\n                    keys: keys,\n                    path: from_moz(M.source),\n                });\n            }\n            return new AST_ExportReferences({\n                start: my_start_token(M),\n                end: my_end_token(M),\n                properties: M.specifiers.map(function(prop) {\n                    var sym = new AST_SymbolExport(from_moz(prop.local));\n                    sym.alias = from_moz_alias(prop.exported);\n                    return sym;\n                }),\n            });\n        },\n        ImportDeclaration: function(M) {\n            var start = my_start_token(M);\n            var end = my_end_token(M);\n            var all = null, def = null, props = null;\n            M.specifiers.forEach(function(prop) {\n                var sym = new AST_SymbolImport(from_moz(prop.local));\n                switch (prop.type) {\n                  case \"ImportDefaultSpecifier\":\n                    def = sym;\n                    def.key = new AST_String({\n                        start: start,\n                        value: \"\",\n                        end: end,\n                    });\n                    break;\n                  case \"ImportNamespaceSpecifier\":\n                    all = sym;\n                    all.key = new AST_String({\n                        start: start,\n                        value: \"*\",\n                        end: end,\n                    });\n                    break;\n                  default:\n                    sym.key = from_moz_alias(prop.imported);\n                    if (!props) props = [];\n                    props.push(sym);\n                    break;\n                }\n            });\n            return new AST_Import({\n                start: start,\n                end: end,\n                all: all,\n                default: def,\n                properties: props,\n                path: from_moz(M.source),\n            });\n        },\n        ImportExpression: function(M) {\n            var start = my_start_token(M);\n            var arg = from_moz(M.source);\n            return new AST_Call({\n                start: start,\n                end: my_end_token(M),\n                expression: new AST_SymbolRef({\n                    start: start,\n                    end: arg.start,\n                    name: \"import\",\n                }),\n                args: [ arg ],\n            });\n        },\n        VariableDeclaration: function(M) {\n            return new ({\n                const: AST_Const,\n                let: AST_Let,\n            }[M.kind] || AST_Var)({\n                start: my_start_token(M),\n                end: my_end_token(M),\n                definitions: M.declarations.map(from_moz),\n            });\n        },\n        Literal: function(M) {\n            var args = {\n                start: my_start_token(M),\n                end: my_end_token(M),\n            };\n            if (M.bigint) {\n                args.value = M.bigint.toLowerCase();\n                return new AST_BigInt(args);\n            }\n            var val = M.value;\n            if (val === null) return new AST_Null(args);\n            var rx = M.regex;\n            if (rx && rx.pattern) {\n                // RegExpLiteral as per ESTree AST spec\n                args.value = new RegExp(rx.pattern, rx.flags);\n                args.value.raw_source = rx.pattern;\n                return new AST_RegExp(args);\n            } else if (rx) {\n                // support legacy RegExp\n                args.value = M.regex && M.raw ? M.raw : val;\n                return new AST_RegExp(args);\n            }\n            switch (typeof val) {\n              case \"string\":\n                args.value = val;\n                return new AST_String(args);\n              case \"number\":\n                if (isNaN(val)) return new AST_NaN(args);\n                var negate, node;\n                if (isFinite(val)) {\n                    negate = 1 / val < 0;\n                    args.value = negate ? -val : val;\n                    node = new AST_Number(args);\n                } else {\n                    negate = val < 0;\n                    node = new AST_Infinity(args);\n                }\n                return negate ? new AST_UnaryPrefix({\n                    start: args.start,\n                    end: args.end,\n                    operator: \"-\",\n                    expression: node,\n                }) : node;\n              case \"boolean\":\n                return new (val ? AST_True : AST_False)(args);\n            }\n        },\n        TemplateLiteral: function(M) {\n            return new AST_Template({\n                start: my_start_token(M),\n                end: my_end_token(M),\n                expressions: M.expressions.map(from_moz),\n                strings: M.quasis.map(function(el) {\n                    return el.value.raw;\n                }),\n            });\n        },\n        TaggedTemplateExpression: function(M) {\n            var tmpl = from_moz(M.quasi);\n            tmpl.start = my_start_token(M);\n            tmpl.end = my_end_token(M);\n            tmpl.tag = from_moz(M.tag);\n            return tmpl;\n        },\n        Identifier: function(M) {\n            var p, level = FROM_MOZ_STACK.length - 1;\n            do {\n                p = FROM_MOZ_STACK[--level];\n            } while (p.type == \"ArrayPattern\"\n                || p.type == \"AssignmentPattern\" && p.left === FROM_MOZ_STACK[level + 1]\n                || p.type == \"ObjectPattern\"\n                || p.type == \"Property\" && p.value === FROM_MOZ_STACK[level + 1]\n                || p.type == \"VariableDeclarator\" && p.id === FROM_MOZ_STACK[level + 1]);\n            var ctor = AST_SymbolRef;\n            switch (p.type) {\n              case \"ArrowFunctionExpression\":\n                if (p.body !== FROM_MOZ_STACK[level + 1]) ctor = AST_SymbolFunarg;\n                break;\n              case \"BreakStatement\":\n              case \"ContinueStatement\":\n                ctor = AST_LabelRef;\n                break;\n              case \"CatchClause\":\n                ctor = AST_SymbolCatch;\n                break;\n              case \"ClassDeclaration\":\n                if (p.id === FROM_MOZ_STACK[level + 1]) ctor = AST_SymbolDefClass;\n                break;\n              case \"ClassExpression\":\n                if (p.id === FROM_MOZ_STACK[level + 1]) ctor = AST_SymbolClass;\n                break;\n              case \"FunctionDeclaration\":\n                ctor = p.id === FROM_MOZ_STACK[level + 1] ? AST_SymbolDefun : AST_SymbolFunarg;\n                break;\n              case \"FunctionExpression\":\n                ctor = p.id === FROM_MOZ_STACK[level + 1] ? AST_SymbolLambda : AST_SymbolFunarg;\n                break;\n              case \"LabeledStatement\":\n                ctor = AST_Label;\n                break;\n              case \"VariableDeclaration\":\n                ctor = {\n                    const: AST_SymbolConst,\n                    let: AST_SymbolLet,\n                }[p.kind] || AST_SymbolVar;\n                break;\n            }\n            return new ctor({\n                start: my_start_token(M),\n                end: my_end_token(M),\n                name: M.name,\n            });\n        },\n        Super: function(M) {\n            return new AST_Super({\n                start: my_start_token(M),\n                end: my_end_token(M),\n                name: \"super\",\n            });\n        },\n        ThisExpression: function(M) {\n            return new AST_This({\n                start: my_start_token(M),\n                end: my_end_token(M),\n                name: \"this\",\n            });\n        },\n        ParenthesizedExpression: function(M) {\n            var node = from_moz(M.expression);\n            if (!node.start.parens) node.start.parens = [];\n            node.start.parens.push(my_start_token(M));\n            if (!node.end.parens) node.end.parens = [];\n            node.end.parens.push(my_end_token(M));\n            return node;\n        },\n        ChainExpression: function(M) {\n            var node = from_moz(M.expression);\n            node.terminal = true;\n            return node;\n        },\n    };\n\n    MOZ_TO_ME.UpdateExpression =\n    MOZ_TO_ME.UnaryExpression = function To_Moz_Unary(M) {\n        var prefix = \"prefix\" in M ? M.prefix\n            : M.type == \"UnaryExpression\" ? true : false;\n        return new (prefix ? AST_UnaryPrefix : AST_UnaryPostfix)({\n            start      : my_start_token(M),\n            end        : my_end_token(M),\n            operator   : M.operator,\n            expression : from_moz(M.argument)\n        });\n    };\n\n    map(\"EmptyStatement\", AST_EmptyStatement);\n    map(\"ExpressionStatement\", AST_SimpleStatement, \"expression>body\");\n    map(\"BlockStatement\", AST_BlockStatement, \"body@body\");\n    map(\"IfStatement\", AST_If, \"test>condition, consequent>body, alternate>alternative\");\n    map(\"LabeledStatement\", AST_LabeledStatement, \"label>label, body>body\");\n    map(\"BreakStatement\", AST_Break, \"label>label\");\n    map(\"ContinueStatement\", AST_Continue, \"label>label\");\n    map(\"WithStatement\", AST_With, \"object>expression, body>body\");\n    map(\"SwitchStatement\", AST_Switch, \"discriminant>expression, cases@body\");\n    map(\"ReturnStatement\", AST_Return, \"argument>value\");\n    map(\"ThrowStatement\", AST_Throw, \"argument>value\");\n    map(\"WhileStatement\", AST_While, \"test>condition, body>body\");\n    map(\"DoWhileStatement\", AST_Do, \"test>condition, body>body\");\n    map(\"ForStatement\", AST_For, \"init>init, test>condition, update>step, body>body\");\n    map(\"ForInStatement\", AST_ForIn, \"left>init, right>object, body>body\");\n    map(\"DebuggerStatement\", AST_Debugger);\n    map(\"VariableDeclarator\", AST_VarDef, \"id>name, init>value\");\n    map(\"CatchClause\", AST_Catch, \"param>argname, body%body\");\n\n    map(\"BinaryExpression\", AST_Binary, \"operator=operator, left>left, right>right\");\n    map(\"LogicalExpression\", AST_Binary, \"operator=operator, left>left, right>right\");\n    map(\"AssignmentExpression\", AST_Assign, \"operator=operator, left>left, right>right\");\n    map(\"AssignmentPattern\", AST_DefaultValue, \"left>name, right>value\");\n    map(\"ConditionalExpression\", AST_Conditional, \"test>condition, consequent>consequent, alternate>alternative\");\n    map(\"NewExpression\", AST_New, \"callee>expression, arguments@args, pure=pure\");\n    map(\"SequenceExpression\", AST_Sequence, \"expressions@expressions\");\n    map(\"SpreadElement\", AST_Spread, \"argument>expression\");\n    map(\"ObjectExpression\", AST_Object, \"properties@properties\");\n    map(\"AwaitExpression\", AST_Await, \"argument>expression\");\n    map(\"YieldExpression\", AST_Yield, \"argument>expression, delegate=nested\");\n\n    def_to_moz(AST_Toplevel, function To_Moz_Program(M) {\n        return to_moz_scope(\"Program\", M);\n    });\n\n    def_to_moz(AST_LambdaDefinition, function To_Moz_FunctionDeclaration(M) {\n        var params = M.argnames.map(to_moz);\n        if (M.rest) params.push({\n            type: \"RestElement\",\n            argument: to_moz(M.rest),\n        });\n        return {\n            type: \"FunctionDeclaration\",\n            id: to_moz(M.name),\n            async: is_async(M),\n            generator: is_generator(M),\n            params: params,\n            body: to_moz_scope(\"BlockStatement\", M),\n        };\n    });\n\n    def_to_moz(AST_Lambda, function To_Moz_FunctionExpression(M) {\n        var params = M.argnames.map(to_moz);\n        if (M.rest) params.push({\n            type: \"RestElement\",\n            argument: to_moz(M.rest),\n        });\n        if (is_arrow(M)) return {\n            type: \"ArrowFunctionExpression\",\n            async: is_async(M),\n            params: params,\n            expression: !!M.value,\n            body: M.value ? to_moz(M.value) : to_moz_scope(\"BlockStatement\", M),\n        };\n        return {\n            type: \"FunctionExpression\",\n            id: to_moz(M.name),\n            async: is_async(M),\n            generator: is_generator(M),\n            params: params,\n            body: to_moz_scope(\"BlockStatement\", M),\n        };\n    });\n\n    def_to_moz(AST_Call, function To_Moz_CallExpression(M) {\n        var expr = M.expression;\n        if (M.args.length == 1 && expr instanceof AST_SymbolRef && expr.name == \"import\") return {\n            type: \"ImportExpression\",\n            source: to_moz(M.args[0]),\n        };\n        return {\n            type: \"CallExpression\",\n            callee: to_moz(expr),\n            arguments: M.args.map(to_moz),\n            optional: M.optional,\n            pure: M.pure,\n        };\n    });\n\n    def_to_moz(AST_DefClass, function To_Moz_ClassDeclaration(M) {\n        return {\n            type: \"ClassDeclaration\",\n            id: to_moz(M.name),\n            superClass: to_moz(M.extends),\n            body: {\n                type: \"ClassBody\",\n                body: M.properties.map(to_moz),\n            },\n        };\n    });\n\n    def_to_moz(AST_ClassExpression, function To_Moz_ClassExpression(M) {\n        return {\n            type: \"ClassExpression\",\n            id: to_moz(M.name),\n            superClass: to_moz(M.extends),\n            body: {\n                type: \"ClassBody\",\n                body: M.properties.map(to_moz),\n            },\n        };\n    });\n\n    function To_Moz_MethodDefinition(kind) {\n        return function(M) {\n            var computed = M.key instanceof AST_Node;\n            var key = computed ? to_moz(M.key) : M.private ? {\n                type: \"PrivateIdentifier\",\n                name: M.key.slice(1),\n            } : {\n                type: \"Literal\",\n                value: M.key,\n            };\n            return {\n                type: \"MethodDefinition\",\n                kind: kind,\n                computed: computed,\n                key: key,\n                static: M.static,\n                value: to_moz(M.value),\n            };\n        };\n    }\n    def_to_moz(AST_ClassGetter, To_Moz_MethodDefinition(\"get\"));\n    def_to_moz(AST_ClassSetter, To_Moz_MethodDefinition(\"set\"));\n    def_to_moz(AST_ClassMethod, To_Moz_MethodDefinition(\"method\"));\n\n    def_to_moz(AST_ClassField, function To_Moz_PropertyDefinition(M) {\n        var computed = M.key instanceof AST_Node;\n        var key = computed ? to_moz(M.key) : M.private ? {\n            type: \"PrivateIdentifier\",\n            name: M.key.slice(1),\n        } : {\n            type: \"Literal\",\n            value: M.key,\n        };\n        return {\n            type: \"PropertyDefinition\",\n            computed: computed,\n            key: key,\n            static: M.static,\n            value: to_moz(M.value),\n        };\n    });\n\n    def_to_moz(AST_ClassInit, function To_Moz_StaticBlock(M) {\n        return to_moz_scope(\"StaticBlock\", M.value);\n    });\n\n    function To_Moz_ForOfStatement(is_await) {\n        return function(M) {\n            return {\n                type: \"ForOfStatement\",\n                await: is_await,\n                left: to_moz(M.init),\n                right: to_moz(M.object),\n                body: to_moz(M.body),\n            };\n        };\n    }\n    def_to_moz(AST_ForAwaitOf, To_Moz_ForOfStatement(true));\n    def_to_moz(AST_ForOf, To_Moz_ForOfStatement(false));\n\n    def_to_moz(AST_Directive, function To_Moz_Directive(M) {\n        return {\n            type: \"ExpressionStatement\",\n            directive: M.value,\n            expression: set_moz_loc(M, {\n                type: \"Literal\",\n                value: M.value,\n            }),\n        };\n    });\n\n    def_to_moz(AST_SwitchBranch, function To_Moz_SwitchCase(M) {\n        return {\n            type: \"SwitchCase\",\n            test: to_moz(M.expression),\n            consequent: M.body.map(to_moz),\n        };\n    });\n\n    def_to_moz(AST_Try, function To_Moz_TryStatement(M) {\n        return {\n            type: \"TryStatement\",\n            block: to_moz_block(M),\n            handler: to_moz(M.bcatch),\n            finalizer: to_moz(M.bfinally),\n        };\n    });\n\n    def_to_moz(AST_Catch, function To_Moz_CatchClause(M) {\n        return {\n            type: \"CatchClause\",\n            param: to_moz(M.argname),\n            body: to_moz_block(M),\n        };\n    });\n\n    def_to_moz(AST_ExportDeclaration, function To_Moz_ExportNamedDeclaration_declaration(M) {\n        return {\n            type: \"ExportNamedDeclaration\",\n            declaration: to_moz(M.body),\n            specifiers: [],\n        };\n    });\n\n    def_to_moz(AST_ExportDefault, function To_Moz_ExportDefaultDeclaration(M) {\n        return {\n            type: \"ExportDefaultDeclaration\",\n            declaration: to_moz(M.body),\n        };\n    });\n\n    def_to_moz(AST_ExportForeign, function To_Moz_ExportAllDeclaration_ExportNamedDeclaration(M) {\n        if (M.keys[0].value == \"*\") return {\n            type: \"ExportAllDeclaration\",\n            exported: M.aliases[0].value == \"*\" ? null : to_moz_alias(M.aliases[0]),\n            source: to_moz(M.path),\n        };\n        var specifiers = [];\n        for (var i = 0; i < M.aliases.length; i++) {\n            specifiers.push(set_moz_loc({\n                start: M.keys[i].start,\n                end: M.aliases[i].end,\n            }, {\n                type: \"ExportSpecifier\",\n                local: to_moz_alias(M.keys[i]),\n                exported: to_moz_alias(M.aliases[i]),\n            }));\n        }\n        return {\n            type: \"ExportNamedDeclaration\",\n            specifiers: specifiers,\n            source: to_moz(M.path),\n        };\n    });\n\n    def_to_moz(AST_ExportReferences, function To_Moz_ExportNamedDeclaration_specifiers(M) {\n        return {\n            type: \"ExportNamedDeclaration\",\n            specifiers: M.properties.map(function(prop) {\n                return set_moz_loc({\n                    start: prop.start,\n                    end: prop.alias.end,\n                }, {\n                    type: \"ExportSpecifier\",\n                    local: to_moz(prop),\n                    exported: to_moz_alias(prop.alias),\n                });\n            }),\n        };\n    });\n\n    def_to_moz(AST_Import, function To_Moz_ImportDeclaration(M) {\n        var specifiers = M.properties ? M.properties.map(function(prop) {\n            return set_moz_loc({\n                start: prop.key.start,\n                end: prop.end,\n            }, {\n                type: \"ImportSpecifier\",\n                local: to_moz(prop),\n                imported: to_moz_alias(prop.key),\n            });\n        }) : [];\n        if (M.all) specifiers.unshift(set_moz_loc(M.all, {\n            type: \"ImportNamespaceSpecifier\",\n            local: to_moz(M.all),\n        }));\n        if (M.default) specifiers.unshift(set_moz_loc(M.default, {\n            type: \"ImportDefaultSpecifier\",\n            local: to_moz(M.default),\n        }));\n        return {\n            type: \"ImportDeclaration\",\n            specifiers: specifiers,\n            source: to_moz(M.path),\n        };\n    });\n\n    def_to_moz(AST_Definitions, function To_Moz_VariableDeclaration(M) {\n        return {\n            type: \"VariableDeclaration\",\n            kind: M.TYPE.toLowerCase(),\n            declarations: M.definitions.map(to_moz),\n        };\n    });\n\n    def_to_moz(AST_PropAccess, function To_Moz_MemberExpression(M) {\n        var computed = M instanceof AST_Sub;\n        var expr = {\n            type: \"MemberExpression\",\n            object: to_moz(M.expression),\n            computed: computed,\n            optional: M.optional,\n            property: computed ? to_moz(M.property) : {\n                type: \"Identifier\",\n                name: M.property,\n            },\n        };\n        return M.terminal ? {\n            type: \"ChainExpression\",\n            expression: expr,\n        } : expr;\n    });\n\n    def_to_moz(AST_Unary, function To_Moz_Unary(M) {\n        return {\n            type: M.operator == \"++\" || M.operator == \"--\" ? \"UpdateExpression\" : \"UnaryExpression\",\n            operator: M.operator,\n            prefix: M instanceof AST_UnaryPrefix,\n            argument: to_moz(M.expression)\n        };\n    });\n\n    def_to_moz(AST_Binary, function To_Moz_BinaryExpression(M) {\n        return {\n            type: M.operator == \"&&\" || M.operator == \"||\" ? \"LogicalExpression\" : \"BinaryExpression\",\n            left: to_moz(M.left),\n            operator: M.operator,\n            right: to_moz(M.right)\n        };\n    });\n\n    def_to_moz(AST_Array, function To_Moz_ArrayExpression(M) {\n        return {\n            type: \"ArrayExpression\",\n            elements: M.elements.map(to_moz),\n        };\n    });\n\n    def_to_moz(AST_DestructuredArray, function To_Moz_ArrayPattern(M) {\n        var elements = M.elements.map(to_moz);\n        if (M.rest) elements.push({\n            type: \"RestElement\",\n            argument: to_moz(M.rest),\n        });\n        return {\n            type: \"ArrayPattern\",\n            elements: elements,\n        };\n    });\n\n    def_to_moz(AST_DestructuredKeyVal, function To_Moz_Property(M) {\n        var computed = M.key instanceof AST_Node;\n        var key = computed ? to_moz(M.key) : {\n            type: \"Literal\",\n            value: M.key,\n        };\n        return {\n            type: \"Property\",\n            kind: \"init\",\n            computed: computed,\n            method: false,\n            shorthand: false,\n            key: key,\n            value: to_moz(M.value),\n        };\n    });\n\n    def_to_moz(AST_DestructuredObject, function To_Moz_ObjectPattern(M) {\n        var props = M.properties.map(to_moz);\n        if (M.rest) props.push({\n            type: \"RestElement\",\n            argument: to_moz(M.rest),\n        });\n        return {\n            type: \"ObjectPattern\",\n            properties: props,\n        };\n    });\n\n    def_to_moz(AST_ObjectProperty, function To_Moz_Property(M) {\n        var computed = M.key instanceof AST_Node;\n        var key = computed ? to_moz(M.key) : {\n            type: \"Literal\",\n            value: M.key,\n        };\n        var kind;\n        if (M instanceof AST_ObjectKeyVal) {\n            kind = \"init\";\n        } else if (M instanceof AST_ObjectGetter) {\n            kind = \"get\";\n        } else if (M instanceof AST_ObjectSetter) {\n            kind = \"set\";\n        }\n        return {\n            type: \"Property\",\n            kind: kind,\n            computed: computed,\n            method: M instanceof AST_ObjectMethod,\n            shorthand: false,\n            key: key,\n            value: to_moz(M.value),\n        };\n    });\n\n    def_to_moz(AST_Symbol, function To_Moz_Identifier(M) {\n        var def = M.definition();\n        return {\n            type: \"Identifier\",\n            name: def && def.mangled_name || M.name,\n        };\n    });\n\n    def_to_moz(AST_Super, function To_Moz_Super() {\n        return { type: \"Super\" };\n    });\n\n    def_to_moz(AST_This, function To_Moz_ThisExpression() {\n        return { type: \"ThisExpression\" };\n    });\n\n    def_to_moz(AST_NewTarget, function To_Moz_MetaProperty() {\n        return {\n            type: \"MetaProperty\",\n            meta: {\n                type: \"Identifier\",\n                name: \"new\",\n            },\n            property: {\n                type: \"Identifier\",\n                name: \"target\",\n            },\n        };\n    });\n\n    def_to_moz(AST_RegExp, function To_Moz_RegExpLiteral(M) {\n        var flags = M.value.toString().match(/\\/([gimuy]*)$/)[1];\n        var value = \"/\" + M.value.raw_source + \"/\" + flags;\n        return {\n            type: \"Literal\",\n            value: value,\n            raw: value,\n            regex: {\n                pattern: M.value.raw_source,\n                flags: flags,\n            },\n        };\n    });\n\n    def_to_moz(AST_BigInt, function To_Moz_BigInt(M) {\n        var value = M.value;\n        return {\n            type: \"Literal\",\n            bigint: value,\n            raw: value + \"n\",\n        };\n    });\n\n    function To_Moz_Literal(M) {\n        var value = M.value;\n        if (typeof value === \"number\" && (value < 0 || (value === 0 && 1 / value < 0))) {\n            return {\n                type: \"UnaryExpression\",\n                operator: \"-\",\n                prefix: true,\n                argument: {\n                    type: \"Literal\",\n                    value: -value,\n                    raw: M.start.raw,\n                },\n            };\n        }\n        return {\n            type: \"Literal\",\n            value: value,\n            raw: M.start.raw,\n        };\n    }\n    def_to_moz(AST_Boolean, To_Moz_Literal);\n    def_to_moz(AST_Constant, To_Moz_Literal);\n    def_to_moz(AST_Null, To_Moz_Literal);\n\n    def_to_moz(AST_Atom, function To_Moz_Atom(M) {\n        return {\n            type: \"Identifier\",\n            name: String(M.value),\n        };\n    });\n\n    def_to_moz(AST_Template, function To_Moz_TemplateLiteral_TaggedTemplateExpression(M) {\n        var last = M.strings.length - 1;\n        var tmpl = {\n            type: \"TemplateLiteral\",\n            expressions: M.expressions.map(to_moz),\n            quasis: M.strings.map(function(str, index) {\n                return {\n                    type: \"TemplateElement\",\n                    tail: index == last,\n                    value: { raw: str },\n                };\n            }),\n        };\n        if (!M.tag) return tmpl;\n        return {\n            type: \"TaggedTemplateExpression\",\n            tag: to_moz(M.tag),\n            quasi: tmpl,\n        };\n    });\n\n    AST_Block.DEFMETHOD(\"to_mozilla_ast\", AST_BlockStatement.prototype.to_mozilla_ast);\n    AST_Hole.DEFMETHOD(\"to_mozilla_ast\", return_null);\n    AST_Node.DEFMETHOD(\"to_mozilla_ast\", function() {\n        throw new Error(\"Cannot convert AST_\" + this.TYPE);\n    });\n\n    /* -----[ tools ]----- */\n\n    function normalize_directives(body) {\n        for (var i = 0; i < body.length; i++) {\n            var stat = body[i];\n            if (!(stat instanceof AST_SimpleStatement)) break;\n            var node = stat.body;\n            if (!(node instanceof AST_String)) break;\n            if (stat.start.pos !== node.start.pos) break;\n            body[i] = new AST_Directive(node);\n        }\n        return body;\n    }\n\n    function raw_token(moznode) {\n        if (moznode.type == \"Literal\") {\n            return moznode.raw != null ? moznode.raw : moznode.value + \"\";\n        }\n    }\n\n    function my_start_token(moznode) {\n        var loc = moznode.loc, start = loc && loc.start;\n        var range = moznode.range;\n        return new AST_Token({\n            file    : loc && loc.source,\n            line    : start && start.line,\n            col     : start && start.column,\n            pos     : range ? range[0] : moznode.start,\n            endline : start && start.line,\n            endcol  : start && start.column,\n            endpos  : range ? range[0] : moznode.start,\n            raw     : raw_token(moznode),\n        });\n    }\n\n    function my_end_token(moznode) {\n        var loc = moznode.loc, end = loc && loc.end;\n        var range = moznode.range;\n        return new AST_Token({\n            file    : loc && loc.source,\n            line    : end && end.line,\n            col     : end && end.column,\n            pos     : range ? range[1] : moznode.end,\n            endline : end && end.line,\n            endcol  : end && end.column,\n            endpos  : range ? range[1] : moznode.end,\n            raw     : raw_token(moznode),\n        });\n    }\n\n    function read_name(M) {\n        return \"\" + M[M.type == \"Identifier\" ? \"name\" : \"value\"];\n    }\n\n    function map(moztype, mytype, propmap) {\n        var moz_to_me = [\n            \"start: my_start_token(M)\",\n            \"end: my_end_token(M)\",\n        ];\n        var me_to_moz = [\n            \"type: \" + JSON.stringify(moztype),\n        ];\n\n        if (propmap) propmap.split(/\\s*,\\s*/).forEach(function(prop) {\n            var m = /([a-z0-9$_]+)(=|@|>|%)([a-z0-9$_]+)/i.exec(prop);\n            if (!m) throw new Error(\"Can't understand property map: \" + prop);\n            var moz = m[1], how = m[2], my = m[3];\n            switch (how) {\n              case \"@\":\n                moz_to_me.push(my + \": M.\" + moz + \".map(from_moz)\");\n                me_to_moz.push(moz + \": M.\" +  my + \".map(to_moz)\");\n                break;\n              case \">\":\n                moz_to_me.push(my + \": from_moz(M.\" + moz + \")\");\n                me_to_moz.push(moz + \": to_moz(M.\" + my + \")\");\n                break;\n              case \"=\":\n                moz_to_me.push(my + \": M.\" + moz);\n                me_to_moz.push(moz + \": M.\" + my);\n                break;\n              case \"%\":\n                moz_to_me.push(my + \": from_moz(M.\" + moz + \").body\");\n                me_to_moz.push(moz + \": to_moz_block(M)\");\n                break;\n              default:\n                throw new Error(\"Can't understand operator in propmap: \" + prop);\n            }\n        });\n\n        MOZ_TO_ME[moztype] = new Function(\"U2\", \"my_start_token\", \"my_end_token\", \"from_moz\", [\n            \"return function From_Moz_\" + moztype + \"(M) {\",\n            \"    return new U2.AST_\" + mytype.TYPE + \"({\",\n            moz_to_me.join(\",\\n\"),\n            \"    });\",\n            \"};\",\n        ].join(\"\\n\"))(exports, my_start_token, my_end_token, from_moz);\n        def_to_moz(mytype, new Function(\"to_moz\", \"to_moz_block\", \"to_moz_scope\", [\n            \"return function To_Moz_\" + moztype + \"(M) {\",\n            \"    return {\",\n            me_to_moz.join(\",\\n\"),\n            \"    };\",\n            \"};\",\n        ].join(\"\\n\"))(to_moz, to_moz_block, to_moz_scope));\n    }\n\n    var FROM_MOZ_STACK = null;\n\n    function from_moz(moz) {\n        FROM_MOZ_STACK.push(moz);\n        var node = null;\n        if (moz) {\n            if (!HOP(MOZ_TO_ME, moz.type)) throw new Error(\"Unsupported type: \" + moz.type);\n            node = MOZ_TO_ME[moz.type](moz);\n        }\n        FROM_MOZ_STACK.pop();\n        return node;\n    }\n\n    function from_moz_alias(moz) {\n        return new AST_String({\n            start: my_start_token(moz),\n            value: read_name(moz),\n            end: my_end_token(moz),\n        });\n    }\n\n    AST_Node.from_mozilla_ast = function(node) {\n        var save_stack = FROM_MOZ_STACK;\n        FROM_MOZ_STACK = [];\n        var ast = from_moz(node);\n        FROM_MOZ_STACK = save_stack;\n        ast.walk(new TreeWalker(function(node) {\n            if (node instanceof AST_LabelRef) {\n                for (var level = 0, parent; parent = this.parent(level); level++) {\n                    if (parent instanceof AST_Scope) break;\n                    if (parent instanceof AST_LabeledStatement && parent.label.name == node.name) {\n                        node.thedef = parent.label;\n                        break;\n                    }\n                }\n                if (!node.thedef) {\n                    var s = node.start;\n                    js_error(\"Undefined label \" + node.name, s.file, s.line, s.col, s.pos);\n                }\n            }\n        }));\n        return ast;\n    };\n\n    function set_moz_loc(mynode, moznode) {\n        var start = mynode.start;\n        var end = mynode.end;\n        if (start.pos != null && end.endpos != null) {\n            moznode.range = [start.pos, end.endpos];\n        }\n        if (start.line) {\n            moznode.loc = {\n                start: {line: start.line, column: start.col},\n                end: end.endline ? {line: end.endline, column: end.endcol} : null,\n            };\n            if (start.file) {\n                moznode.loc.source = start.file;\n            }\n        }\n        return moznode;\n    }\n\n    function def_to_moz(mytype, handler) {\n        mytype.DEFMETHOD(\"to_mozilla_ast\", function() {\n            return set_moz_loc(this, handler(this));\n        });\n    }\n\n    function to_moz(node) {\n        return node != null ? node.to_mozilla_ast() : null;\n    }\n\n    function to_moz_alias(alias) {\n        return is_identifier_string(alias.value) ? set_moz_loc(alias, {\n            type: \"Identifier\",\n            name: alias.value,\n        }) : to_moz(alias);\n    }\n\n    function to_moz_block(node) {\n        return {\n            type: \"BlockStatement\",\n            body: node.body.map(to_moz),\n        };\n    }\n\n    function to_moz_scope(type, node) {\n        var body = node.body.map(to_moz);\n        if (node.body[0] instanceof AST_SimpleStatement && node.body[0].body instanceof AST_String) {\n            body.unshift(to_moz(new AST_EmptyStatement(node.body[0])));\n        }\n        return {\n            type: type,\n            body: body,\n        };\n    }\n})();\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}